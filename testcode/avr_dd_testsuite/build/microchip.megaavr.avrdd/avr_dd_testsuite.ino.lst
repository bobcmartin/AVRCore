
C:\Users\c40769\AppData\Local\arduino\sketches\AE2793EB58938CDDEA48F57C9220A6DC/avr_dd_testsuite.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	07 c6       	rjmp	.+3086   	; 0xc10 <__dtors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	39 c6       	rjmp	.+3186   	; 0xc78 <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	37 c6       	rjmp	.+3182   	; 0xc78 <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	35 c6       	rjmp	.+3178   	; 0xc78 <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	33 c6       	rjmp	.+3174   	; 0xc78 <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	31 c6       	rjmp	.+3170   	; 0xc78 <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	2f c6       	rjmp	.+3166   	; 0xc78 <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	2d c6       	rjmp	.+3162   	; 0xc78 <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	2b c6       	rjmp	.+3158   	; 0xc78 <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	29 c6       	rjmp	.+3154   	; 0xc78 <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	27 c6       	rjmp	.+3150   	; 0xc78 <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	25 c6       	rjmp	.+3146   	; 0xc78 <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	23 c6       	rjmp	.+3142   	; 0xc78 <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	21 c6       	rjmp	.+3138   	; 0xc78 <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	1f c6       	rjmp	.+3134   	; 0xc78 <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	1d c6       	rjmp	.+3130   	; 0xc78 <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	1b c6       	rjmp	.+3126   	; 0xc78 <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	19 c6       	rjmp	.+3122   	; 0xc78 <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	0c 94 bb 18 	jmp	0x3176	; 0x3176 <__vector_18>
../../../../crt1/gcrt1.S:85
      4c:	15 c6       	rjmp	.+3114   	; 0xc78 <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	13 c6       	rjmp	.+3110   	; 0xc78 <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	0c 94 38 18 	jmp	0x3070	; 0x3070 <__vector_21>
../../../../crt1/gcrt1.S:88
      58:	0c 94 32 18 	jmp	0x3064	; 0x3064 <__vector_22>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 3e 18 	jmp	0x307c	; 0x307c <__vector_23>
../../../../crt1/gcrt1.S:90
      60:	0b c6       	rjmp	.+3094   	; 0xc78 <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	09 c6       	rjmp	.+3090   	; 0xc78 <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	07 c6       	rjmp	.+3086   	; 0xc78 <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	05 c6       	rjmp	.+3082   	; 0xc78 <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	03 c6       	rjmp	.+3078   	; 0xc78 <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	01 c6       	rjmp	.+3074   	; 0xc78 <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	0c 94 16 18 	jmp	0x302c	; 0x302c <__vector_30>
../../../../crt1/gcrt1.S:97
      7c:	fd c5       	rjmp	.+3066   	; 0xc78 <__bad_interrupt>
      7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
      80:	fb c5       	rjmp	.+3062   	; 0xc78 <__bad_interrupt>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	f9 c5       	rjmp	.+3058   	; 0xc78 <__bad_interrupt>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	f7 c5       	rjmp	.+3054   	; 0xc78 <__bad_interrupt>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	f5 c5       	rjmp	.+3050   	; 0xc78 <__bad_interrupt>
	...

00000090 <__trampolines_end>:
__trampolines_start():
      90:	00 01       	movw	r0, r0
      92:	03 07       	cpc	r16, r19
      94:	0f 1f       	adc	r16, r31
      96:	3f 7f       	andi	r19, 0xFF	; 255

00000098 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int)::premask>:
      98:	00 80 c0 e0 f0 f8 fc fe                             ........

000000a0 <font>:
      a0:	00 00 00 00 00 3e 5b 4f 5b 3e 3e 6b 4f 6b 3e 1c     .....>[O[>>kOk>.
      b0:	3e 7c 3e 1c 18 3c 7e 3c 18 1c 57 7d 57 1c 1c 5e     >|>..<~<..W}W..^
      c0:	7f 5e 1c 00 18 3c 18 00 ff e7 c3 e7 ff 00 18 24     .^...<.........$
      d0:	18 00 ff e7 db e7 ff 30 48 3a 06 0e 26 29 79 29     .......0H:..&)y)
      e0:	26 40 7f 05 05 07 40 7f 05 25 3f 5a 3c e7 3c 5a     &@....@..%?Z<.<Z
      f0:	7f 3e 1c 1c 08 08 1c 1c 3e 7f 14 22 7f 22 14 5f     .>......>.."."._
     100:	5f 00 5f 5f 06 09 7f 01 7f 00 66 89 95 6a 60 60     _.__......f..j``
     110:	60 60 60 94 a2 ff a2 94 08 04 7e 04 08 10 20 7e     ```.......~... ~
     120:	20 10 08 08 2a 1c 08 08 1c 2a 08 08 1e 10 10 10      ...*....*......
     130:	10 0c 1e 0c 1e 0c 30 38 3e 38 30 06 0e 3e 0e 06     ......08>80..>..
     140:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
     150:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
     160:	56 20 50 00 08 07 03 00 00 1c 22 41 00 00 41 22     V P......."A..A"
     170:	1c 00 2a 1c 7f 1c 2a 08 08 3e 08 08 00 80 70 30     ..*...*..>....p0
     180:	00 08 08 08 08 08 00 00 60 60 00 20 10 08 04 02     ........``. ....
     190:	3e 51 49 45 3e 00 42 7f 40 00 72 49 49 49 46 21     >QIE>.B.@.rIIIF!
     1a0:	41 49 4d 33 18 14 12 7f 10 27 45 45 45 39 3c 4a     AIM3.....'EEE9<J
     1b0:	49 49 31 41 21 11 09 07 36 49 49 49 36 46 49 49     II1A!...6III6FII
     1c0:	29 1e 00 00 14 00 00 00 40 34 00 00 00 08 14 22     ).......@4....."
     1d0:	41 14 14 14 14 14 00 41 22 14 08 02 01 59 09 06     A......A"....Y..
     1e0:	3e 41 5d 59 4e 7c 12 11 12 7c 7f 49 49 49 36 3e     >A]YN|...|.III6>
     1f0:	41 41 41 22 7f 41 41 41 3e 7f 49 49 49 41 7f 09     AAA".AAA>.IIIA..
     200:	09 09 01 3e 41 41 51 73 7f 08 08 08 7f 00 41 7f     ...>AAQs......A.
     210:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     220:	40 7f 02 1c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     230:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 26     .....>AQ!^...)F&
     240:	49 49 49 32 03 01 7f 01 03 3f 40 40 40 3f 1f 20     III2.....?@@@?. 
     250:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 03 04 78     @ .?@8@?c...c..x
     260:	04 03 61 59 49 4d 43 00 7f 41 41 41 02 04 08 10     ..aYIMC..AAA....
     270:	20 00 41 41 41 7f 04 02 01 02 04 40 40 40 40 40      .AAA......@@@@@
     280:	00 03 07 08 00 20 54 54 78 40 7f 28 44 44 38 38     ..... TTx@.(DD88
     290:	44 44 44 28 38 44 44 28 7f 38 54 54 54 18 00 08     DDD(8DD(.8TTT...
     2a0:	7e 09 02 18 a4 a4 9c 78 7f 08 04 04 78 00 44 7d     ~......x....x.D}
     2b0:	40 00 20 40 40 3d 00 7f 10 28 44 00 00 41 7f 40     @. @@=...(D..A.@
     2c0:	00 7c 04 78 04 78 7c 08 04 04 78 38 44 44 44 38     .|.x.x|...x8DDD8
     2d0:	fc 18 24 24 18 18 24 24 18 fc 7c 08 04 04 08 48     ..$$..$$..|....H
     2e0:	54 54 54 24 04 04 3f 44 24 3c 40 40 20 7c 1c 20     TTT$..?D$<@@ |. 
     2f0:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 4c 90 90     @ .<@0@<D(.(DL..
     300:	90 7c 44 64 54 4c 44 00 08 36 41 00 00 00 77 00     .|DdTLD..6A...w.
     310:	00 00 41 36 08 00 02 01 02 04 02 3c 26 23 26 3c     ..A6.......<&#&<
     320:	1e a1 a1 61 12 3a 40 40 20 7a 38 54 54 55 59 21     ...a.:@@ z8TTUY!
     330:	55 55 79 41 22 54 54 78 42 21 55 54 78 40 20 54     UUyA"TTxB!UTx@ T
     340:	55 79 40 0c 1e 52 72 12 39 55 55 55 59 39 54 54     Uy@..Rr.9UUUY9TT
     350:	54 59 39 55 54 54 58 00 00 45 7c 41 00 02 45 7d     TY9UTTX..E|A..E}
     360:	42 00 01 45 7c 40 7d 12 11 12 7d f0 28 25 28 f0     B..E|@}...}.(%(.
     370:	7c 54 55 45 00 20 54 54 7c 54 7c 0a 09 7f 49 32     |TUE. TT|T|...I2
     380:	49 49 49 32 3a 44 44 44 3a 32 4a 48 48 30 3a 41     III2:DDD:2JHH0:A
     390:	41 21 7a 3a 42 40 20 78 00 9d a0 a0 7d 3d 42 42     A!z:B@ x....}=BB
     3a0:	42 3d 3d 40 40 40 3d 3c 24 ff 24 24 48 7e 49 43     B==@@@=<$.$$H~IC
     3b0:	66 2b 2f fc 2f 2b ff 09 29 f6 20 c0 88 7e 09 03     f+/./+..). ..~..
     3c0:	20 54 54 79 41 00 00 44 7d 41 30 48 48 4a 32 38      TTyA..D}A0HHJ28
     3d0:	40 40 22 7a 00 7a 0a 0a 72 7d 0d 19 31 7d 26 29     @@"z.z..r}..1}&)
     3e0:	29 2f 28 26 29 29 29 26 30 48 4d 40 20 38 08 08     )/(&)))&0HM@ 8..
     3f0:	08 08 08 08 08 08 38 2f 10 c8 ac ba 2f 10 28 34     ......8/..../.(4
     400:	fa 00 00 7b 00 00 08 14 2a 14 22 22 14 2a 14 08     ...{....*."".*..
     410:	55 00 55 00 55 aa 55 aa 55 aa ff 55 ff 55 ff 00     U.U.U.U.U..U.U..
     420:	00 00 ff 00 10 10 10 ff 00 14 14 14 ff 00 10 10     ................
     430:	ff 00 ff 10 10 f0 10 f0 14 14 14 fc 00 14 14 f7     ................
     440:	00 ff 00 00 ff 00 ff 14 14 f4 04 fc 14 14 17 10     ................
     450:	1f 10 10 1f 10 1f 14 14 14 1f 00 10 10 10 f0 00     ................
     460:	00 00 00 1f 10 10 10 10 1f 10 10 10 10 f0 10 00     ................
     470:	00 00 ff 10 10 10 10 10 10 10 10 10 ff 10 00 00     ................
     480:	00 ff 14 00 00 ff 00 ff 00 00 1f 10 17 00 00 fc     ................
     490:	04 f4 14 14 17 10 17 14 14 f4 04 f4 00 00 ff 00     ................
     4a0:	f7 14 14 14 14 14 14 14 f7 00 f7 14 14 14 17 14     ................
     4b0:	10 10 1f 10 1f 14 14 14 f4 14 10 10 f0 10 f0 00     ................
     4c0:	00 1f 10 1f 00 00 00 1f 14 00 00 00 fc 14 00 00     ................
     4d0:	f0 10 f0 10 10 ff 10 ff 14 14 14 ff 14 10 10 10     ................
     4e0:	1f 00 00 00 00 f0 10 ff ff ff ff ff f0 f0 f0 f0     ................
     4f0:	f0 ff ff ff 00 00 00 00 00 ff ff 0f 0f 0f 0f 0f     ................
     500:	38 44 44 38 44 fc 4a 4a 4a 34 7e 02 02 06 06 02     8DD8D.JJJ4~.....
     510:	7e 02 7e 02 63 55 49 41 63 38 44 44 3c 04 40 7e     ~.~.cUIAc8DD<.@~
     520:	20 1e 20 06 02 7e 02 02 99 a5 e7 a5 99 1c 2a 49      . ..~........*I
     530:	2a 1c 4c 72 01 72 4c 30 4a 4d 4d 30 30 48 78 48     *.Lr.rL0JMM00HxH
     540:	30 bc 62 5a 46 3d 3e 49 49 49 00 7e 01 01 01 7e     0.bZF=>III.~...~
     550:	2a 2a 2a 2a 2a 44 44 5f 44 44 40 51 4a 44 40 40     *****DD_DD@QJD@@
     560:	44 4a 51 40 00 00 ff 01 03 e0 80 ff 00 00 08 08     DJQ@............
     570:	6b 6b 08 36 12 36 24 36 06 0f 09 0f 06 00 00 18     kk.6.6$6........
     580:	18 00 00 00 10 10 00 30 40 ff 01 01 00 1f 01 01     .......0@.......
     590:	1e 00 19 1d 17 12 00 3c 3c 3c 3c 00 00 00 00 00     .......<<<<.....

000005a0 <Adafruit_SSD1306::begin(unsigned char, unsigned char, bool, bool)::init5>:
     5a0:	db 40 a4 a6 2e af                                   .@....

000005a6 <Adafruit_SSD1306::begin(unsigned char, unsigned char, bool, bool)::init3>:
     5a6:	20 00 a1 c8                                          ...

000005aa <Adafruit_SSD1306::begin(unsigned char, unsigned char, bool, bool)::init2>:
     5aa:	d3 00 40 8d                                         ..@.

000005ae <Adafruit_SSD1306::begin(unsigned char, unsigned char, bool, bool)::init1>:
     5ae:	ae d5 80 a8                                         ....

000005b2 <splash2_data>:
     5b2:	00 00 60 00 00 00 00 00 00 00 00 00 00 00 00 00     ..`.............
     5c2:	00 e0 00 00 00 00 00 00 00 00 00 00 00 00 00 01     ................
     5d2:	e0 00 00 00 00 00 00 00 00 00 00 00 00 00 01 f0     ................
	...
     5ee:	00 03 f0 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     5fe:	07 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 07     ................
     60e:	f8 00 00 00 00 00 00 00 00 00 00 00 00 00 0f f8     ................
     61e:	00 00 00 03 c0 00 7e 00 00 01 e0 00 7f 0f f8 00     ......~.........
     62e:	00 00 03 c0 00 fe 00 00 01 e0 00 ff ef f8 00 00     ................
     63e:	00 03 c0 00 fe 00 00 01 e0 00 ff ff f8 00 00 00     ................
     64e:	03 c0 00 f0 00 00 00 0f 00 7f fe 7f c0 00 00 03     ................
     65e:	c0 00 f0 00 00 00 0f 00 3f fe 7f f8 3f f1 fb cf     ........?...?...
     66e:	fc fe f3 bc 3d ef e0 1f fe 7f ff 7f fb ff df fe     ....=...........
     67e:	fe ff bc 3d ef e0 1f c6 ff ff 7f fb ff df fe fe     ...=............
     68e:	ff bc 3d ef e0 0f e3 c7 fe 78 7b c3 de 1e f0 ff     ..=......x{.....
     69e:	bc 3d ef 00 07 ff 87 fc 78 7b c3 de 1e f0 f8 3c     .=......x{.....<
     6ae:	3d ef 00 01 ff ff f0 00 7b c3 c0 1e f0 f0 3c 3d     =.......{.....<=
     6be:	ef 00 01 f3 7f e0 3f fb c3 cf fe f0 f0 3c 3d ef     ......?......<=.
     6ce:	00 03 e3 3f 80 7f fb c3 df fe f0 f0 3c 3d ef 00     ...?........<=..
     6de:	07 e7 3c 00 78 7b c3 de 1e f0 f0 3c 3d ef 00 07     ..<.x{.....<=...
     6ee:	ff be 00 78 7b c3 de 1e f0 f0 3c 3d ef 00 07 ff     ...x{.....<=....
     6fe:	fe 00 78 7b c3 de 1e f0 f0 3c 3d ef 00 0f ff fe     ..x{.....<=.....
     70e:	00 7f fb ff df fe f0 f0 3f fd ef e0 0f ff ff 00     ........?.......
     71e:	7f fb ff df fe f0 f0 3f fd ef e0 0f f9 ff 00 3e     .......?.......>
     72e:	79 f9 cf 9e f0 f0 1f 3d e7 e0 1f f1 ff 00 00 00     y......=........
	...
     746:	00 1f 80 ff 00 7f ff ff ff ff ff ff ff ff ff e0     ................
     756:	1c 00 7f 00 7f ff ff ff fe b4 6d 88 8d 18 e0 00     ..........m.....
     766:	00 1f 00 7f ff ff ff fe 95 ad 7d b5 77 e0 00 00     ..........}.w...
     776:	0f 00 7f ff ff ff fe a5 ad 9d 8d 19 e0 00 00 06     ................
     786:	00 7f ff ff ff fe b5 ad ed b5 7e e0                 ..........~.

00000792 <splash1_data>:
     792:	00 00 00 00 00 01 80 00 00 00 00 00 00 00 00 00     ................
     7a2:	03 80 00 00 00 00 00 00 00 00 00 07 c0 00 00 00     ................
     7b2:	00 00 00 00 00 00 07 c0 00 00 00 00 00 00 00 00     ................
     7c2:	00 0f c0 00 00 00 00 00 00 00 00 00 1f e0 00 00     ................
     7d2:	00 00 00 00 00 00 00 1f e0 00 00 00 00 00 00 00     ................
     7e2:	00 00 3f e0 00 00 00 00 00 00 00 00 00 3f f0 00     ..?..........?..
	...
     7fa:	7f f0 00 00 00 00 00 00 00 1f f8 7f f0 00 00 00     ................
     80a:	00 00 00 00 3f fe 7f f0 00 00 00 00 00 00 00 3f     ....?..........?
     81a:	ff 7f f0 00 00 00 00 00 00 00 1f ff fb e0 00 00     ................
     82a:	00 00 00 00 00 0f ff f9 ff c0 00 00 00 00 00 00     ................
     83a:	0f ff f9 ff f8 00 00 00 00 00 00 07 ff f1 ff ff     ................
     84a:	00 00 00 00 00 00 03 fc 73 ff ff 80 00 00 00 00     ........s.......
     85a:	00 01 fe 3f ff ff 80 00 00 00 00 00 00 ff 1e 0f     ...?............
     86a:	ff 00 00 00 00 00 00 00 7f fe 1f fc 00 00 00 00     ................
     87a:	00 00 00 3f ff ff f8 00 00 00 00 00 00 00 0f df     ...?............
     88a:	ff e0 00 00 00 00 00 00 00 1f 19 ff c0 00 00 00     ................
     89a:	00 00 00 00 3f 3c ff 00 00 00 00 00 00 00 00 7e     ....?<.........~
     8aa:	7c f8 00 00 00 00 00 00 00 00 7f fe 7c 00 00 00     |...........|...
     8ba:	00 00 00 00 00 ff ff fc 00 00 00 00 00 00 00 00     ................
     8ca:	ff ff fe 00 00 00 00 00 00 00 00 ff ff fe 00 00     ................
     8da:	00 00 00 00 00 01 ff ef fe 00 00 00 00 00 00 00     ................
     8ea:	01 ff cf fe 00 00 00 00 00 00 00 03 ff 07 fe 00     ................
     8fa:	00 00 00 00 00 00 03 fc 07 fe 00 00 00 00 00 00     ................
     90a:	00 03 f0 03 fe 00 00 00 00 00 00 00 01 80 00 fe     ................
	...
     922:	00 00 7e 00 00 00 00 00 00 00 00 00 00 3e 00 00     ..~..........>..
	...
     93a:	0c 00 00 00 00 00 00 07 80 00 fc 00 00 03 c0 00     ................
     94a:	00 00 07 80 01 fc 00 00 03 c0 00 00 00 07 80 01     ................
     95a:	fc 00 00 03 c0 00 00 00 07 80 01 e0 00 00 00 1e     ................
     96a:	00 00 00 07 80 01 e0 00 00 00 1e 00 7f e3 f7 9f     ................
     97a:	f9 fd e7 78 7b df c0 ff f7 ff bf fd fd ff 78 7b     ...x{.........x{
     98a:	df c0 ff f7 ff bf fd fd ff 78 7b df c0 f0 f7 87     .........x{.....
     99a:	bc 3d e1 ff 78 7b de 00 f0 f7 87 bc 3d e1 f0 78     .=..x{......=..x
     9aa:	7b de 00 00 f7 87 80 3d e1 e0 78 7b de 00 7f f7     {......=..x{....
     9ba:	87 9f fd e1 e0 78 7b de 00 ff f7 87 bf fd e1 e0     .....x{.........
     9ca:	78 7b de 00 f0 f7 87 bc 3d e1 e0 78 7b de 00 f0     x{......=..x{...
     9da:	f7 87 bc 3d e1 e0 78 7b de 00 f0 f7 87 bc 3d e1     ...=..x{......=.
     9ea:	e0 78 7b de 00 ff f7 ff bf fd e1 e0 7f fb df c0     .x{.............
     9fa:	ff f7 ff bf fd e1 e0 7f fb df c0 7c f3 f3 9f 3d     ...........|...=
     a0a:	e1 e0 3e 7b cf c0 00 00 00 00 00 00 00 00 00 00     ..>{............
     a1a:	00 ff ff ff ff ff ff ff ff ff ff c0 ff ff ff ff     ................
     a2a:	fd 68 db 11 1a 31 c0 ff ff ff ff fd 2b 5a fb 6a     .h...1......+Z.j
     a3a:	ef c0 ff ff ff ff fd 4b 5b 3b 1a 33 c0 ff ff ff     .......K[;.3....
     a4a:	ff fd 6b 5b db 6a fd c0                             ..k[.j..

00000a52 <oled_init()::__c>:
     a52:	53 53 44 31 33 30 36 20 61 6c 6c 6f 63 61 74 69     SSD1306 allocati
     a62:	6f 6e 20 66 61 69 6c 65 64 00                       on failed.

00000a6c <setup::__c>:
     a6c:	0d 0a 20 41 56 52 43 6f 72 65 20 74 65 73 74 20     .. AVRCore test 
     a7c:	76 61 6c 69 64 61 74 69 6f 6e 20 73 75 69 74 65     validation suite
     a8c:	0d 0a 00                                            ...

00000a8f <Adafruit_SSD1306::display()::dlist1>:
     a8f:	22 00 ff 21 00                                      "..!.

00000a94 <meatball>:
     a94:	ff ff ff ff ff ff f0 ff ff ff ff ff ff f0 ff ff     ................
     aa4:	ff ff ff ff f0 ff ff ff ff ff ff f0 ff ff ff ff     ................
     ab4:	ff ff f0 ff ff fe 03 ff ff f0 ff ff f0 00 3f ff     ..............?.
     ac4:	f0 ff ff 80 00 0e 1f f0 ff fe 00 00 06 1f f0 ff     ................
     ad4:	fc 00 00 02 1f f0 ff f0 00 00 02 3f f0 ff e0 00     ...........?....
     ae4:	00 01 ff f0 ff c0 00 00 00 ff f0 ff c0 00 00 00     ................
     af4:	ff f0 ff 80 10 00 20 7f f0 ff 00 3c 00 70 7f f0     ...... ....<.p..
     b04:	ff 00 7c 00 f8 3f f0 fe 00 7e 01 f8 1f f0 fe 00     ..|..?...~......
     b14:	ff 01 fc 1f f0 fc 01 ff 03 fe 0f f0 fc 00 ff 83     ................
     b24:	fe 07 f0 fc 00 ff c1 ff 07 f0 fc 00 7f c1 ff 03     ................
     b34:	f0 f8 00 7f e0 ff 81 f0 f8 08 3f f0 ff c1 f0 f8     ..........?.....
     b44:	1c 1f f0 7f c0 f0 f8 3e 1f f8 3f e0 70 f8 3e 0f     .......>..?.p.>.
     b54:	f8 3f f0 70 f8 7f 07 fc 1f f0 70 fc ff 83 fe 0f     .?.p......p.....
     b64:	f8 70 fd ff 83 fe 0f fc f0 ff ff 01 ff 07 fc f0     .p..............
     b74:	ff ff 01 ff 03 ff f0 ff fe 00 fe 03 ff f0 ff fc     ................
     b84:	00 fc 01 ff f0 ff f8 00 78 00 ff f0 ff f8 00 38     ........x......8
     b94:	00 ff f0 ff f0 00 10 00 7f f0 ff e0 00 00 00 3f     ...............?
     ba4:	f0 ff e0 00 00 00 3f f0 ff f0 00 00 00 3f f0 ff     ......?......?..
     bb4:	f8 00 00 00 7f f0 ff fe 00 00 01 ff f0 ff ff 80     ................
     bc4:	00 07 ff f0 ff ff e0 00 1f ff f0 ff ff fc 00 ff     ................
     bd4:	ff f0 ff ff ff ff ff ff f0 ff ff ff ff ff ff f0     ................
     be4:	ff ff ff ff ff ff f0 ff ff ff ff ff ff f0 ff ff     ................
     bf4:	ff ff ff ff f0                                      .....

00000bf9 <_usart0_pins>:
     bf9:	00 00 02 01 04 06 02 02 ff 03 10 12 04 09 0b 05     ................
     c09:	00 07 00                                            ...

00000c0c <__ctors_start>:
__ctors_start():
     c0c:	85 19       	sub	r24, r5

00000c0e <__ctors_end>:
__dtors_start():
     c0e:	aa 22       	and	r10, r26

00000c10 <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     c10:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     c12:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     c14:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     c16:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     c18:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
     c1a:	de bf       	out	0x3e, r29	; 62

00000c1c <_initThreeStuff()>:
init_reset_flags():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:139

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
     c1c:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:140
    RSTCTRL.RSTFR = flags;
     c20:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:141
    if (flags == 0) {
     c24:	81 11       	cpse	r24, r1
     c26:	05 c0       	rjmp	.+10     	; 0xc32 <_initThreeStuff()+0x16>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:142
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     c28:	98 ed       	ldi	r25, 0xD8	; 216
     c2a:	21 e0       	ldi	r18, 0x01	; 1
     c2c:	94 bf       	out	0x34, r25	; 52
     c2e:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7f0041>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:144
    }
    GPIOR0 = flags;
     c32:	8c bb       	out	0x1c, r24	; 28

00000c34 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     c34:	13 e6       	ldi	r17, 0x63	; 99
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     c36:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     c38:	b0 e6       	ldi	r27, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     c3a:	e0 e0       	ldi	r30, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     c3c:	f0 e5       	ldi	r31, 0x50	; 80
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     c3e:	02 c0       	rjmp	.+4      	; 0xc44 <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     c40:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     c42:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     c44:	aa 30       	cpi	r26, 0x0A	; 10
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     c46:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     c48:	d9 f7       	brne	.-10     	; 0xc40 <__do_copy_data+0xc>

00000c4a <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     c4a:	25 e6       	ldi	r18, 0x65	; 101
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     c4c:	aa e0       	ldi	r26, 0x0A	; 10
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     c4e:	b3 e6       	ldi	r27, 0x63	; 99
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     c50:	01 c0       	rjmp	.+2      	; 0xc54 <.do_clear_bss_start>

00000c52 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     c52:	1d 92       	st	X+, r1

00000c54 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     c54:	ad 3a       	cpi	r26, 0xAD	; 173
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     c56:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     c58:	e1 f7       	brne	.-8      	; 0xc52 <.do_clear_bss_loop>

00000c5a <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     c5a:	16 e0       	ldi	r17, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     c5c:	c7 e0       	ldi	r28, 0x07	; 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     c5e:	d6 e0       	ldi	r29, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     c60:	04 c0       	rjmp	.+8      	; 0xc6a <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     c62:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     c64:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     c66:	0e 94 9e 26 	call	0x4d3c	; 0x4d3c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     c6a:	c6 30       	cpi	r28, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     c6c:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     c6e:	c9 f7       	brne	.-14     	; 0xc62 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     c70:	0e 94 a6 1a 	call	0x354c	; 0x354c <main>
../../../../crt1/gcrt1.S:315
     c74:	0c 94 f4 27 	jmp	0x4fe8	; 0x4fe8 <__do_global_dtors>

00000c78 <__bad_interrupt>:
__vector_28():
../../../../crt1/gcrt1.S:209
     c78:	c3 c9       	rjmp	.-3194   	; 0x0 <__vectors>

00000c7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>:
transfer():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:600
  * The following NOP introduces a small delay that can prevent the wait
  * loop from iterating when running at the maximum speed. This gives
  * about 10% more speed, even if it seems counter-intuitive. At lower
  * speeds it is unnoticed.
  */
  asm volatile("nop");
     c7a:	00 00       	nop
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:602

  SPI_MODULE.DATA = data;
     c7c:	80 93 44 09 	sts	0x0944, r24	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:603
  while ((SPI_MODULE.INTFLAGS & SPI_RXCIF_bm) == 0);  // wait for complete send
     c80:	80 91 43 09 	lds	r24, 0x0943	; 0x800943 <__TEXT_REGION_LENGTH__+0x7f0943>
     c84:	87 ff       	sbrs	r24, 7
     c86:	fc cf       	rjmp	.-8      	; 0xc80 <SPIClass::transfer(unsigned char) [clone .constprop.53]+0x6>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:604
  return SPI_MODULE.DATA;                             // read data back
     c88:	80 91 44 09 	lds	r24, 0x0944	; 0x800944 <__TEXT_REGION_LENGTH__+0x7f0944>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:605
}
     c8c:	08 95       	ret

00000c8e <Adafruit_GFX::startWrite()>:
startWrite():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:180
/**************************************************************************/
/*!
   @brief    Start a display-writing routine, overwrite in subclasses.
*/
/**************************************************************************/
void Adafruit_GFX::startWrite() {}
     c8e:	08 95       	ret

00000c90 <_delayMicroseconds>:
_delayMicroseconds():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1341
  // we just burned 24 (22) cycles above, remove 3
  us -= 3; // 2 cycles

#elif F_CPU >= 24000000L
  // for a one-microsecond delay, burn 8 cycles and return
  __asm__ __volatile__ (
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <_delayMicroseconds+0x4>
     c92:	08 95       	ret
     c94:	fe df       	rcall	.-4      	; 0xc92 <_delayMicroseconds+0x2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1346
    "rjmp .+2" "\n\t"     // 2 cycles - jump over next instruction.
    "ret" "\n\t"          // 4 cycles - rjmped over initially....
    "rcall .-4");         // 2 cycles - ... but then called here);
                          // wait 8 cycles with 3 words
  if (us <= 1) return; //  = 3 cycles, (4 when true)
     c96:	82 30       	cpi	r24, 0x02	; 2
     c98:	91 05       	cpc	r25, r1
     c9a:	50 f0       	brcs	.+20     	; 0xcb0 <_delayMicroseconds+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1350

  // the loop takes 1/3 of a microsecond (8 cycles) per iteration
  // so execute it three times for each microsecond of delay requested.
  us = (us << 1) + us; // x3 us, = 5 cycles
     c9c:	9c 01       	movw	r18, r24
     c9e:	22 0f       	add	r18, r18
     ca0:	33 1f       	adc	r19, r19
     ca2:	03 97       	sbiw	r24, 0x03	; 3
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1352
  // we just burned 24 (22) cycles above, remove 3
  us -= 3; // 2 cycles
     ca4:	82 0f       	add	r24, r18
     ca6:	93 1f       	adc	r25, r19
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1484
    "rjmp .+0"      "\n\t"            // 2 cycles
    "nop"           "\n\t"
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#elif defined(DELAYMICROS_EIGHT)
  __asm__ __volatile__ (
     ca8:	01 97       	sbiw	r24, 0x01	; 1
     caa:	00 c0       	rjmp	.+0      	; 0xcac <_delayMicroseconds+0x1c>
     cac:	00 c0       	rjmp	.+0      	; 0xcae <_delayMicroseconds+0x1e>
     cae:	e1 f7       	brne	.-8      	; 0xca8 <_delayMicroseconds+0x18>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1510
    "1: sbiw %0, 1" "\n\t"            // 2 cycles
    "brne 1b" : "=w" (us) : "0" (us)  // 2 cycles
  );
#endif
  // return = 4 cycles
}
     cb0:	08 95       	ret

00000cb2 <micros>:
micros():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:449
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     cb2:	9f b7       	in	r25, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:450
      cli(); /* INTERRUPTS OFF */
     cb4:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:466
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     cb6:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7f0b2a>
     cba:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7f0b2b>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:467
        flags = _timer->INTFLAGS;
     cbe:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:475
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     cc2:	20 91 93 63 	lds	r18, 0x6393	; 0x806393 <timingStruct>
     cc6:	30 91 94 63 	lds	r19, 0x6394	; 0x806394 <timingStruct+0x1>
     cca:	40 91 95 63 	lds	r20, 0x6395	; 0x806395 <timingStruct+0x2>
     cce:	50 91 96 63 	lds	r21, 0x6396	; 0x806396 <timingStruct+0x3>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:480
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     cd2:	9f bf       	out	0x3f, r25	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:490
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     cd4:	80 ff       	sbrs	r24, 0
     cd6:	08 c0       	rjmp	.+16     	; 0xce8 <micros+0x36>
     cd8:	cf 01       	movw	r24, r30
     cda:	88 27       	eor	r24, r24
     cdc:	89 2b       	or	r24, r25
     cde:	21 f4       	brne	.+8      	; 0xce8 <micros+0x36>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:495
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     ce0:	2f 5f       	subi	r18, 0xFF	; 255
     ce2:	3f 4f       	sbci	r19, 0xFF	; 255
     ce4:	4f 4f       	sbci	r20, 0xFF	; 255
     ce6:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:785
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.

        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          // The terrible twelves!
            __asm__ __volatile__(
     ce8:	0f 01       	movw	r0, r30
     cea:	16 94       	lsr	r1
     cec:	07 94       	ror	r0
     cee:	16 94       	lsr	r1
     cf0:	07 94       	ror	r0
     cf2:	16 94       	lsr	r1
     cf4:	07 94       	ror	r0
     cf6:	16 94       	lsr	r1
     cf8:	07 94       	ror	r0
     cfa:	f0 01       	movw	r30, r0
     cfc:	16 94       	lsr	r1
     cfe:	07 94       	ror	r0
     d00:	e0 0d       	add	r30, r0
     d02:	f1 1d       	adc	r31, r1
     d04:	16 94       	lsr	r1
     d06:	07 94       	ror	r0
     d08:	10 2c       	mov	r1, r0
     d0a:	16 94       	lsr	r1
     d0c:	01 18       	sub	r0, r1
     d0e:	16 94       	lsr	r1
     d10:	01 0c       	add	r0, r1
     d12:	16 94       	lsr	r1
     d14:	01 18       	sub	r0, r1
     d16:	16 94       	lsr	r1
     d18:	01 0c       	add	r0, r1
     d1a:	16 94       	lsr	r1
     d1c:	01 18       	sub	r0, r1
     d1e:	16 94       	lsr	r1
     d20:	16 94       	lsr	r1
     d22:	01 0c       	add	r0, r1
     d24:	11 24       	eor	r1, r1
     d26:	e0 19       	sub	r30, r0
     d28:	f1 09       	sbc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:830
          "add r0,r1"     "\n\t"  // + ticks >> 9
          "eor r1,r1"     "\n\t"  // clear out r1
          "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
          "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
          : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
        microseconds = overflows * 1000 + ticks;
     d2a:	a8 ee       	ldi	r26, 0xE8	; 232
     d2c:	b3 e0       	ldi	r27, 0x03	; 3
     d2e:	0e 94 18 26 	call	0x4c30	; 0x4c30 <__muluhisi3>
     d32:	6e 0f       	add	r22, r30
     d34:	7f 1f       	adc	r23, r31
     d36:	81 1d       	adc	r24, r1
     d38:	91 1d       	adc	r25, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1039
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     d3a:	08 95       	ret

00000d3c <tinyNeoPixel::show(unsigned int) [clone .constprop.13]>:
show():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:126
#if (PROGMEM_SIZE > 4096UL)

void tinyNeoPixel::show(void) {
  show(0);
}
void tinyNeoPixel::show(uint16_t leds) {
     d3c:	0f 93       	push	r16
     d3e:	1f 93       	push	r17
     d40:	cf 93       	push	r28
     d42:	df 93       	push	r29
     d44:	cd b7       	in	r28, 0x3d	; 61
     d46:	de b7       	in	r29, 0x3e	; 62
     d48:	27 97       	sbiw	r28, 0x07	; 7
     d4a:	cd bf       	out	0x3d, r28	; 61
     d4c:	de bf       	out	0x3e, r29	; 62
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:127
  volatile uint16_t i = numBytes;;
     d4e:	80 91 3d 64 	lds	r24, 0x643D	; 0x80643d <pixel_ring+0x3>
     d52:	90 91 3e 64 	lds	r25, 0x643E	; 0x80643e <pixel_ring+0x4>
     d56:	89 83       	std	Y+1, r24	; 0x01
     d58:	9a 83       	std	Y+2, r25	; 0x02
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:135
      i = leds + leds + leds;
    } else {
      i = leds << 2;
    }
  }
  if ((!pixels) || pin >= NUM_DIGITAL_PINS)  {
     d5a:	80 91 43 64 	lds	r24, 0x6443	; 0x806443 <pixel_ring+0x9>
     d5e:	90 91 44 64 	lds	r25, 0x6444	; 0x806444 <pixel_ring+0xa>
     d62:	89 2b       	or	r24, r25
     d64:	09 f4       	brne	.+2      	; 0xd68 <tinyNeoPixel::show(unsigned int) [clone .constprop.13]+0x2c>
     d66:	67 c0       	rjmp	.+206    	; 0xe36 <_nextbyte24+0x2a>
     d68:	80 91 41 64 	lds	r24, 0x6441	; 0x806441 <pixel_ring+0x7>
     d6c:	8c 31       	cpi	r24, 0x1C	; 28
     d6e:	08 f0       	brcs	.+2      	; 0xd72 <tinyNeoPixel::show(unsigned int) [clone .constprop.13]+0x36>
     d70:	62 c0       	rjmp	.+196    	; 0xe36 <_nextbyte24+0x2a>
canShow():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.h:317
             function instead.
  */
  static uint32_t gamma32(uint32_t x);

  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    inline bool canShow(void) { return (micros() - endTime) >= (uint32_t) latchTime; }
     d72:	9f df       	rcall	.-194    	; 0xcb2 <micros>
     d74:	00 91 49 64 	lds	r16, 0x6449	; 0x806449 <pixel_ring+0xf>
     d78:	10 91 4a 64 	lds	r17, 0x644A	; 0x80644a <pixel_ring+0x10>
     d7c:	20 91 4b 64 	lds	r18, 0x644B	; 0x80644b <pixel_ring+0x11>
     d80:	30 91 4c 64 	lds	r19, 0x644C	; 0x80644c <pixel_ring+0x12>
     d84:	ab 01       	movw	r20, r22
     d86:	bc 01       	movw	r22, r24
     d88:	40 1b       	sub	r20, r16
     d8a:	51 0b       	sbc	r21, r17
     d8c:	62 0b       	sbc	r22, r18
     d8e:	73 0b       	sbc	r23, r19
     d90:	80 91 3f 64 	lds	r24, 0x643F	; 0x80643f <pixel_ring+0x5>
     d94:	90 91 40 64 	lds	r25, 0x6440	; 0x806440 <pixel_ring+0x6>
     d98:	b0 e0       	ldi	r27, 0x00	; 0
     d9a:	a0 e0       	ldi	r26, 0x00	; 0
show():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:148
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while (!canShow());
     d9c:	48 17       	cp	r20, r24
     d9e:	59 07       	cpc	r21, r25
     da0:	6a 07       	cpc	r22, r26
     da2:	7b 07       	cpc	r23, r27
     da4:	30 f3       	brcs	.-52     	; 0xd72 <tinyNeoPixel::show(unsigned int) [clone .constprop.13]+0x36>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:200
  //     is given constraint "+r", which can assign it to any register.
  //     But the code uses LDI on it. LDI doesn't work on every register,
  //     it must have the "+d" constraint to guarantee an upper register.


  noInterrupts(); // Need 100% focus on instruction timing
     da6:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:211
  // run at those speeds, only that - if they do - you can control WS2812s
  // with them.


  volatile uint8_t
   *ptr = pixels,   // Pointer to next byte
     da8:	a0 91 43 64 	lds	r26, 0x6443	; 0x806443 <pixel_ring+0x9>
     dac:	b0 91 44 64 	lds	r27, 0x6444	; 0x806444 <pixel_ring+0xa>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:212
    b   = *ptr++,   // Current byte value
     db0:	fd 01       	movw	r30, r26
     db2:	31 96       	adiw	r30, 0x01	; 1
     db4:	8c 91       	ld	r24, X
     db6:	8f 83       	std	Y+7, r24	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:788
    // 30 inst. clocks per bit: HHHHHHHHxxxxxxxxLLLLLLLLLLLLLL H:8 x:8 L14
    // ST instructions:         ^       ^       ^  (T=0,8,16)

    volatile uint8_t next, bit;

    hi   = *port |  pinMask;
     db8:	a0 91 4d 64 	lds	r26, 0x644D	; 0x80644d <pixel_ring+0x13>
     dbc:	b0 91 4e 64 	lds	r27, 0x644E	; 0x80644e <pixel_ring+0x14>
     dc0:	9c 91       	ld	r25, X
     dc2:	80 91 4f 64 	lds	r24, 0x644F	; 0x80644f <pixel_ring+0x15>
     dc6:	98 2b       	or	r25, r24
     dc8:	9e 83       	std	Y+6, r25	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:789
    lo   = *port & ~pinMask;
     dca:	9c 91       	ld	r25, X
     dcc:	80 95       	com	r24
     dce:	89 23       	and	r24, r25
     dd0:	8d 83       	std	Y+5, r24	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:790
    next = lo;
     dd2:	8d 81       	ldd	r24, Y+5	; 0x05
     dd4:	8c 83       	std	Y+4, r24	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:791
    bit  = 8;
     dd6:	88 e0       	ldi	r24, 0x08	; 8
     dd8:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:831
      [bit]   "+d" (bit),
      [next]  "+r" (next),
      [count] "+w" (i)
    : [port]   "e" (port),
      [hi]     "r" (hi),
      [lo]     "r" (lo));
     dda:	5e 81       	ldd	r21, Y+6	; 0x06
     ddc:	6d 81       	ldd	r22, Y+5	; 0x05
     dde:	4f 81       	ldd	r20, Y+7	; 0x07
     de0:	3b 81       	ldd	r19, Y+3	; 0x03
     de2:	2c 81       	ldd	r18, Y+4	; 0x04
     de4:	89 81       	ldd	r24, Y+1	; 0x01
     de6:	9a 81       	ldd	r25, Y+2	; 0x02

00000de8 <_head24>:
     de8:	5c 93       	st	X, r21
     dea:	47 fd       	sbrc	r20, 7
     dec:	25 2f       	mov	r18, r21
     dee:	3a 95       	dec	r19
     df0:	00 c0       	rjmp	.+0      	; 0xdf2 <_head24+0xa>
     df2:	00 c0       	rjmp	.+0      	; 0xdf4 <_head24+0xc>
     df4:	2c 93       	st	X, r18
     df6:	26 2f       	mov	r18, r22
     df8:	00 c0       	rjmp	.+0      	; 0xdfa <_head24+0x12>
     dfa:	41 f0       	breq	.+16     	; 0xe0c <_nextbyte24>
     dfc:	44 1f       	adc	r20, r20
     dfe:	6c 93       	st	X, r22
     e00:	01 d0       	rcall	.+2      	; 0xe04 <_seconddelay24>
     e02:	f2 cf       	rjmp	.-28     	; 0xde8 <_head24>

00000e04 <_seconddelay24>:
     e04:	00 c0       	rjmp	.+0      	; 0xe06 <_seconddelay24+0x2>
     e06:	00 c0       	rjmp	.+0      	; 0xe08 <_thirddelay24>

00000e08 <_thirddelay24>:
     e08:	00 00       	nop
     e0a:	08 95       	ret

00000e0c <_nextbyte24>:
     e0c:	6c 93       	st	X, r22
     e0e:	38 e0       	ldi	r19, 0x08	; 8
     e10:	41 91       	ld	r20, Z+
     e12:	fa df       	rcall	.-12     	; 0xe08 <_thirddelay24>
     e14:	01 97       	sbiw	r24, 0x01	; 1
     e16:	41 f7       	brne	.-48     	; 0xde8 <_head24>
     e18:	4f 83       	std	Y+7, r20	; 0x07
     e1a:	3b 83       	std	Y+3, r19	; 0x03
     e1c:	2c 83       	std	Y+4, r18	; 0x04
     e1e:	89 83       	std	Y+1, r24	; 0x01
     e20:	9a 83       	std	Y+2, r25	; 0x02
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1119



  interrupts();
  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    endTime = micros();
     e22:	78 94       	sei
     e24:	46 df       	rcall	.-372    	; 0xcb2 <micros>
     e26:	60 93 49 64 	sts	0x6449, r22	; 0x806449 <pixel_ring+0xf>
     e2a:	70 93 4a 64 	sts	0x644A, r23	; 0x80644a <pixel_ring+0x10>
     e2e:	80 93 4b 64 	sts	0x644B, r24	; 0x80644b <pixel_ring+0x11>
     e32:	90 93 4c 64 	sts	0x644C, r25	; 0x80644c <pixel_ring+0x12>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1125
    // Save EOD time for latch on next call
    #pragma message("micros() present. This library assumes the canonical 50 us latch delay; some pixels will wait as long as 250us. In these cases, you must be sure to not call show more often. See documentation.")
  #else
    #pragma message("micros() is not available because millis is disabled from the tools subemnu. It is your responsibility to ensure a sufficient time has passed between calls to show(). See documentation.")
  #endif
}
     e36:	27 96       	adiw	r28, 0x07	; 7
     e38:	cd bf       	out	0x3d, r28	; 61
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	df 91       	pop	r29
     e3e:	cf 91       	pop	r28
     e40:	1f 91       	pop	r17
     e42:	0f 91       	pop	r16
     e44:	08 95       	ret

00000e46 <delay>:
delay():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1101

#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
     e46:	cf 92       	push	r12
     e48:	df 92       	push	r13
     e4a:	ef 92       	push	r14
     e4c:	ff 92       	push	r15
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
     e52:	6b 01       	movw	r12, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1102
    uint16_t start = (uint16_t)micros();
     e54:	7c 01       	movw	r14, r24
     e56:	2d df       	rcall	.-422    	; 0xcb2 <micros>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1106
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     e58:	eb 01       	movw	r28, r22
     e5a:	2b df       	rcall	.-426    	; 0xcb2 <micros>
     e5c:	6c 1b       	sub	r22, r28
     e5e:	7d 0b       	sbc	r23, r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1107
      if (us_passed >= 1000) {
     e60:	68 3e       	cpi	r22, 0xE8	; 232
     e62:	73 40       	sbci	r23, 0x03	; 3
     e64:	d0 f3       	brcs	.-12     	; 0xe5a <delay+0x14>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1108
        ms--;
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	c8 1a       	sub	r12, r24
     e6a:	d1 08       	sbc	r13, r1
     e6c:	e1 08       	sbc	r14, r1
     e6e:	f1 08       	sbc	r15, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1109
        start += 1000;
     e70:	c8 51       	subi	r28, 0x18	; 24
     e72:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1104
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     e74:	c1 14       	cp	r12, r1
     e76:	d1 04       	cpc	r13, r1
     e78:	e1 04       	cpc	r14, r1
     e7a:	f1 04       	cpc	r15, r1
     e7c:	71 f7       	brne	.-36     	; 0xe5a <delay+0x14>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1112
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
     e7e:	df 91       	pop	r29
     e80:	cf 91       	pop	r28
     e82:	ff 90       	pop	r15
     e84:	ef 90       	pop	r14
     e86:	df 90       	pop	r13
     e88:	cf 90       	pop	r12
     e8a:	08 95       	ret

00000e8c <millis>:
millis():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:381
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     e8c:	2f b7       	in	r18, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:382
    cli();
     e8e:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:433
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
     e90:	60 91 93 63 	lds	r22, 0x6393	; 0x806393 <timingStruct>
     e94:	70 91 94 63 	lds	r23, 0x6394	; 0x806394 <timingStruct+0x1>
     e98:	80 91 95 63 	lds	r24, 0x6395	; 0x806395 <timingStruct+0x2>
     e9c:	90 91 96 63 	lds	r25, 0x6396	; 0x806396 <timingStruct+0x3>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:434
      SREG = oldSREG;
     ea0:	2f bf       	out	0x3f, r18	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:437
    #endif
    return m;
  }
     ea2:	08 95       	ret

00000ea4 <analogRead_type1>:
analogRead_type1():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:245

#ifdef ADC_TYPE1
int16_t analogRead_type1(uint8_t pin)
 {
  
   if (pin < 0x80)
     ea4:	87 fd       	sbrc	r24, 7
     ea6:	05 c0       	rjmp	.+10     	; 0xeb2 <analogRead_type1+0xe>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:246
    pin = digitalPinToAnalogInput(pin);
     ea8:	8c 30       	cpi	r24, 0x0C	; 12
     eaa:	e8 f0       	brcs	.+58     	; 0xee6 <analogRead_type1+0x42>
     eac:	84 31       	cpi	r24, 0x14	; 20
     eae:	b8 f4       	brcc	.+46     	; 0xede <analogRead_type1+0x3a>
     eb0:	8c 50       	subi	r24, 0x0C	; 12
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:248
  
  ADC0.CTRLA &= ~(ADC_CONVMODE_DIFF_gc);  // set single ended mode
     eb2:	90 91 00 06 	lds	r25, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
     eb6:	9f 7d       	andi	r25, 0xDF	; 223
     eb8:	90 93 00 06 	sts	0x0600, r25	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:251

  // set negative input to GND
  ADC0.MUXNEG = 0x40;
     ebc:	90 e4       	ldi	r25, 0x40	; 64
     ebe:	90 93 09 06 	sts	0x0609, r25	; 0x800609 <__TEXT_REGION_LENGTH__+0x7f0609>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:257

  // fill entries in adc_status
  adc_status.mux_plus = pin;

  /* Select channel */
  ADC0.MUXPOS = pin;
     ec2:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <__TEXT_REGION_LENGTH__+0x7f0608>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:260

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	80 93 0a 06 	sts	0x060A, r24	; 0x80060a <__TEXT_REGION_LENGTH__+0x7f060a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:263

  /* Wait for result ready */
  while(!(ADC0.INTFLAGS & ADC_RESRDY_bm));
     ecc:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <__TEXT_REGION_LENGTH__+0x7f060d>
     ed0:	80 ff       	sbrs	r24, 0
     ed2:	fc cf       	rjmp	.-8      	; 0xecc <analogRead_type1+0x28>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:265

  return ADC0.RES;
     ed4:	80 91 10 06 	lds	r24, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7f0610>
     ed8:	90 91 11 06 	lds	r25, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7f0611>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:267

}
     edc:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:246
#ifdef ADC_TYPE1
int16_t analogRead_type1(uint8_t pin)
 {
  
   if (pin < 0x80)
    pin = digitalPinToAnalogInput(pin);
     ede:	8a 31       	cpi	r24, 0x1A	; 26
     ee0:	30 f4       	brcc	.+12     	; 0xeee <analogRead_type1+0x4a>
     ee2:	84 50       	subi	r24, 0x04	; 4
     ee4:	e6 cf       	rjmp	.-52     	; 0xeb2 <analogRead_type1+0xe>
     ee6:	82 30       	cpi	r24, 0x02	; 2
     ee8:	10 f0       	brcs	.+4      	; 0xeee <analogRead_type1+0x4a>
     eea:	8c 5e       	subi	r24, 0xEC	; 236
     eec:	e2 cf       	rjmp	.-60     	; 0xeb2 <analogRead_type1+0xe>
     eee:	8f ef       	ldi	r24, 0xFF	; 255
     ef0:	e0 cf       	rjmp	.-64     	; 0xeb2 <analogRead_type1+0xe>

00000ef2 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     ef2:	af 92       	push	r10
     ef4:	bf 92       	push	r11
     ef6:	cf 92       	push	r12
     ef8:	df 92       	push	r13
     efa:	ef 92       	push	r14
     efc:	ff 92       	push	r15
     efe:	0f 93       	push	r16
     f00:	1f 93       	push	r17
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	6c 01       	movw	r12, r24
     f08:	7b 01       	movw	r14, r22
     f0a:	8b 01       	movw	r16, r22
     f0c:	04 0f       	add	r16, r20
     f0e:	15 1f       	adc	r17, r21
     f10:	eb 01       	movw	r28, r22
     f12:	5e 01       	movw	r10, r28
     f14:	ae 18       	sub	r10, r14
     f16:	bf 08       	sbc	r11, r15
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     f18:	c0 17       	cp	r28, r16
     f1a:	d1 07       	cpc	r29, r17
     f1c:	59 f0       	breq	.+22     	; 0xf34 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:32
    if (write(*buffer++)) {
     f1e:	69 91       	ld	r22, Y+
     f20:	d6 01       	movw	r26, r12
     f22:	ed 91       	ld	r30, X+
     f24:	fc 91       	ld	r31, X
     f26:	01 90       	ld	r0, Z+
     f28:	f0 81       	ld	r31, Z
     f2a:	e0 2d       	mov	r30, r0
     f2c:	c6 01       	movw	r24, r12
     f2e:	09 95       	icall
     f30:	89 2b       	or	r24, r25
     f32:	79 f7       	brne	.-34     	; 0xf12 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     f34:	c5 01       	movw	r24, r10
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	df 90       	pop	r13
     f44:	cf 90       	pop	r12
     f46:	bf 90       	pop	r11
     f48:	af 90       	pop	r10
     f4a:	08 95       	ret

00000f4c <analogReadResolution1>:
analogReadResolution1():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:227

void analogReadResolution1(uint8_t resolution)
{

  // default to 12 bits unless 10bit requested
  if(resolution == 10)       
     f4c:	8a 30       	cpi	r24, 0x0A	; 10
     f4e:	59 f4       	brne	.+22     	; 0xf66 <analogReadResolution1+0x1a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:229
      {
        ADC0.CTRLA &= 0xF3;
     f50:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
     f54:	83 7f       	andi	r24, 0xF3	; 243
     f56:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:230
        ADC0.CTRLA |= 0x04;
     f5a:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
     f5e:	84 60       	ori	r24, 0x04	; 4
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:234
      }
     
  else 
      ADC0.CTRLA &= 0xF3;
     f60:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:236
   
}
     f64:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:234
        ADC0.CTRLA &= 0xF3;
        ADC0.CTRLA |= 0x04;
      }
     
  else 
      ADC0.CTRLA &= 0xF3;
     f66:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
     f6a:	83 7f       	andi	r24, 0xF3	; 243
     f6c:	f9 cf       	rjmp	.-14     	; 0xf60 <analogReadResolution1+0x14>

00000f6e <analogRead>:
analogRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:141
  int16_t analogRead(uint8_t pin)
  {
  
    uint16_t adc_val;
  
    adc_val = adc_read(pin);
     f6e:	e0 91 0b 63 	lds	r30, 0x630B	; 0x80630b <adc_read>
     f72:	f0 91 0c 63 	lds	r31, 0x630C	; 0x80630c <adc_read+0x1>
     f76:	09 95       	icall
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:142
    if(adc_config.sample_number > 1)
     f78:	20 91 16 63 	lds	r18, 0x6316	; 0x806316 <adc_config+0x2>
     f7c:	22 30       	cpi	r18, 0x02	; 2
     f7e:	94 f0       	brlt	.+36     	; 0xfa4 <analogRead+0x36>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:143
      adc_val /= (uint16_t)adc_config.sample_number;
     f80:	62 2f       	mov	r22, r18
     f82:	02 2e       	mov	r0, r18
     f84:	00 0c       	add	r0, r0
     f86:	77 0b       	sbc	r23, r23
     f88:	0e 94 8a 26 	call	0x4d14	; 0x4d14 <__udivmodhi4>
     f8c:	cb 01       	movw	r24, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:147

    // correct for truncation at higher sample numbers

    if(adc_config.sample_number == 32)
     f8e:	20 32       	cpi	r18, 0x20	; 32
     f90:	19 f4       	brne	.+6      	; 0xf98 <analogRead+0x2a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:148
      adc_val *= 2;
     f92:	88 0f       	add	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:150

    if(adc_config.sample_number == 64)
     f98:	20 34       	cpi	r18, 0x40	; 64
     f9a:	21 f4       	brne	.+8      	; 0xfa4 <analogRead+0x36>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:151
      adc_val *= 4;
     f9c:	88 0f       	add	r24, r24
     f9e:	99 1f       	adc	r25, r25
     fa0:	88 0f       	add	r24, r24
     fa2:	99 1f       	adc	r25, r25
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:158
    if(adc_config.sample_number == 128)
      adc_val *= 8;  
  
    return(adc_val);
  
  }
     fa4:	08 95       	ret

00000fa6 <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:728
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     fa6:	fc 01       	movw	r30, r24
     fa8:	51 89       	ldd	r21, Z+17	; 0x11
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:729
          tail = _tx_buffer_tail;
     faa:	42 89       	ldd	r20, Z+18	; 0x12
     fac:	25 2f       	mov	r18, r21
     fae:	30 e0       	ldi	r19, 0x00	; 0
     fb0:	84 2f       	mov	r24, r20
     fb2:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:732
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     fb4:	82 1b       	sub	r24, r18
     fb6:	93 0b       	sbc	r25, r19
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:731

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     fb8:	54 17       	cp	r21, r20
     fba:	10 f0       	brcs	.+4      	; 0xfc0 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:732
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     fbc:	cf 96       	adiw	r24, 0x3f	; 63
     fbe:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:734
        }
        return tail - head - 1;
     fc0:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:735
      }
     fc2:	08 95       	ret

00000fc4 <HardwareSerial::read()>:
read():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:712
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     fc4:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:714
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     fc6:	97 85       	ldd	r25, Z+15	; 0x0f
     fc8:	80 89       	ldd	r24, Z+16	; 0x10
     fca:	98 17       	cp	r25, r24
     fcc:	61 f0       	breq	.+24     	; 0xfe6 <HardwareSerial::read()+0x22>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:717
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     fce:	a0 89       	ldd	r26, Z+16	; 0x10
     fd0:	ae 0f       	add	r26, r30
     fd2:	bf 2f       	mov	r27, r31
     fd4:	b1 1d       	adc	r27, r1
     fd6:	53 96       	adiw	r26, 0x13	; 19
     fd8:	8c 91       	ld	r24, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:718
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     fda:	90 89       	ldd	r25, Z+16	; 0x10
     fdc:	9f 5f       	subi	r25, 0xFF	; 255
     fde:	9f 73       	andi	r25, 0x3F	; 63
     fe0:	90 8b       	std	Z+16, r25	; 0x10
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:719
        return c;
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:715
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     fe6:	8f ef       	ldi	r24, 0xFF	; 255
     fe8:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:721
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     fea:	08 95       	ret

00000fec <HardwareSerial::peek()>:
peek():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:704

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     fec:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:705
      if (_rx_buffer_head == _rx_buffer_tail) {
     fee:	97 85       	ldd	r25, Z+15	; 0x0f
     ff0:	80 89       	ldd	r24, Z+16	; 0x10
     ff2:	98 17       	cp	r25, r24
     ff4:	31 f0       	breq	.+12     	; 0x1002 <HardwareSerial::peek()+0x16>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:708
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     ff6:	80 89       	ldd	r24, Z+16	; 0x10
     ff8:	e8 0f       	add	r30, r24
     ffa:	f1 1d       	adc	r31, r1
     ffc:	83 89       	ldd	r24, Z+19	; 0x13
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:706
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
    1002:	8f ef       	ldi	r24, 0xFF	; 255
    1004:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:710
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
    1006:	08 95       	ret

00001008 <HardwareSerial::available()>:
available():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:700
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
    1008:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:701
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    100a:	97 85       	ldd	r25, Z+15	; 0x0f
    100c:	20 89       	ldd	r18, Z+16	; 0x10
    100e:	89 2f       	mov	r24, r25
    1010:	90 e0       	ldi	r25, 0x00	; 0
    1012:	80 5c       	subi	r24, 0xC0	; 192
    1014:	9f 4f       	sbci	r25, 0xFF	; 255
    1016:	82 1b       	sub	r24, r18
    1018:	91 09       	sbc	r25, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:702
    }
    101a:	8f 73       	andi	r24, 0x3F	; 63
    101c:	99 27       	eor	r25, r25
    101e:	08 95       	ret

00001020 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:427
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
    1020:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:428
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	07 fe       	sbrs	r0, 7
    1026:	04 c0       	rjmp	.+8      	; 0x1030 <HardwareSerial::_poll_tx_data_empty()+0x10>
    1028:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7f0111>
    102c:	88 23       	and	r24, r24
    102e:	a9 f0       	breq	.+42     	; 0x105a <_poll_dre_done>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:445
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
    1030:	a0 85       	ldd	r26, Z+8	; 0x08
    1032:	b1 85       	ldd	r27, Z+9	; 0x09
    1034:	14 96       	adiw	r26, 0x04	; 4
    1036:	8c 91       	ld	r24, X
    1038:	14 97       	sbiw	r26, 0x04	; 4
    103a:	85 ff       	sbrs	r24, 5
    103c:	0e c0       	rjmp	.+28     	; 0x105a <_poll_dre_done>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:446
          if (_tx_buffer_head == _tx_buffer_tail) {
    103e:	91 89       	ldd	r25, Z+17	; 0x11
    1040:	82 89       	ldd	r24, Z+18	; 0x12
    1042:	98 13       	cpse	r25, r24
    1044:	07 c0       	rjmp	.+14     	; 0x1054 <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:448
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
    1046:	15 96       	adiw	r26, 0x05	; 5
    1048:	8c 91       	ld	r24, X
    104a:	15 97       	sbiw	r26, 0x05	; 5
    104c:	8f 7d       	andi	r24, 0xDF	; 223
    104e:	15 96       	adiw	r26, 0x05	; 5
    1050:	8c 93       	st	X, r24
    1052:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:466
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
    1054:	e8 94       	clt
    1056:	0c 94 4b 18 	jmp	0x3096	; 0x3096 <_poll_dre>

0000105a <_poll_dre_done>:
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:475
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
    105a:	08 95       	ret

0000105c <HardwareSerial::write(unsigned char)>:
write():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:768
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
    105c:	0f 93       	push	r16
    105e:	1f 93       	push	r17
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	ec 01       	movw	r28, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:769
        _state |= 1; // Record that we have written to serial since it was begun.
    1066:	8e 85       	ldd	r24, Y+14	; 0x0e
    1068:	81 60       	ori	r24, 0x01	; 1
    106a:	8e 87       	std	Y+14, r24	; 0x0e
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:774
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
    106c:	99 89       	ldd	r25, Y+17	; 0x11
    106e:	8a 89       	ldd	r24, Y+18	; 0x12
    1070:	98 13       	cpse	r25, r24
    1072:	0b c0       	rjmp	.+22     	; 0x108a <HardwareSerial::write(unsigned char)+0x2e>
    1074:	e8 85       	ldd	r30, Y+8	; 0x08
    1076:	f9 85       	ldd	r31, Y+9	; 0x09
    1078:	84 81       	ldd	r24, Z+4	; 0x04
    107a:	85 ff       	sbrs	r24, 5
    107c:	06 c0       	rjmp	.+12     	; 0x108a <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:775
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
    107e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1080:	81 fd       	sbrc	r24, 1
    1082:	0d c0       	rjmp	.+26     	; 0x109e <HardwareSerial::write(unsigned char)+0x42>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:782
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
    1084:	80 e4       	ldi	r24, 0x40	; 64
    1086:	84 83       	std	Z+4, r24	; 0x04
    1088:	12 c0       	rjmp	.+36     	; 0x10ae <HardwareSerial::write(unsigned char)+0x52>
    108a:	06 2f       	mov	r16, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:803
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
    108c:	19 89       	ldd	r17, Y+17	; 0x11
    108e:	1f 5f       	subi	r17, 0xFF	; 255
    1090:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:807

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
    1092:	8a 89       	ldd	r24, Y+18	; 0x12
    1094:	81 13       	cpse	r24, r17
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:808
          _poll_tx_data_empty();
    1096:	15 c0       	rjmp	.+42     	; 0x10c2 <HardwareSerial::write(unsigned char)+0x66>
    1098:	ce 01       	movw	r24, r28
    109a:	c2 df       	rcall	.-124    	; 0x1020 <HardwareSerial::_poll_tx_data_empty()>
    109c:	fa cf       	rjmp	.-12     	; 0x1092 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:776
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
    109e:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:777
            ctrla &= ~USART_RXCIE_bm;
    10a0:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:778
            ctrla |=  USART_TXCIE_bm;
    10a2:	80 64       	ori	r24, 0x40	; 64
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:779
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
    10a4:	90 e4       	ldi	r25, 0x40	; 64
    10a6:	94 83       	std	Z+4, r25	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:780
            (*_hwserial_module).CTRLA = ctrla;
    10a8:	e8 85       	ldd	r30, Y+8	; 0x08
    10aa:	f9 85       	ldd	r31, Y+9	; 0x09
    10ac:	85 83       	std	Z+5, r24	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:785
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
    10ae:	e8 85       	ldd	r30, Y+8	; 0x08
    10b0:	f9 85       	ldd	r31, Y+9	; 0x09
    10b2:	62 83       	std	Z+2, r22	; 0x02
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:823
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
    10b4:	81 e0       	ldi	r24, 0x01	; 1
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:810
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
    10c2:	e9 89       	ldd	r30, Y+17	; 0x11
    10c4:	ec 0f       	add	r30, r28
    10c6:	fd 2f       	mov	r31, r29
    10c8:	f1 1d       	adc	r31, r1
    10ca:	ed 5a       	subi	r30, 0xAD	; 173
    10cc:	ff 4f       	sbci	r31, 0xFF	; 255
    10ce:	00 83       	st	Z, r16
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:811
        _tx_buffer_head = i;
    10d0:	19 8b       	std	Y+17, r17	; 0x11
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:812
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
    10d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    10d4:	e8 85       	ldd	r30, Y+8	; 0x08
    10d6:	f9 85       	ldd	r31, Y+9	; 0x09
    10d8:	81 ff       	sbrs	r24, 1
    10da:	09 c0       	rjmp	.+18     	; 0x10ee <HardwareSerial::write(unsigned char)+0x92>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:813
          uint8_t ctrla = (*_hwserial_module).CTRLA;
    10dc:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:814
          ctrla &= ~USART_RXCIE_bm;
    10de:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:815
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
    10e0:	80 66       	ori	r24, 0x60	; 96
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:816
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
    10e2:	90 e4       	ldi	r25, 0x40	; 64
    10e4:	94 83       	std	Z+4, r25	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:817
          (*_hwserial_module).CTRLA = ctrla;
    10e6:	e8 85       	ldd	r30, Y+8	; 0x08
    10e8:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:820
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
    10ea:	85 83       	std	Z+5, r24	; 0x05
    10ec:	e3 cf       	rjmp	.-58     	; 0x10b4 <HardwareSerial::write(unsigned char)+0x58>
    10ee:	85 81       	ldd	r24, Z+5	; 0x05
    10f0:	80 62       	ori	r24, 0x20	; 32
    10f2:	fb cf       	rjmp	.-10     	; 0x10ea <HardwareSerial::write(unsigned char)+0x8e>

000010f4 <HardwareSerial::flush()>:
flush():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:737
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
    10f4:	cf 93       	push	r28
    10f6:	df 93       	push	r29
    10f8:	ec 01       	movw	r28, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:741
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
    10fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    10fc:	88 23       	and	r24, r24
    10fe:	59 f0       	breq	.+22     	; 0x1116 <HardwareSerial::flush()+0x22>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:756
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
    1100:	e8 85       	ldd	r30, Y+8	; 0x08
    1102:	f9 85       	ldd	r31, Y+9	; 0x09
    1104:	85 81       	ldd	r24, Z+5	; 0x05
    1106:	85 fd       	sbrc	r24, 5
    1108:	03 c0       	rjmp	.+6      	; 0x1110 <HardwareSerial::flush()+0x1c>
    110a:	84 81       	ldd	r24, Z+4	; 0x04
    110c:	86 fd       	sbrc	r24, 6
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:761

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
    110e:	03 c0       	rjmp	.+6      	; 0x1116 <HardwareSerial::flush()+0x22>
    1110:	ce 01       	movw	r24, r28
    1112:	86 df       	rcall	.-244    	; 0x1020 <HardwareSerial::_poll_tx_data_empty()>
    1114:	f5 cf       	rjmp	.-22     	; 0x1100 <HardwareSerial::flush()+0xc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:765
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	08 95       	ret

0000111c <TWI_MasterSetBaud.part.3>:
TWI_MasterSetBaud.part.3():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:204
 *
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     uint8_t 1 - something went wrong; 0 - new frequency set.
 */
uint8_t TWI_MasterSetBaud(struct twiData *_data, uint32_t frequency) {
    111c:	cf 92       	push	r12
    111e:	df 92       	push	r13
    1120:	ef 92       	push	r14
    1122:	ff 92       	push	r15
    1124:	cf 93       	push	r28
    1126:	df 93       	push	r29
    1128:	ec 01       	movw	r28, r24
    112a:	6a 01       	movw	r12, r20
    112c:	7b 01       	movw	r14, r22
    112e:	60 e0       	ldi	r22, 0x00	; 0
    1130:	7b e1       	ldi	r23, 0x1B	; 27
    1132:	87 eb       	ldi	r24, 0xB7	; 183
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	a7 01       	movw	r20, r14
    1138:	96 01       	movw	r18, r12
    113a:	0e 94 59 26 	call	0x4cb2	; 0x4cb2 <__udivmodsi4>
TWI_MasterCalcBaud():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:258
      baud = TWI_BAUD(frequency, 350);
    } else {                            // assuming 4.7kOhm
      baud = TWI_BAUD(frequency, 600);  // 300kHz will be off at 10MHz. Trade-off between size and accuracy
    }
  #else
    if (frequency >= 600000) {          // assuming 1.5kOhm
    113e:	80 ec       	ldi	r24, 0xC0	; 192
    1140:	c8 16       	cp	r12, r24
    1142:	87 e2       	ldi	r24, 0x27	; 39
    1144:	d8 06       	cpc	r13, r24
    1146:	89 e0       	ldi	r24, 0x09	; 9
    1148:	e8 06       	cpc	r14, r24
    114a:	f1 04       	cpc	r15, r1
    114c:	38 f0       	brcs	.+14     	; 0x115c <TWI_MasterSetBaud.part.3+0x40>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:259
      baud = TWI_BAUD(frequency, 250);
    114e:	28 50       	subi	r18, 0x08	; 8
    1150:	31 09       	sbc	r19, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:275
    const uint8_t baudlimit = 1;
  #else
    const uint8_t baudlimit = 0;
  #endif

  if (baud < baudlimit) {
    1152:	22 30       	cpi	r18, 0x02	; 2
    1154:	31 05       	cpc	r19, r1
    1156:	64 f4       	brge	.+24     	; 0x1170 <TWI_MasterSetBaud.part.3+0x54>
TWI_MasterSetBaud.part.3():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:276
    return baudlimit;
    1158:	22 e0       	ldi	r18, 0x02	; 2
    115a:	0a c0       	rjmp	.+20     	; 0x1170 <TWI_MasterSetBaud.part.3+0x54>
TWI_MasterCalcBaud():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:260
      baud = TWI_BAUD(frequency, 600);  // 300kHz will be off at 10MHz. Trade-off between size and accuracy
    }
  #else
    if (frequency >= 600000) {          // assuming 1.5kOhm
      baud = TWI_BAUD(frequency, 250);
    } else if (frequency >= 400000) {   // assuming 2.2kOhm
    115c:	80 e8       	ldi	r24, 0x80	; 128
    115e:	c8 16       	cp	r12, r24
    1160:	8a e1       	ldi	r24, 0x1A	; 26
    1162:	d8 06       	cpc	r13, r24
    1164:	86 e0       	ldi	r24, 0x06	; 6
    1166:	e8 06       	cpc	r14, r24
    1168:	f1 04       	cpc	r15, r1
    116a:	10 f1       	brcs	.+68     	; 0x11b0 <TWI_MasterSetBaud.part.3+0x94>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:261
      baud = TWI_BAUD(frequency, 400);
    116c:	29 50       	subi	r18, 0x09	; 9
    116e:	31 09       	sbc	r19, r1
TWI_MasterSetBaud.part.3():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:217
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    uint8_t newBaud = TWI_MasterCalcBaud(frequency);      // get the new Baud value
    uint8_t oldBaud = _data->_module->MBAUD;              // load the old Baud value
    1170:	e8 81       	ld	r30, Y
    1172:	f9 81       	ldd	r31, Y+1	; 0x01
    1174:	86 81       	ldd	r24, Z+6	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:218
    if (newBaud != oldBaud) {                             // compare both, in case the code is issuing this before every transmission.
    1176:	82 17       	cp	r24, r18
    1178:	99 f0       	breq	.+38     	; 0x11a0 <TWI_MasterSetBaud.part.3+0x84>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:219
      uint8_t restore = _data->_module->MCTRLA;           // Save the old Master state
    117a:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:220
      _data->_module->MCTRLA    = 0;                      // Disable Master
    117c:	13 82       	std	Z+3, r1	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:221
      _data->_module->MBAUD     = newBaud;                // update Baud register
    117e:	26 83       	std	Z+6, r18	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:222
      if (frequency > 400000) {
    1180:	81 e8       	ldi	r24, 0x81	; 129
    1182:	c8 16       	cp	r12, r24
    1184:	8a e1       	ldi	r24, 0x1A	; 26
    1186:	d8 06       	cpc	r13, r24
    1188:	86 e0       	ldi	r24, 0x06	; 6
    118a:	e8 06       	cpc	r14, r24
    118c:	f1 04       	cpc	r15, r1
    118e:	d8 f0       	brcs	.+54     	; 0x11c6 <TWI_MasterSetBaud.part.3+0xaa>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:223
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
    1190:	80 81       	ld	r24, Z
    1192:	82 60       	ori	r24, 0x02	; 2
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:225
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
    1194:	80 83       	st	Z, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:227
      }
      _data->_module->MCTRLA    = restore;                // restore the old register, thus enabling it again
    1196:	93 83       	std	Z+3, r25	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:228
      if (restore & TWI_ENABLE_bm) {                      // If the TWI was enabled,
    1198:	90 ff       	sbrs	r25, 0
    119a:	02 c0       	rjmp	.+4      	; 0x11a0 <TWI_MasterSetBaud.part.3+0x84>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:229
        _data->_module->MSTATUS   = TWI_BUSSTATE_IDLE_gc;   // Force the state machine into IDLE according to the data sheet
    119c:	81 e0       	ldi	r24, 0x01	; 1
    119e:	85 83       	std	Z+5, r24	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:235
      }
    }
    return 0;
  }
  return 1;
}
    11a0:	80 e0       	ldi	r24, 0x00	; 0
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	ff 90       	pop	r15
    11a8:	ef 90       	pop	r14
    11aa:	df 90       	pop	r13
    11ac:	cf 90       	pop	r12
    11ae:	08 95       	ret
TWI_MasterCalcBaud():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:263
    if (frequency >= 600000) {          // assuming 1.5kOhm
      baud = TWI_BAUD(frequency, 250);
    } else if (frequency >= 400000) {   // assuming 2.2kOhm
      baud = TWI_BAUD(frequency, 400);
    } else {                            // assuming 4.7kOhm
      baud = TWI_BAUD(frequency, 600);
    11b0:	2c 50       	subi	r18, 0x0C	; 12
    11b2:	31 09       	sbc	r19, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:275
    const uint8_t baudlimit = 1;
  #else
    const uint8_t baudlimit = 0;
  #endif

  if (baud < baudlimit) {
    11b4:	22 30       	cpi	r18, 0x02	; 2
    11b6:	31 05       	cpc	r19, r1
    11b8:	7c f2       	brlt	.-98     	; 0x1158 <TWI_MasterSetBaud.part.3+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:277
    return baudlimit;
  } else if (baud > 255) {
    11ba:	2f 3f       	cpi	r18, 0xFF	; 255
    11bc:	31 05       	cpc	r19, r1
    11be:	c1 f2       	breq	.-80     	; 0x1170 <TWI_MasterSetBaud.part.3+0x54>
    11c0:	bc f2       	brlt	.-82     	; 0x1170 <TWI_MasterSetBaud.part.3+0x54>
TWI_MasterSetBaud.part.3():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:278
    return 255;
    11c2:	2f ef       	ldi	r18, 0xFF	; 255
    11c4:	d5 cf       	rjmp	.-86     	; 0x1170 <TWI_MasterSetBaud.part.3+0x54>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:225
      _data->_module->MCTRLA    = 0;                      // Disable Master
      _data->_module->MBAUD     = newBaud;                // update Baud register
      if (frequency > 400000) {
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
    11c6:	80 81       	ld	r24, Z
    11c8:	8d 7f       	andi	r24, 0xFD	; 253
    11ca:	e4 cf       	rjmp	.-56     	; 0x1194 <TWI_MasterSetBaud.part.3+0x78>

000011cc <TWI_MasterWrite>:
TWI_MasterWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:298
 *@param      bool send_stop enables the STOP condition at the end of a write
 *
 *@return     uint8_t
 *@retval     error code, if enabled. Not 0 means something went wrong
 */
uint8_t TWI_MasterWrite(struct twiData *_data, bool send_stop) {
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
    11d0:	dc 01       	movw	r26, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:309
  #else                                                   // Separate tx/rx Buffers
    txHead   = &(_data->_bytesToWrite);
    txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
    11d2:	ed 91       	ld	r30, X+
    11d4:	fc 91       	ld	r31, X
    11d6:	11 97       	sbiw	r26, 0x01	; 1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:320
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
  #endif


    if (((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) || // If the bus was not initialized
    11d8:	85 81       	ldd	r24, Z+5	; 0x05
    11da:	83 70       	andi	r24, 0x03	; 3
    11dc:	09 f4       	brne	.+2      	; 0x11e0 <TWI_MasterWrite+0x14>
    11de:	43 c0       	rjmp	.+134    	; 0x1266 <TWI_MasterWrite+0x9a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:321
      ((module->MCTRLA & TWI_ENABLE_bm) == false)) {  // Or is disabled,
    11e0:	83 81       	ldd	r24, Z+3	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:320
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
  #endif


    if (((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) || // If the bus was not initialized
    11e2:	80 ff       	sbrs	r24, 0
    11e4:	40 c0       	rjmp	.+128    	; 0x1266 <TWI_MasterWrite+0x9a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:316
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  twi_buffer_index_t dataWritten = 0;
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
    11e6:	30 e0       	ldi	r19, 0x00	; 0
    11e8:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:314
  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  twi_buffer_index_t dataWritten = 0;
    11ea:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:326
      ((module->MCTRLA & TWI_ENABLE_bm) == false)) {  // Or is disabled,
      return TWI_ERR_UNINIT;                          // return
    }

  while (true) {
    currentStatus = module->MSTATUS;
    11ec:	45 81       	ldd	r20, Z+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:327
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
    11ee:	84 2f       	mov	r24, r20
    11f0:	83 70       	andi	r24, 0x03	; 3
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:330

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
    11f2:	2f 5f       	subi	r18, 0xFF	; 255
    11f4:	3f 4f       	sbci	r19, 0xFF	; 255
    11f6:	21 3c       	cpi	r18, 0xC1	; 193
    11f8:	5d e5       	ldi	r21, 0x5D	; 93
    11fa:	35 07       	cpc	r19, r21
    11fc:	50 f0       	brcs	.+20     	; 0x1212 <TWI_MasterWrite+0x46>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:331
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
    11fe:	82 30       	cpi	r24, 0x02	; 2
    1200:	71 f1       	breq	.+92     	; 0x125e <TWI_MasterWrite+0x92>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:333
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	71 f1       	breq	.+92     	; 0x1262 <TWI_MasterWrite+0x96>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:336
          TWI_SET_ERROR(TWI_ERR_PULLUP);
        } else {
          TWI_SET_ERROR(TWI_ERR_UNDEFINED);
    1206:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:376
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
    1208:	93 e0       	ldi	r25, 0x03	; 3
    120a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:379
  }
  return TWI_GET_ERROR;
}
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:342
        }
        break;
      }
    #endif

    if   (currentStatus & TWI_ARBLOST_bm) {     // Check for Bus error
    1212:	43 ff       	sbrs	r20, 3
    1214:	04 c0       	rjmp	.+8      	; 0x121e <TWI_MasterWrite+0x52>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:343
        module->MSTATUS = TWI_ARBLOST_bm;       // reset error flags
    1216:	88 e0       	ldi	r24, 0x08	; 8
    1218:	85 83       	std	Z+5, r24	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:344
        TWI_SET_ERROR(TWI_ERR_BUS_ARB);         // set error flag
    121a:	82 e1       	ldi	r24, 0x12	; 18
    121c:	f5 cf       	rjmp	.-22     	; 0x1208 <TWI_MasterWrite+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:348
        break;                                  // leave TX loop
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
    121e:	81 30       	cpi	r24, 0x01	; 1
    1220:	41 f4       	brne	.+16     	; 0x1232 <TWI_MasterWrite+0x66>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:349
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
    1222:	14 96       	adiw	r26, 0x04	; 4
    1224:	8c 91       	ld	r24, X
    1226:	14 97       	sbiw	r26, 0x04	; 4
    1228:	8e 7f       	andi	r24, 0xFE	; 254
    122a:	87 83       	std	Z+7, r24	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:364
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
            dataWritten++;                                        // data was Written
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                                        // reset timeout
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	dd cf       	rjmp	.-70     	; 0x11ec <TWI_MasterWrite+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:353
    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = 0;                           // reset timeout
        #endif
    } else if (currentSM == TWI_BUSSTATE_OWNER_gc) {              // Address was sent, host is owner
    1232:	82 30       	cpi	r24, 0x02	; 2
    1234:	d9 f6       	brne	.-74     	; 0x11ec <TWI_MasterWrite+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:354
      if     (currentStatus & TWI_WIF_bm) {                       // data sent
    1236:	46 ff       	sbrs	r20, 6
    1238:	d9 cf       	rjmp	.-78     	; 0x11ec <TWI_MasterWrite+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:355
        if   (currentStatus & TWI_RXACK_bm) {                     // AND the RXACK bit is set, last byte has failed
    123a:	44 ff       	sbrs	r20, 4
    123c:	04 c0       	rjmp	.+8      	; 0x1246 <TWI_MasterWrite+0x7a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:356
          if (dataWritten == 0) TWI_SET_ERROR(TWI_ERR_ACK_ADR);   // if dataWritten is 0, no payload was sent, so address was NACKed
    123e:	99 23       	and	r25, r25
    1240:	19 f3       	breq	.-58     	; 0x1208 <TWI_MasterWrite+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:357
          else                  TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // else payload was NACKed
    1242:	83 e0       	ldi	r24, 0x03	; 3
    1244:	e1 cf       	rjmp	.-62     	; 0x1208 <TWI_MasterWrite+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:360
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
    1246:	15 96       	adiw	r26, 0x05	; 5
    1248:	8c 91       	ld	r24, X
    124a:	15 97       	sbiw	r26, 0x05	; 5
    124c:	98 17       	cp	r25, r24
    124e:	68 f4       	brcc	.+26     	; 0x126a <TWI_MasterWrite+0x9e>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:361
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
    1250:	ed 01       	movw	r28, r26
    1252:	c9 0f       	add	r28, r25
    1254:	d1 1d       	adc	r29, r1
    1256:	8d 85       	ldd	r24, Y+13	; 0x0d
    1258:	80 87       	std	Z+8, r24	; 0x08
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:362
            dataWritten++;                                        // data was Written
    125a:	9f 5f       	subi	r25, 0xFF	; 255
    125c:	e7 cf       	rjmp	.-50     	; 0x122c <TWI_MasterWrite+0x60>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:332
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
        if        (currentSM == TWI_BUSSTATE_OWNER_gc) {
          TWI_SET_ERROR(TWI_ERR_TIMEOUT);
    125e:	85 e0       	ldi	r24, 0x05	; 5
    1260:	d3 cf       	rjmp	.-90     	; 0x1208 <TWI_MasterWrite+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:334
        } else if (currentSM == TWI_BUSSTATE_IDLE_gc) {
          TWI_SET_ERROR(TWI_ERR_PULLUP);
    1262:	81 e1       	ldi	r24, 0x11	; 17
    1264:	d1 cf       	rjmp	.-94     	; 0x1208 <TWI_MasterWrite+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:322
  #endif


    if (((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) || // If the bus was not initialized
      ((module->MCTRLA & TWI_ENABLE_bm) == false)) {  // Or is disabled,
      return TWI_ERR_UNINIT;                          // return
    1266:	80 e1       	ldi	r24, 0x10	; 16
    1268:	d1 cf       	rjmp	.-94     	; 0x120c <TWI_MasterWrite+0x40>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:311
    txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
    126a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:375
      }
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    126c:	66 23       	and	r22, r22
    126e:	71 f2       	breq	.-100    	; 0x120c <TWI_MasterWrite+0x40>
    1270:	cb cf       	rjmp	.-106    	; 0x1208 <TWI_MasterWrite+0x3c>

00001272 <TwoWire::flush()>:
TWI_Flush():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:130
 */
void TWI_Flush(struct twiData *_data) {
  #if defined(ERRATA_TWI_FLUSH)
    // badCall("The AVR DA-series parts are impacted by an errata that leaves the TWI peripheral in a non-functioning state when using flush.");
    // restarting TWI hardware by hand. Extra size shouldn't matter on DA series
    uint8_t temp_MCTRLA     = _data->_module->MCTRLA;
    1272:	dc 01       	movw	r26, r24
    1274:	18 96       	adiw	r26, 0x08	; 8
    1276:	ed 91       	ld	r30, X+
    1278:	fc 91       	ld	r31, X
    127a:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:131
    uint8_t temp_SCTRLA     = _data->_module->SCTRLA;
    127c:	81 85       	ldd	r24, Z+9	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:132
    _data->_module->MCTRLA  = 0x00;
    127e:	13 82       	std	Z+3, r1	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:133
    _data->_module->SCTRLA  = 0x00;
    1280:	11 86       	std	Z+9, r1	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:134
    _data->_module->MCTRLA  = temp_MCTRLA;
    1282:	93 83       	std	Z+3, r25	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:135
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
    1284:	91 e0       	ldi	r25, 0x01	; 1
    1286:	95 83       	std	Z+5, r25	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:136
    _data->_module->SCTRLA  = temp_SCTRLA;
    1288:	81 87       	std	Z+9, r24	; 0x09
flush():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:748
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
    128a:	08 95       	ret

0000128c <TwoWire::peek()>:
peek():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:726
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
    128c:	9c 01       	movw	r18, r24
    128e:	29 56       	subi	r18, 0x69	; 105
    1290:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:730
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
    1292:	dc 01       	movw	r26, r24
    1294:	1f 96       	adiw	r26, 0x0f	; 15
    1296:	ec 91       	ld	r30, X
    1298:	1f 97       	sbiw	r26, 0x0f	; 15
    129a:	1e 96       	adiw	r26, 0x0e	; 14
    129c:	8c 91       	ld	r24, X
    129e:	e8 17       	cp	r30, r24
    12a0:	30 f4       	brcc	.+12     	; 0x12ae <TwoWire::peek()+0x22>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:731
    return rxBuffer[(*rxTail)];
    12a2:	e2 0f       	add	r30, r18
    12a4:	f3 2f       	mov	r31, r19
    12a6:	f1 1d       	adc	r31, r1
    12a8:	80 81       	ld	r24, Z
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:733
  } else {      // No bytes to read
    return -1;
    12ae:	8f ef       	ldi	r24, 0xFF	; 255
    12b0:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:735
  }
}
    12b2:	08 95       	ret

000012b4 <TwoWire::read()>:
read():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:635
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
    12b4:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:653
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
    12b6:	dc 01       	movw	r26, r24
    12b8:	a9 56       	subi	r26, 0x69	; 105
    12ba:	bf 4f       	sbci	r27, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:658
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
    12bc:	97 85       	ldd	r25, Z+15	; 0x0f
    12be:	86 85       	ldd	r24, Z+14	; 0x0e
    12c0:	98 17       	cp	r25, r24
    12c2:	40 f4       	brcc	.+16     	; 0x12d4 <TwoWire::read()+0x20>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:659
    uint8_t c = rxBuffer[(*rxTail)];
    12c4:	a9 0f       	add	r26, r25
    12c6:	b1 1d       	adc	r27, r1
    12c8:	2c 91       	ld	r18, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:660
    (*rxTail)++;
    12ca:	9f 5f       	subi	r25, 0xFF	; 255
    12cc:	97 87       	std	Z+15, r25	; 0x0f
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:661
    return c;
    12ce:	82 2f       	mov	r24, r18
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:663
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
    12d4:	8f ef       	ldi	r24, 0xFF	; 255
    12d6:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:665
  }
}
    12d8:	08 95       	ret

000012da <TwoWire::available()>:
available():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:603
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
    12da:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
    12dc:	86 85       	ldd	r24, Z+14	; 0x0e
    12de:	97 85       	ldd	r25, Z+15	; 0x0f
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:618
    #endif
  }
  return rxHead;
}
    12e0:	89 1b       	sub	r24, r25
    12e2:	99 0b       	sbc	r25, r25
    12e4:	08 95       	ret

000012e6 <TwoWire::write(unsigned char)>:
write():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:536
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
    12e6:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:557
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
    12e8:	a5 85       	ldd	r26, Z+13	; 0x0d
    12ea:	a2 38       	cpi	r26, 0x82	; 130
    12ec:	58 f4       	brcc	.+22     	; 0x1304 <TwoWire::write(unsigned char)+0x1e>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:558
    txBuffer[(*txHead)] = data;             // Load data into the buffer
    12ee:	a8 0f       	add	r26, r24
    12f0:	b9 2f       	mov	r27, r25
    12f2:	b1 1d       	adc	r27, r1
    12f4:	55 96       	adiw	r26, 0x15	; 21
    12f6:	6c 93       	st	X, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:559
    (*txHead)++;                            // advancing the head
    12f8:	85 85       	ldd	r24, Z+13	; 0x0d
    12fa:	8f 5f       	subi	r24, 0xFF	; 255
    12fc:	85 87       	std	Z+13, r24	; 0x0d
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:560
    return 1;
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:562
  } else {
    return 0;
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:564
  }
}
    1308:	08 95       	ret

0000130a <TwoWire::write(unsigned char const*, unsigned int)>:
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:579
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
    130a:	bf 92       	push	r11
    130c:	cf 92       	push	r12
    130e:	df 92       	push	r13
    1310:	ef 92       	push	r14
    1312:	ff 92       	push	r15
    1314:	0f 93       	push	r16
    1316:	1f 93       	push	r17
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	7c 01       	movw	r14, r24
    131e:	6a 01       	movw	r12, r20
    1320:	b6 2e       	mov	r11, r22
    1322:	eb 01       	movw	r28, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:581
  twi_buffer_index_t i = 0;
  for (; i < quantity; i++) {
    1324:	0c 2f       	mov	r16, r28
    1326:	0b 19       	sub	r16, r11
    1328:	10 e0       	ldi	r17, 0x00	; 0
    132a:	0c 15       	cp	r16, r12
    132c:	1d 05       	cpc	r17, r13
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:582
    if (TwoWire::write(*(data++)) == 0)
    132e:	28 f4       	brcc	.+10     	; 0x133a <TwoWire::write(unsigned char const*, unsigned int)+0x30>
    1330:	69 91       	ld	r22, Y+
    1332:	c7 01       	movw	r24, r14
    1334:	d8 df       	rcall	.-80     	; 0x12e6 <TwoWire::write(unsigned char)>
    1336:	89 2b       	or	r24, r25
    1338:	a9 f7       	brne	.-22     	; 0x1324 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:587
      break;   // break if buffer full
  }

  return i;
}
    133a:	c8 01       	movw	r24, r16
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	ff 90       	pop	r15
    1346:	ef 90       	pop	r14
    1348:	df 90       	pop	r13
    134a:	cf 90       	pop	r12
    134c:	bf 90       	pop	r11
    134e:	08 95       	ret

00001350 <Adafruit_SPIDevice::transfer(unsigned char)>:
transfer():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:273
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI, without
 * transaction management
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
    1350:	af 92       	push	r10
    1352:	bf 92       	push	r11
    1354:	cf 92       	push	r12
    1356:	df 92       	push	r13
    1358:	ef 92       	push	r14
    135a:	ff 92       	push	r15
    135c:	0f 93       	push	r16
    135e:	1f 93       	push	r17
    1360:	cf 93       	push	r28
    1362:	df 93       	push	r29
    1364:	ec 01       	movw	r28, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:135
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
  //
  // HARDWARE SPI
  //
  if (_spi) {
    1366:	88 81       	ld	r24, Y
    1368:	99 81       	ldd	r25, Y+1	; 0x01
    136a:	89 2b       	or	r24, r25
    136c:	09 f0       	breq	.+2      	; 0x1370 <Adafruit_SPIDevice::transfer(unsigned char)+0x20>
    136e:	a2 c0       	rjmp	.+324    	; 0x14b4 <Adafruit_SPIDevice::transfer(unsigned char)+0x164>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:154

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    1370:	88 85       	ldd	r24, Y+8	; 0x08
    1372:	99 85       	ldd	r25, Y+9	; 0x09
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:155
    startbit = 0x1;
    1374:	11 e0       	ldi	r17, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:154

  //
  // SOFTWARE SPI
  //
  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
    1376:	89 2b       	or	r24, r25
    1378:	09 f0       	breq	.+2      	; 0x137c <Adafruit_SPIDevice::transfer(unsigned char)+0x2c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:157
    startbit = 0x1;
  } else {
    startbit = 0x80;
    137a:	10 e8       	ldi	r17, 0x80	; 128
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:160
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
    137c:	aa 24       	eor	r10, r10
    137e:	a3 94       	inc	r10
    1380:	86 2f       	mov	r24, r22
    1382:	81 23       	and	r24, r17
    1384:	09 f0       	breq	.+2      	; 0x1388 <Adafruit_SPIDevice::transfer(unsigned char)+0x38>
    1386:	a1 2c       	mov	r10, r1
    1388:	06 2f       	mov	r16, r22
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:161
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
    138a:	2c 81       	ldd	r18, Y+4	; 0x04
    138c:	3d 81       	ldd	r19, Y+5	; 0x05
    138e:	4e 81       	ldd	r20, Y+6	; 0x06
    1390:	5f 81       	ldd	r21, Y+7	; 0x07
    1392:	60 e2       	ldi	r22, 0x20	; 32
    1394:	71 ea       	ldi	r23, 0xA1	; 161
    1396:	87 e0       	ldi	r24, 0x07	; 7
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	0e 94 59 26 	call	0x4cb2	; 0x4cb2 <__udivmodsi4>
    139e:	d2 2e       	mov	r13, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:164

  for (size_t i = 0; i < len; i++) {
    uint8_t reply = 0;
    13a0:	b0 2e       	mov	r11, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:178
    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
    13a2:	c1 2c       	mov	r12, r1
    13a4:	e2 2e       	mov	r14, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:177

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
    13a6:	f1 2c       	mov	r15, r1
    13a8:	dd 20       	and	r13, r13
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1134
inline __attribute__((always_inline)) void delayMicroseconds(unsigned int us) {
  // This function gets optimized away, but to what depends on whether us is constant.
  if (__builtin_constant_p(us)) {
    _delay_us(us); // Constant microseconds use the avr-libc _delay_us() which is highly accurate for all values and efficient!
  } else { // If it is not, we have to use the Arduino style implementation.
    _delayMicroseconds(us);
    13aa:	11 f0       	breq	.+4      	; 0x13b0 <Adafruit_SPIDevice::transfer(unsigned char)+0x60>
delayMicroseconds():
    13ac:	c7 01       	movw	r24, r14
    13ae:	70 dc       	rcall	.-1824   	; 0xc90 <_delayMicroseconds>
transfer():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:181
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
    13b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    13b2:	8d 7f       	andi	r24, 0xFD	; 253
    13b4:	84 30       	cpi	r24, 0x04	; 4
    13b6:	09 f0       	breq	.+2      	; 0x13ba <Adafruit_SPIDevice::transfer(unsigned char)+0x6a>
    13b8:	4d c0       	rjmp	.+154    	; 0x1454 <Adafruit_SPIDevice::transfer(unsigned char)+0x104>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:183
        towrite = send & b;
        if ((_mosi != -1) && (lastmosi != towrite)) {
    13ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    13bc:	8f 3f       	cpi	r24, 0xFF	; 255
    13be:	89 f0       	breq	.+34     	; 0x13e2 <Adafruit_SPIDevice::transfer(unsigned char)+0x92>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:182
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
    13c0:	80 2f       	mov	r24, r16
    13c2:	81 23       	and	r24, r17
    13c4:	91 e0       	ldi	r25, 0x01	; 1
    13c6:	09 f4       	brne	.+2      	; 0x13ca <Adafruit_SPIDevice::transfer(unsigned char)+0x7a>
    13c8:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:183
        if ((_mosi != -1) && (lastmosi != towrite)) {
    13ca:	9a 15       	cp	r25, r10
    13cc:	51 f0       	breq	.+20     	; 0x13e2 <Adafruit_SPIDevice::transfer(unsigned char)+0x92>
    13ce:	ef 85       	ldd	r30, Y+15	; 0x0f
    13d0:	f8 89       	ldd	r31, Y+16	; 0x10
    13d2:	9f 89       	ldd	r25, Y+23	; 0x17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:185
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
    13d4:	88 23       	and	r24, r24
    13d6:	c1 f1       	breq	.+112    	; 0x1448 <Adafruit_SPIDevice::transfer(unsigned char)+0xf8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:186
            *mosiPort = *mosiPort | mosiPinMask;
    13d8:	80 81       	ld	r24, Z
    13da:	98 2b       	or	r25, r24
    13dc:	90 83       	st	Z, r25
    13de:	aa 24       	eor	r10, r10
    13e0:	a3 94       	inc	r10
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:196
#endif
          lastmosi = towrite;
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort = *clkPort | clkPinMask; // Clock high
    13e2:	e9 89       	ldd	r30, Y+17	; 0x11
    13e4:	fa 89       	ldd	r31, Y+18	; 0x12
    13e6:	80 81       	ld	r24, Z
    13e8:	99 8d       	ldd	r25, Y+25	; 0x19
    13ea:	89 2b       	or	r24, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:201
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
    13ec:	80 83       	st	Z, r24
    13ee:	dd 20       	and	r13, r13
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1134
    13f0:	11 f0       	breq	.+4      	; 0x13f6 <Adafruit_SPIDevice::transfer(unsigned char)+0xa6>
delayMicroseconds():
    13f2:	c7 01       	movw	r24, r14
    13f4:	4d dc       	rcall	.-1894   	; 0xc90 <_delayMicroseconds>
transfer():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:205
          delayMicroseconds(bitdelay_us);
        }

        if (_miso != -1) {
    13f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    13f8:	8f 3f       	cpi	r24, 0xFF	; 255
    13fa:	39 f0       	breq	.+14     	; 0x140a <Adafruit_SPIDevice::transfer(unsigned char)+0xba>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:207
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
    13fc:	eb 89       	ldd	r30, Y+19	; 0x13
    13fe:	fc 89       	ldd	r31, Y+20	; 0x14
    1400:	80 81       	ld	r24, Z
    1402:	98 8d       	ldd	r25, Y+24	; 0x18
    1404:	89 23       	and	r24, r25
    1406:	09 f0       	breq	.+2      	; 0x140a <Adafruit_SPIDevice::transfer(unsigned char)+0xba>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:211
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
    1408:	c1 2a       	or	r12, r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:216
          }
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort = *clkPort & ~clkPinMask; // Clock low
    140a:	e9 89       	ldd	r30, Y+17	; 0x11
    140c:	fa 89       	ldd	r31, Y+18	; 0x12
    140e:	90 81       	ld	r25, Z
    1410:	89 8d       	ldd	r24, Y+25	; 0x19
    1412:	80 95       	com	r24
    1414:	89 23       	and	r24, r25
    1416:	80 83       	st	Z, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:259
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
    1418:	8e 85       	ldd	r24, Y+14	; 0x0e
    141a:	8f 3f       	cpi	r24, 0xFF	; 255
    141c:	09 f0       	breq	.+2      	; 0x1420 <Adafruit_SPIDevice::transfer(unsigned char)+0xd0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:260
        buffer[i] = reply;
    141e:	bc 2c       	mov	r11, r12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:174
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    1420:	88 85       	ldd	r24, Y+8	; 0x08
    1422:	99 85       	ldd	r25, Y+9	; 0x09
    1424:	89 2b       	or	r24, r25
    1426:	09 f0       	breq	.+2      	; 0x142a <Adafruit_SPIDevice::transfer(unsigned char)+0xda>
    1428:	43 c0       	rjmp	.+134    	; 0x14b0 <Adafruit_SPIDevice::transfer(unsigned char)+0x160>
    142a:	11 0f       	add	r17, r17
    142c:	11 11       	cpse	r17, r1
    142e:	bc cf       	rjmp	.-136    	; 0x13a8 <Adafruit_SPIDevice::transfer(unsigned char)+0x58>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:277
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
  return data;
}
    1430:	8b 2d       	mov	r24, r11
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	ff 90       	pop	r15
    143c:	ef 90       	pop	r14
    143e:	df 90       	pop	r13
    1440:	cf 90       	pop	r12
    1442:	bf 90       	pop	r11
    1444:	af 90       	pop	r10
    1446:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:188
        if ((_mosi != -1) && (lastmosi != towrite)) {
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
            *mosiPort = *mosiPort | mosiPinMask;
          else
            *mosiPort = *mosiPort & ~mosiPinMask;
    1448:	80 81       	ld	r24, Z
    144a:	90 95       	com	r25
    144c:	98 23       	and	r25, r24
    144e:	90 83       	st	Z, r25
    1450:	a1 2c       	mov	r10, r1
    1452:	c7 cf       	rjmp	.-114    	; 0x13e2 <Adafruit_SPIDevice::transfer(unsigned char)+0x92>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:223
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort = *clkPort | clkPinMask; // Clock high
    1454:	e9 89       	ldd	r30, Y+17	; 0x11
    1456:	fa 89       	ldd	r31, Y+18	; 0x12
    1458:	80 81       	ld	r24, Z
    145a:	99 8d       	ldd	r25, Y+25	; 0x19
    145c:	89 2b       	or	r24, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:228
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
    145e:	80 83       	st	Z, r24
    1460:	dd 20       	and	r13, r13
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1134
    1462:	11 f0       	breq	.+4      	; 0x1468 <Adafruit_SPIDevice::transfer(unsigned char)+0x118>
delayMicroseconds():
    1464:	c7 01       	movw	r24, r14
    1466:	14 dc       	rcall	.-2008   	; 0xc90 <_delayMicroseconds>
transfer():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:232
          delayMicroseconds(bitdelay_us);
        }

        if (_mosi != -1) {
    1468:	8d 85       	ldd	r24, Y+13	; 0x0d
    146a:	8f 3f       	cpi	r24, 0xFF	; 255
    146c:	49 f0       	breq	.+18     	; 0x1480 <Adafruit_SPIDevice::transfer(unsigned char)+0x130>
    146e:	ef 85       	ldd	r30, Y+15	; 0x0f
    1470:	f8 89       	ldd	r31, Y+16	; 0x10
    1472:	8f 89       	ldd	r24, Y+23	; 0x17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:234
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
    1474:	90 2f       	mov	r25, r16
    1476:	91 23       	and	r25, r17
    1478:	b9 f0       	breq	.+46     	; 0x14a8 <Adafruit_SPIDevice::transfer(unsigned char)+0x158>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:235
            *mosiPort = *mosiPort | mosiPinMask;
    147a:	90 81       	ld	r25, Z
    147c:	89 2b       	or	r24, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:237
          else
            *mosiPort = *mosiPort & ~mosiPinMask;
    147e:	80 83       	st	Z, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:244
          digitalWrite(_mosi, send & b);
#endif
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort = *clkPort & ~clkPinMask; // Clock low
    1480:	e9 89       	ldd	r30, Y+17	; 0x11
    1482:	fa 89       	ldd	r31, Y+18	; 0x12
    1484:	90 81       	ld	r25, Z
    1486:	89 8d       	ldd	r24, Y+25	; 0x19
    1488:	80 95       	com	r24
    148a:	89 23       	and	r24, r25
    148c:	80 83       	st	Z, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:249
#else
        digitalWrite(_sck, LOW);
#endif

        if (_miso != -1) {
    148e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1490:	8f 3f       	cpi	r24, 0xFF	; 255
    1492:	09 f4       	brne	.+2      	; 0x1496 <Adafruit_SPIDevice::transfer(unsigned char)+0x146>
    1494:	c1 cf       	rjmp	.-126    	; 0x1418 <Adafruit_SPIDevice::transfer(unsigned char)+0xc8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:251
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
    1496:	eb 89       	ldd	r30, Y+19	; 0x13
    1498:	fc 89       	ldd	r31, Y+20	; 0x14
    149a:	80 81       	ld	r24, Z
    149c:	98 8d       	ldd	r25, Y+24	; 0x18
    149e:	89 23       	and	r24, r25
    14a0:	09 f4       	brne	.+2      	; 0x14a4 <Adafruit_SPIDevice::transfer(unsigned char)+0x154>
    14a2:	ba cf       	rjmp	.-140    	; 0x1418 <Adafruit_SPIDevice::transfer(unsigned char)+0xc8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:255
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
    14a4:	c1 2a       	or	r12, r17
    14a6:	b8 cf       	rjmp	.-144    	; 0x1418 <Adafruit_SPIDevice::transfer(unsigned char)+0xc8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:237
        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
            *mosiPort = *mosiPort | mosiPinMask;
          else
            *mosiPort = *mosiPort & ~mosiPinMask;
    14a8:	90 81       	ld	r25, Z
    14aa:	80 95       	com	r24
    14ac:	89 23       	and	r24, r25
    14ae:	e7 cf       	rjmp	.-50     	; 0x147e <Adafruit_SPIDevice::transfer(unsigned char)+0x12e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:174
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
    14b0:	16 95       	lsr	r17
    14b2:	bc cf       	rjmp	.-136    	; 0x142c <Adafruit_SPIDevice::transfer(unsigned char)+0xdc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:632
}

void SPIClass::transfer(void *buf, size_t count) {
  uint8_t *buffer = reinterpret_cast<uint8_t *>(buf);
  for (size_t i = 0; i < count; i++) {
    *buffer = transfer(*buffer);
    14b4:	86 2f       	mov	r24, r22
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:277
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
  return data;
}
    14b6:	df 91       	pop	r29
    14b8:	cf 91       	pop	r28
    14ba:	1f 91       	pop	r17
    14bc:	0f 91       	pop	r16
    14be:	ff 90       	pop	r15
    14c0:	ef 90       	pop	r14
    14c2:	df 90       	pop	r13
    14c4:	cf 90       	pop	r12
    14c6:	bf 90       	pop	r11
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:632
    14c8:	af 90       	pop	r10
    14ca:	d7 cb       	rjmp	.-2130   	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>

000014cc <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.1]>:
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.part.1():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:102
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	ec 01       	movw	r28, r24
    14d8:	8a 01       	movw	r16, r20
    14da:	f2 2e       	mov	r15, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:128
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
    14dc:	89 81       	ldd	r24, Y+1	; 0x01
    14de:	9a 81       	ldd	r25, Y+2	; 0x02
    14e0:	dc 01       	movw	r26, r24
    14e2:	ed 91       	ld	r30, X+
    14e4:	fc 91       	ld	r31, X
    14e6:	02 80       	ldd	r0, Z+2	; 0x02
    14e8:	f3 81       	ldd	r31, Z+3	; 0x03
    14ea:	e0 2d       	mov	r30, r0
    14ec:	09 95       	icall
    14ee:	08 17       	cp	r16, r24
    14f0:	19 07       	cpc	r17, r25
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:518
 *           20 for likely a slave holding the clock low
 *          255 (-1) for TWI not initialized (begin not called) or bus somehow in "unknown" state.
 */
uint8_t TwoWire::endTransmission(bool sendStop) {
  // transmit (blocking)
  return TWI_MasterWrite(&vars, sendStop);
    14f2:	39 f4       	brne	.+14     	; 0x1502 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.1]+0x36>
endTransmission():
    14f4:	89 81       	ldd	r24, Y+1	; 0x01
    14f6:	9a 81       	ldd	r25, Y+2	; 0x02
    14f8:	6f 2d       	mov	r22, r15
    14fa:	08 96       	adiw	r24, 0x08	; 8
    14fc:	67 de       	rcall	.-818    	; 0x11cc <TWI_MasterWrite>
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.part.1():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:161
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
    14fe:	91 e0       	ldi	r25, 0x01	; 1
    1500:	81 11       	cpse	r24, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:132
  // Write the data itself
  if (_wire->write(buffer, len) != len) {
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice failed to write"));
#endif
    return false;
    1502:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:173
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
    1504:	89 2f       	mov	r24, r25
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	1f 91       	pop	r17
    150c:	0f 91       	pop	r16
    150e:	ff 90       	pop	r15
    1510:	08 95       	ret

00001512 <Adafruit_GFX::invertDisplay(bool)>:
invertDisplay():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1543
*/
/**************************************************************************/
void Adafruit_GFX::invertDisplay(bool i) {
  // Do nothing, must be subclassed if supported by hardware
  (void)i; // disable -Wunused-parameter warning
}
    1512:	08 95       	ret

00001514 <Adafruit_GFX::setRotation(unsigned char)>:
setRotation():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1316
/*!
    @brief      Set rotation setting for display
    @param  x   0 thru 3 corresponding to 4 cardinal rotations
*/
/**************************************************************************/
void Adafruit_GFX::setRotation(uint8_t x) {
    1514:	fc 01       	movw	r30, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1317
  rotation = (x & 3);
    1516:	63 70       	andi	r22, 0x03	; 3
    1518:	66 8b       	std	Z+22, r22	; 0x16
    151a:	84 81       	ldd	r24, Z+4	; 0x04
    151c:	95 81       	ldd	r25, Z+5	; 0x05
    151e:	26 81       	ldd	r18, Z+6	; 0x06
    1520:	37 81       	ldd	r19, Z+7	; 0x07
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1318
  switch (rotation) {
    1522:	61 30       	cpi	r22, 0x01	; 1
    1524:	39 f0       	breq	.+14     	; 0x1534 <Adafruit_GFX::setRotation(unsigned char)+0x20>
    1526:	63 30       	cpi	r22, 0x03	; 3
    1528:	29 f0       	breq	.+10     	; 0x1534 <Adafruit_GFX::setRotation(unsigned char)+0x20>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1321
  case 0:
  case 2:
    _width = WIDTH;
    152a:	80 87       	std	Z+8, r24	; 0x08
    152c:	91 87       	std	Z+9, r25	; 0x09
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1322
    _height = HEIGHT;
    152e:	22 87       	std	Z+10, r18	; 0x0a
    1530:	33 87       	std	Z+11, r19	; 0x0b
    1532:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1326
    break;
  case 1:
  case 3:
    _width = HEIGHT;
    1534:	20 87       	std	Z+8, r18	; 0x08
    1536:	31 87       	std	Z+9, r19	; 0x09
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1327
    _height = WIDTH;
    1538:	82 87       	std	Z+10, r24	; 0x0a
    153a:	93 87       	std	Z+11, r25	; 0x0b
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1330
    break;
  }
}
    153c:	08 95       	ret

0000153e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)>:
drawChar():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1136
    @param    size_y  Font magnification level in Y-axis, 1 is 'original' size
*/
/**************************************************************************/
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
                            uint16_t color, uint16_t bg, uint8_t size_x,
                            uint8_t size_y) {
    153e:	2f 92       	push	r2
    1540:	3f 92       	push	r3
    1542:	4f 92       	push	r4
    1544:	5f 92       	push	r5
    1546:	6f 92       	push	r6
    1548:	7f 92       	push	r7
    154a:	8f 92       	push	r8
    154c:	9f 92       	push	r9
    154e:	af 92       	push	r10
    1550:	bf 92       	push	r11
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
    155c:	1f 93       	push	r17
    155e:	cf 93       	push	r28
    1560:	df 93       	push	r29
    1562:	cd b7       	in	r28, 0x3d	; 61
    1564:	de b7       	in	r29, 0x3e	; 62
    1566:	6a 97       	sbiw	r28, 0x1a	; 26
    1568:	cd bf       	out	0x3d, r28	; 61
    156a:	de bf       	out	0x3e, r29	; 62
    156c:	89 8f       	std	Y+25, r24	; 0x19
    156e:	9a 8f       	std	Y+26, r25	; 0x1a
    1570:	69 83       	std	Y+1, r22	; 0x01
    1572:	7a 83       	std	Y+2, r23	; 0x02
    1574:	4a 01       	movw	r8, r20
    1576:	d2 2e       	mov	r13, r18
    1578:	0f 83       	std	Y+7, r16	; 0x07
    157a:	18 87       	std	Y+8, r17	; 0x08
    157c:	37 01       	movw	r6, r14
    157e:	bc 2c       	mov	r11, r12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1138

  if (!gfxFont) { // 'Classic' built-in font
    1580:	dc 01       	movw	r26, r24
    1582:	59 96       	adiw	r26, 0x19	; 25
    1584:	2d 91       	ld	r18, X+
    1586:	3c 91       	ld	r19, X
    1588:	5a 97       	sbiw	r26, 0x1a	; 26
    158a:	21 15       	cp	r18, r1
    158c:	31 05       	cpc	r19, r1
    158e:	09 f0       	breq	.+2      	; 0x1592 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x54>
    1590:	12 c1       	rjmp	.+548    	; 0x17b6 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x278>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1140

    if ((x >= _width) ||              // Clip right
    1592:	18 96       	adiw	r26, 0x08	; 8
    1594:	8d 91       	ld	r24, X+
    1596:	9c 91       	ld	r25, X
    1598:	19 97       	sbiw	r26, 0x09	; 9
    159a:	68 17       	cp	r22, r24
    159c:	79 07       	cpc	r23, r25
    159e:	0c f0       	brlt	.+2      	; 0x15a2 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x64>
    15a0:	d4 c1       	rjmp	.+936    	; 0x194a <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x40c>
    15a2:	1a 96       	adiw	r26, 0x0a	; 10
    15a4:	8d 91       	ld	r24, X+
    15a6:	9c 91       	ld	r25, X
    15a8:	48 17       	cp	r20, r24
    15aa:	59 07       	cpc	r21, r25
    15ac:	0c f0       	brlt	.+2      	; 0x15b0 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x72>
    15ae:	cd c1       	rjmp	.+922    	; 0x194a <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x40c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1142
        (y >= _height) ||             // Clip bottom
        ((x + 6 * size_x - 1) < 0) || // Clip left
    15b0:	4c 2c       	mov	r4, r12
    15b2:	51 2c       	mov	r5, r1
    15b4:	b6 e0       	ldi	r27, 0x06	; 6
    15b6:	cb 9e       	mul	r12, r27
    15b8:	60 0d       	add	r22, r0
    15ba:	71 1d       	adc	r23, r1
    15bc:	11 24       	eor	r1, r1
    15be:	6b 87       	std	Y+11, r22	; 0x0b
    15c0:	7c 87       	std	Y+12, r23	; 0x0c
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1141
                            uint8_t size_y) {

  if (!gfxFont) { // 'Classic' built-in font

    if ((x >= _width) ||              // Clip right
        (y >= _height) ||             // Clip bottom
    15c2:	16 16       	cp	r1, r22
    15c4:	17 06       	cpc	r1, r23
    15c6:	0c f0       	brlt	.+2      	; 0x15ca <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x8c>
    15c8:	c0 c1       	rjmp	.+896    	; 0x194a <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x40c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1143
        ((x + 6 * size_x - 1) < 0) || // Clip left
        ((y + 8 * size_y - 1) < 0))   // Clip top
    15ca:	ea 2d       	mov	r30, r10
    15cc:	f0 e0       	ldi	r31, 0x00	; 0
    15ce:	e9 87       	std	Y+9, r30	; 0x09
    15d0:	fa 87       	std	Y+10, r31	; 0x0a
    15d2:	93 e0       	ldi	r25, 0x03	; 3
    15d4:	ee 0f       	add	r30, r30
    15d6:	ff 1f       	adc	r31, r31
    15d8:	9a 95       	dec	r25
    15da:	e1 f7       	brne	.-8      	; 0x15d4 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x96>
    15dc:	ef 87       	std	Y+15, r30	; 0x0f
    15de:	f8 8b       	std	Y+16, r31	; 0x10
    15e0:	cf 01       	movw	r24, r30
    15e2:	84 0f       	add	r24, r20
    15e4:	95 1f       	adc	r25, r21
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1142

  if (!gfxFont) { // 'Classic' built-in font

    if ((x >= _width) ||              // Clip right
        (y >= _height) ||             // Clip bottom
        ((x + 6 * size_x - 1) < 0) || // Clip left
    15e6:	18 16       	cp	r1, r24
    15e8:	19 06       	cpc	r1, r25
    15ea:	0c f0       	brlt	.+2      	; 0x15ee <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0xb0>
    15ec:	ae c1       	rjmp	.+860    	; 0x194a <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x40c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1146
        ((y + 8 * size_y - 1) < 0))   // Clip top
      return;

    if (!_cp437 && (c >= 176))
    15ee:	a9 8d       	ldd	r26, Y+25	; 0x19
    15f0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    15f2:	58 96       	adiw	r26, 0x18	; 24
    15f4:	8c 91       	ld	r24, X
    15f6:	81 11       	cpse	r24, r1
    15f8:	04 c0       	rjmp	.+8      	; 0x1602 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0xc4>
    15fa:	bf ea       	ldi	r27, 0xAF	; 175
    15fc:	bd 15       	cp	r27, r13
    15fe:	08 f4       	brcc	.+2      	; 0x1602 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0xc4>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1147
      c++; // Handle 'classic' charset behavior
    1600:	d3 94       	inc	r13
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1149

    startWrite();
    1602:	a9 8d       	ldd	r26, Y+25	; 0x19
    1604:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1606:	ed 91       	ld	r30, X+
    1608:	fc 91       	ld	r31, X
    160a:	11 97       	sbiw	r26, 0x01	; 1
    160c:	02 84       	ldd	r0, Z+10	; 0x0a
    160e:	f3 85       	ldd	r31, Z+11	; 0x0b
    1610:	e0 2d       	mov	r30, r0
    1612:	cd 01       	movw	r24, r26
    1614:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1151
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
    1616:	b5 e0       	ldi	r27, 0x05	; 5
    1618:	db 9e       	mul	r13, r27
    161a:	c0 01       	movw	r24, r0
    161c:	11 24       	eor	r1, r1
    161e:	e9 81       	ldd	r30, Y+1	; 0x01
    1620:	fa 81       	ldd	r31, Y+2	; 0x02
    1622:	eb 83       	std	Y+3, r30	; 0x03
    1624:	fc 83       	std	Y+4, r31	; 0x04
    1626:	31 2c       	mov	r3, r1
    1628:	21 2c       	mov	r2, r1
    162a:	9c 01       	movw	r18, r24
    162c:	20 56       	subi	r18, 0x60	; 96
    162e:	3f 4f       	sbci	r19, 0xFF	; 255
    1630:	2f 8b       	std	Y+23, r18	; 0x17
    1632:	38 8f       	std	Y+24, r19	; 0x18
    1634:	4a 2d       	mov	r20, r10
    1636:	50 e0       	ldi	r21, 0x00	; 0
    1638:	4d 8b       	std	Y+21, r20	; 0x15
    163a:	5e 8b       	std	Y+22, r21	; 0x16
    163c:	ef 89       	ldd	r30, Y+23	; 0x17
    163e:	f8 8d       	ldd	r31, Y+24	; 0x18
    1640:	e2 0d       	add	r30, r2
    1642:	f3 1d       	adc	r31, r3
    1644:	44 91       	lpm	r20, Z
    1646:	8d 82       	std	Y+5, r8	; 0x05
    1648:	9e 82       	std	Y+6, r9	; 0x06
    164a:	d1 2c       	mov	r13, r1
    164c:	c1 2c       	mov	r12, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1161
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
    164e:	69 81       	ldd	r22, Y+1	; 0x01
    1650:	7a 81       	ldd	r23, Y+2	; 0x02
    1652:	62 0d       	add	r22, r2
    1654:	73 1d       	adc	r23, r3
    1656:	69 8b       	std	Y+17, r22	; 0x11
    1658:	7a 8b       	std	Y+18, r23	; 0x12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1153

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
    165a:	84 2f       	mov	r24, r20
    165c:	90 e0       	ldi	r25, 0x00	; 0
    165e:	8b 8b       	std	Y+19, r24	; 0x13
    1660:	9c 8b       	std	Y+20, r25	; 0x14
    1662:	e9 8d       	ldd	r30, Y+25	; 0x19
    1664:	fa 8d       	ldd	r31, Y+26	; 0x1a
    1666:	a0 81       	ld	r26, Z
    1668:	b1 81       	ldd	r27, Z+1	; 0x01
    166a:	40 ff       	sbrs	r20, 0
    166c:	7f c0       	rjmp	.+254    	; 0x176c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x22e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1154
          if (size_x == 1 && size_y == 1)
    166e:	f1 e0       	ldi	r31, 0x01	; 1
    1670:	bf 12       	cpse	r11, r31
    1672:	6c c0       	rjmp	.+216    	; 0x174c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x20e>
    1674:	af 12       	cpse	r10, r31
    1676:	6a c0       	rjmp	.+212    	; 0x174c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x20e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1155
            writePixel(x + i, y + j, color);
    1678:	1c 96       	adiw	r26, 0x0c	; 12
    167a:	ed 91       	ld	r30, X+
    167c:	fc 91       	ld	r31, X
    167e:	2f 81       	ldd	r18, Y+7	; 0x07
    1680:	38 85       	ldd	r19, Y+8	; 0x08
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1161
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
    1682:	a4 01       	movw	r20, r8
    1684:	4c 0d       	add	r20, r12
    1686:	5d 1d       	adc	r21, r13
    1688:	69 89       	ldd	r22, Y+17	; 0x11
    168a:	7a 89       	ldd	r23, Y+18	; 0x12
    168c:	89 8d       	ldd	r24, Y+25	; 0x19
    168e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1690:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1152
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
      uint8_t line = pgm_read_byte(&font[c * 5 + i]);
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
    1692:	eb 89       	ldd	r30, Y+19	; 0x13
    1694:	fc 89       	ldd	r31, Y+20	; 0x14
    1696:	f5 95       	asr	r31
    1698:	e7 95       	ror	r30
    169a:	4e 2f       	mov	r20, r30
    169c:	5f ef       	ldi	r21, 0xFF	; 255
    169e:	c5 1a       	sub	r12, r21
    16a0:	d5 0a       	sbc	r13, r21
    16a2:	6d 81       	ldd	r22, Y+5	; 0x05
    16a4:	7e 81       	ldd	r23, Y+6	; 0x06
    16a6:	8d 89       	ldd	r24, Y+21	; 0x15
    16a8:	9e 89       	ldd	r25, Y+22	; 0x16
    16aa:	68 0f       	add	r22, r24
    16ac:	79 1f       	adc	r23, r25
    16ae:	6d 83       	std	Y+5, r22	; 0x05
    16b0:	7e 83       	std	Y+6, r23	; 0x06
    16b2:	98 e0       	ldi	r25, 0x08	; 8
    16b4:	c9 16       	cp	r12, r25
    16b6:	d1 04       	cpc	r13, r1
    16b8:	81 f6       	brne	.-96     	; 0x165a <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x11c>
    16ba:	af ef       	ldi	r26, 0xFF	; 255
    16bc:	2a 1a       	sub	r2, r26
    16be:	3a 0a       	sbc	r3, r26
    16c0:	eb 81       	ldd	r30, Y+3	; 0x03
    16c2:	fc 81       	ldd	r31, Y+4	; 0x04
    16c4:	e4 0d       	add	r30, r4
    16c6:	f5 1d       	adc	r31, r5
    16c8:	eb 83       	std	Y+3, r30	; 0x03
    16ca:	fc 83       	std	Y+4, r31	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1150

    if (!_cp437 && (c >= 176))
      c++; // Handle 'classic' charset behavior

    startWrite();
    for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
    16cc:	f5 e0       	ldi	r31, 0x05	; 5
    16ce:	2f 16       	cp	r2, r31
    16d0:	31 04       	cpc	r3, r1
    16d2:	09 f0       	breq	.+2      	; 0x16d6 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x198>
    16d4:	b3 cf       	rjmp	.-154    	; 0x163c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0xfe>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1167
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
        }
      }
    }
    if (bg != color) { // If opaque, draw vertical line for last column
    16d6:	2f 81       	ldd	r18, Y+7	; 0x07
    16d8:	38 85       	ldd	r19, Y+8	; 0x08
    16da:	26 15       	cp	r18, r6
    16dc:	37 05       	cpc	r19, r7
    16de:	b9 f0       	breq	.+46     	; 0x170e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x1d0>
    16e0:	a9 8d       	ldd	r26, Y+25	; 0x19
    16e2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    16e4:	ed 91       	ld	r30, X+
    16e6:	fc 91       	ld	r31, X
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1168
      if (size_x == 1 && size_y == 1)
    16e8:	b1 e0       	ldi	r27, 0x01	; 1
    16ea:	bb 12       	cpse	r11, r27
    16ec:	54 c0       	rjmp	.+168    	; 0x1796 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x258>
    16ee:	ab 12       	cpse	r10, r27
    16f0:	52 c0       	rjmp	.+164    	; 0x1796 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x258>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1169
        writeFastVLine(x + 5, y, 8, bg);
    16f2:	69 81       	ldd	r22, Y+1	; 0x01
    16f4:	7a 81       	ldd	r23, Y+2	; 0x02
    16f6:	6b 5f       	subi	r22, 0xFB	; 251
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	00 88       	ldd	r0, Z+16	; 0x10
    16fc:	f1 89       	ldd	r31, Z+17	; 0x11
    16fe:	e0 2d       	mov	r30, r0
    1700:	83 01       	movw	r16, r6
    1702:	28 e0       	ldi	r18, 0x08	; 8
    1704:	30 e0       	ldi	r19, 0x00	; 0
    1706:	a4 01       	movw	r20, r8
    1708:	89 8d       	ldd	r24, Y+25	; 0x19
    170a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    170c:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1232
          }
        }
        bits <<= 1;
      }
    }
    endWrite();
    170e:	a9 8d       	ldd	r26, Y+25	; 0x19
    1710:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1712:	ed 91       	ld	r30, X+
    1714:	fc 91       	ld	r31, X
    1716:	11 97       	sbiw	r26, 0x01	; 1
    1718:	06 88       	ldd	r0, Z+22	; 0x16
    171a:	f7 89       	ldd	r31, Z+23	; 0x17
    171c:	e0 2d       	mov	r30, r0
    171e:	cd 01       	movw	r24, r26
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1235

  } // End classic vs custom font
}
    1720:	6a 96       	adiw	r28, 0x1a	; 26
    1722:	cd bf       	out	0x3d, r28	; 61
    1724:	de bf       	out	0x3e, r29	; 62
    1726:	df 91       	pop	r29
    1728:	cf 91       	pop	r28
    172a:	1f 91       	pop	r17
    172c:	0f 91       	pop	r16
    172e:	ff 90       	pop	r15
    1730:	ef 90       	pop	r14
    1732:	df 90       	pop	r13
    1734:	cf 90       	pop	r12
    1736:	bf 90       	pop	r11
    1738:	af 90       	pop	r10
    173a:	9f 90       	pop	r9
    173c:	8f 90       	pop	r8
    173e:	7f 90       	pop	r7
    1740:	6f 90       	pop	r6
    1742:	5f 90       	pop	r5
    1744:	4f 90       	pop	r4
    1746:	3f 90       	pop	r3
    1748:	2f 90       	pop	r2
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1232
          }
        }
        bits <<= 1;
      }
    }
    endWrite();
    174a:	09 94       	ijmp
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1157
      for (int8_t j = 0; j < 8; j++, line >>= 1) {
        if (line & 1) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
    174c:	1e 96       	adiw	r26, 0x0e	; 14
    174e:	ed 91       	ld	r30, X+
    1750:	fc 91       	ld	r31, X
    1752:	ef 80       	ldd	r14, Y+7	; 0x07
    1754:	f8 84       	ldd	r15, Y+8	; 0x08
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1163
                          color);
        } else if (bg != color) {
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, bg);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
    1756:	09 85       	ldd	r16, Y+9	; 0x09
    1758:	1a 85       	ldd	r17, Y+10	; 0x0a
    175a:	92 01       	movw	r18, r4
    175c:	4d 81       	ldd	r20, Y+5	; 0x05
    175e:	5e 81       	ldd	r21, Y+6	; 0x06
    1760:	6b 81       	ldd	r22, Y+3	; 0x03
    1762:	7c 81       	ldd	r23, Y+4	; 0x04
    1764:	89 8d       	ldd	r24, Y+25	; 0x19
    1766:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1768:	09 95       	icall
    176a:	93 cf       	rjmp	.-218    	; 0x1692 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x154>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1159
          if (size_x == 1 && size_y == 1)
            writePixel(x + i, y + j, color);
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y,
                          color);
        } else if (bg != color) {
    176c:	2f 81       	ldd	r18, Y+7	; 0x07
    176e:	38 85       	ldd	r19, Y+8	; 0x08
    1770:	26 15       	cp	r18, r6
    1772:	37 05       	cpc	r19, r7
    1774:	09 f4       	brne	.+2      	; 0x1778 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x23a>
    1776:	8d cf       	rjmp	.-230    	; 0x1692 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x154>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1160
          if (size_x == 1 && size_y == 1)
    1778:	31 e0       	ldi	r19, 0x01	; 1
    177a:	b3 12       	cpse	r11, r19
    177c:	07 c0       	rjmp	.+14     	; 0x178c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x24e>
    177e:	a3 12       	cpse	r10, r19
    1780:	05 c0       	rjmp	.+10     	; 0x178c <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x24e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1161
            writePixel(x + i, y + j, bg);
    1782:	1c 96       	adiw	r26, 0x0c	; 12
    1784:	ed 91       	ld	r30, X+
    1786:	fc 91       	ld	r31, X
    1788:	93 01       	movw	r18, r6
    178a:	7b cf       	rjmp	.-266    	; 0x1682 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x144>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1163
          else
            writeFillRect(x + i * size_x, y + j * size_y, size_x, size_y, bg);
    178c:	1e 96       	adiw	r26, 0x0e	; 14
    178e:	ed 91       	ld	r30, X+
    1790:	fc 91       	ld	r31, X
    1792:	73 01       	movw	r14, r6
    1794:	e0 cf       	rjmp	.-64     	; 0x1756 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x218>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1171
    }
    if (bg != color) { // If opaque, draw vertical line for last column
      if (size_x == 1 && size_y == 1)
        writeFastVLine(x + 5, y, 8, bg);
      else
        writeFillRect(x + 5 * size_x, y, size_x, 8 * size_y, bg);
    1796:	6b 85       	ldd	r22, Y+11	; 0x0b
    1798:	7c 85       	ldd	r23, Y+12	; 0x0c
    179a:	64 19       	sub	r22, r4
    179c:	75 09       	sbc	r23, r5
    179e:	06 84       	ldd	r0, Z+14	; 0x0e
    17a0:	f7 85       	ldd	r31, Z+15	; 0x0f
    17a2:	e0 2d       	mov	r30, r0
    17a4:	73 01       	movw	r14, r6
    17a6:	0f 85       	ldd	r16, Y+15	; 0x0f
    17a8:	18 89       	ldd	r17, Y+16	; 0x10
    17aa:	92 01       	movw	r18, r4
    17ac:	a4 01       	movw	r20, r8
    17ae:	89 8d       	ldd	r24, Y+25	; 0x19
    17b0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    17b2:	09 95       	icall
    17b4:	ac cf       	rjmp	.-168    	; 0x170e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x1d0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1181

    // Character is assumed previously filtered by write() to eliminate
    // newlines, returns, non-printable characters, etc.  Calling
    // drawChar() directly with 'bad' characters of font may cause mayhem!

    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    17b6:	f9 01       	movw	r30, r18
    17b8:	34 96       	adiw	r30, 0x04	; 4
    17ba:	94 91       	lpm	r25, Z
pgm_read_glyph_ptr():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:67
#define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))
#endif

inline GFXglyph *pgm_read_glyph_ptr(const GFXfont *gfxFont, uint8_t c) {
#ifdef __AVR__
  return &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    17bc:	32 97       	sbiw	r30, 0x02	; 2
    17be:	45 91       	lpm	r20, Z+
    17c0:	54 91       	lpm	r21, Z
drawChar():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1181

    // Character is assumed previously filtered by write() to eliminate
    // newlines, returns, non-printable characters, etc.  Calling
    // drawChar() directly with 'bad' characters of font may cause mayhem!

    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    17c2:	d9 1a       	sub	r13, r25
pgm_read_glyph_ptr():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:67
#define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))
#endif

inline GFXglyph *pgm_read_glyph_ptr(const GFXfont *gfxFont, uint8_t c) {
#ifdef __AVR__
  return &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    17c4:	b7 e0       	ldi	r27, 0x07	; 7
    17c6:	db 9e       	mul	r13, r27
    17c8:	40 0d       	add	r20, r0
    17ca:	51 1d       	adc	r21, r1
    17cc:	11 24       	eor	r1, r1
_Z19pgm_read_bitmap_ptrPK7GFXfont():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:79
#endif //__AVR__
}

inline uint8_t *pgm_read_bitmap_ptr(const GFXfont *gfxFont) {
#ifdef __AVR__
  return (uint8_t *)pgm_read_pointer(&gfxFont->bitmap);
    17ce:	f9 01       	movw	r30, r18
    17d0:	25 91       	lpm	r18, Z+
    17d2:	34 91       	lpm	r19, Z
    17d4:	2b 8b       	std	Y+19, r18	; 0x13
    17d6:	3c 8b       	std	Y+20, r19	; 0x14
drawChar():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1185

    c -= (uint8_t)pgm_read_byte(&gfxFont->first);
    GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c);
    uint8_t *bitmap = pgm_read_bitmap_ptr(gfxFont);

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    17d8:	fa 01       	movw	r30, r20
    17da:	25 90       	lpm	r2, Z+
    17dc:	34 90       	lpm	r3, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1186
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
    17de:	fa 01       	movw	r30, r20
    17e0:	32 96       	adiw	r30, 0x02	; 2
    17e2:	74 90       	lpm	r7, Z
    17e4:	31 96       	adiw	r30, 0x01	; 1
    17e6:	34 91       	lpm	r19, Z
    17e8:	39 8b       	std	Y+17, r19	; 0x11
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1187
    int8_t xo = pgm_read_byte(&glyph->xOffset),
    17ea:	32 96       	adiw	r30, 0x02	; 2
    17ec:	64 90       	lpm	r6, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1188
           yo = pgm_read_byte(&glyph->yOffset);
    17ee:	31 96       	adiw	r30, 0x01	; 1
    17f0:	44 90       	lpm	r4, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1192
    uint8_t xx, yy, bits = 0, bit = 0;
    int16_t xo16 = 0, yo16 = 0;

    if (size_x > 1 || size_y > 1) {
    17f2:	41 e0       	ldi	r20, 0x01	; 1
    17f4:	4c 15       	cp	r20, r12
    17f6:	18 f0       	brcs	.+6      	; 0x17fe <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x2c0>
    17f8:	4a 15       	cp	r20, r10
    17fa:	08 f0       	brcs	.+2      	; 0x17fe <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x2c0>
    17fc:	7f c0       	rjmp	.+254    	; 0x18fc <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x3be>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1193
      xo16 = xo;
    17fe:	66 2d       	mov	r22, r6
    1800:	06 2c       	mov	r0, r6
    1802:	00 0c       	add	r0, r0
    1804:	77 0b       	sbc	r23, r23
    1806:	6b 83       	std	Y+3, r22	; 0x03
    1808:	7c 83       	std	Y+4, r23	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1194
      yo16 = yo;
    180a:	84 2d       	mov	r24, r4
    180c:	04 2c       	mov	r0, r4
    180e:	00 0c       	add	r0, r0
    1810:	99 0b       	sbc	r25, r25
    1812:	8d 83       	std	Y+5, r24	; 0x05
    1814:	9e 83       	std	Y+6, r25	; 0x06
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1215
    // only creates a new set of problems.  Have an idea to work around
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    1816:	a9 8d       	ldd	r26, Y+25	; 0x19
    1818:	ba 8d       	ldd	r27, Y+26	; 0x1a
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	11 97       	sbiw	r26, 0x01	; 1
    1820:	02 84       	ldd	r0, Z+10	; 0x0a
    1822:	f3 85       	ldd	r31, Z+11	; 0x0b
    1824:	e0 2d       	mov	r30, r0
    1826:	cd 01       	movw	r24, r26
    1828:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1189

    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
    182a:	51 2c       	mov	r5, r1
    182c:	d1 2c       	mov	r13, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1216
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
    182e:	c1 2c       	mov	r12, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1225
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
    1830:	ea 2d       	mov	r30, r10
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	e9 87       	std	Y+9, r30	; 0x09
    1836:	fa 87       	std	Y+10, r31	; 0x0a
    1838:	2b 2d       	mov	r18, r11
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	2b 87       	std	Y+11, r18	; 0x0b
    183e:	3c 87       	std	Y+12, r19	; 0x0c
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1223
        if (!(bit++ & 7)) {
          bits = pgm_read_byte(&bitmap[bo++]);
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
    1840:	a4 01       	movw	r20, r8
    1842:	44 0d       	add	r20, r4
    1844:	51 1d       	adc	r21, r1
    1846:	47 fc       	sbrc	r4, 7
    1848:	5a 95       	dec	r21
    184a:	4f 8b       	std	Y+23, r20	; 0x17
    184c:	58 8f       	std	Y+24, r21	; 0x18
    184e:	69 81       	ldd	r22, Y+1	; 0x01
    1850:	7a 81       	ldd	r23, Y+2	; 0x02
    1852:	66 0d       	add	r22, r6
    1854:	71 1d       	adc	r23, r1
    1856:	67 fc       	sbrc	r6, 7
    1858:	7a 95       	dec	r23
    185a:	6d 87       	std	Y+13, r22	; 0x0d
    185c:	7e 87       	std	Y+14, r23	; 0x0e
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1216
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
    185e:	79 89       	ldd	r23, Y+17	; 0x11
    1860:	c7 16       	cp	r12, r23
    1862:	08 f0       	brcs	.+2      	; 0x1866 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x328>
    1864:	54 cf       	rjmp	.-344    	; 0x170e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x1d0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1225
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
    1866:	2c 2d       	mov	r18, r12
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	4d 81       	ldd	r20, Y+5	; 0x05
    186c:	5e 81       	ldd	r21, Y+6	; 0x06
    186e:	42 0f       	add	r20, r18
    1870:	53 1f       	adc	r21, r19
    1872:	a9 85       	ldd	r26, Y+9	; 0x09
    1874:	ba 85       	ldd	r27, Y+10	; 0x0a
    1876:	4a 9f       	mul	r20, r26
    1878:	c0 01       	movw	r24, r0
    187a:	4b 9f       	mul	r20, r27
    187c:	90 0d       	add	r25, r0
    187e:	5a 9f       	mul	r21, r26
    1880:	90 0d       	add	r25, r0
    1882:	11 24       	eor	r1, r1
    1884:	fc 01       	movw	r30, r24
    1886:	e8 0d       	add	r30, r8
    1888:	f9 1d       	adc	r31, r9
    188a:	ef 87       	std	Y+15, r30	; 0x0f
    188c:	f8 8b       	std	Y+16, r31	; 0x10
    188e:	85 2d       	mov	r24, r5
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1217
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
    1890:	61 2c       	mov	r6, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1223
        if (!(bit++ & 7)) {
          bits = pgm_read_byte(&bitmap[bo++]);
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
    1892:	4f 89       	ldd	r20, Y+23	; 0x17
    1894:	58 8d       	ldd	r21, Y+24	; 0x18
    1896:	42 0f       	add	r20, r18
    1898:	53 1f       	adc	r21, r19
    189a:	4d 8b       	std	Y+21, r20	; 0x15
    189c:	5e 8b       	std	Y+22, r21	; 0x16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1217
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
    189e:	67 14       	cp	r6, r7
    18a0:	08 f0       	brcs	.+2      	; 0x18a4 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x366>
    18a2:	50 c0       	rjmp	.+160    	; 0x1944 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x406>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1218
        if (!(bit++ & 7)) {
    18a4:	44 24       	eor	r4, r4
    18a6:	43 94       	inc	r4
    18a8:	48 0e       	add	r4, r24
    18aa:	87 70       	andi	r24, 0x07	; 7
    18ac:	41 f4       	brne	.+16     	; 0x18be <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x380>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1219
          bits = pgm_read_byte(&bitmap[bo++]);
    18ae:	c1 01       	movw	r24, r2
    18b0:	01 96       	adiw	r24, 0x01	; 1
    18b2:	eb 89       	ldd	r30, Y+19	; 0x13
    18b4:	fc 89       	ldd	r31, Y+20	; 0x14
    18b6:	e2 0d       	add	r30, r2
    18b8:	f3 1d       	adc	r31, r3
    18ba:	d4 90       	lpm	r13, Z
    18bc:	1c 01       	movw	r2, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1221
        }
        if (bits & 0x80) {
    18be:	d7 fe       	sbrs	r13, 7
    18c0:	19 c0       	rjmp	.+50     	; 0x18f4 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x3b6>
    18c2:	a9 8d       	ldd	r26, Y+25	; 0x19
    18c4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    18c6:	ed 91       	ld	r30, X+
    18c8:	fc 91       	ld	r31, X
    18ca:	66 2d       	mov	r22, r6
    18cc:	70 e0       	ldi	r23, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1222
          if (size_x == 1 && size_y == 1) {
    18ce:	b1 e0       	ldi	r27, 0x01	; 1
    18d0:	bb 12       	cpse	r11, r27
    18d2:	19 c0       	rjmp	.+50     	; 0x1906 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x3c8>
    18d4:	ab 12       	cpse	r10, r27
    18d6:	17 c0       	rjmp	.+46     	; 0x1906 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x3c8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1223
            writePixel(x + xo + xx, y + yo + yy, color);
    18d8:	2d 85       	ldd	r18, Y+13	; 0x0d
    18da:	3e 85       	ldd	r19, Y+14	; 0x0e
    18dc:	62 0f       	add	r22, r18
    18de:	73 1f       	adc	r23, r19
    18e0:	04 84       	ldd	r0, Z+12	; 0x0c
    18e2:	f5 85       	ldd	r31, Z+13	; 0x0d
    18e4:	e0 2d       	mov	r30, r0
    18e6:	2f 81       	ldd	r18, Y+7	; 0x07
    18e8:	38 85       	ldd	r19, Y+8	; 0x08
    18ea:	4d 89       	ldd	r20, Y+21	; 0x15
    18ec:	5e 89       	ldd	r21, Y+22	; 0x16
    18ee:	89 8d       	ldd	r24, Y+25	; 0x19
    18f0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18f2:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1229
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
                          size_x, size_y, color);
          }
        }
        bits <<= 1;
    18f4:	dd 0c       	add	r13, r13
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1217
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
    18f6:	63 94       	inc	r6
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1218
        if (!(bit++ & 7)) {
    18f8:	84 2d       	mov	r24, r4
    18fa:	d1 cf       	rjmp	.-94     	; 0x189e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x360>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1190
    uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
    uint8_t w = pgm_read_byte(&glyph->width), h = pgm_read_byte(&glyph->height);
    int8_t xo = pgm_read_byte(&glyph->xOffset),
           yo = pgm_read_byte(&glyph->yOffset);
    uint8_t xx, yy, bits = 0, bit = 0;
    int16_t xo16 = 0, yo16 = 0;
    18fc:	1d 82       	std	Y+5, r1	; 0x05
    18fe:	1e 82       	std	Y+6, r1	; 0x06
    1900:	1b 82       	std	Y+3, r1	; 0x03
    1902:	1c 82       	std	Y+4, r1	; 0x04
    1904:	88 cf       	rjmp	.-240    	; 0x1816 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x2d8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1225
        }
        if (bits & 0x80) {
          if (size_x == 1 && size_y == 1) {
            writePixel(x + xo + xx, y + yo + yy, color);
          } else {
            writeFillRect(x + (xo16 + xx) * size_x, y + (yo16 + yy) * size_y,
    1906:	4b 81       	ldd	r20, Y+3	; 0x03
    1908:	5c 81       	ldd	r21, Y+4	; 0x04
    190a:	64 0f       	add	r22, r20
    190c:	75 1f       	adc	r23, r21
    190e:	ab 85       	ldd	r26, Y+11	; 0x0b
    1910:	bc 85       	ldd	r27, Y+12	; 0x0c
    1912:	6a 9f       	mul	r22, r26
    1914:	c0 01       	movw	r24, r0
    1916:	6b 9f       	mul	r22, r27
    1918:	90 0d       	add	r25, r0
    191a:	7a 9f       	mul	r23, r26
    191c:	90 0d       	add	r25, r0
    191e:	11 24       	eor	r1, r1
    1920:	69 81       	ldd	r22, Y+1	; 0x01
    1922:	7a 81       	ldd	r23, Y+2	; 0x02
    1924:	68 0f       	add	r22, r24
    1926:	79 1f       	adc	r23, r25
    1928:	06 84       	ldd	r0, Z+14	; 0x0e
    192a:	f7 85       	ldd	r31, Z+15	; 0x0f
    192c:	e0 2d       	mov	r30, r0
    192e:	ef 80       	ldd	r14, Y+7	; 0x07
    1930:	f8 84       	ldd	r15, Y+8	; 0x08
    1932:	09 85       	ldd	r16, Y+9	; 0x09
    1934:	1a 85       	ldd	r17, Y+10	; 0x0a
    1936:	9d 01       	movw	r18, r26
    1938:	4f 85       	ldd	r20, Y+15	; 0x0f
    193a:	58 89       	ldd	r21, Y+16	; 0x10
    193c:	89 8d       	ldd	r24, Y+25	; 0x19
    193e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1940:	09 95       	icall
    1942:	d8 cf       	rjmp	.-80     	; 0x18f4 <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x3b6>
    1944:	57 0c       	add	r5, r7
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1216
    // this (a canvas object type for MCUs that can afford the RAM and
    // displays supporting setAddrWindow() and pushColors()), but haven't
    // implemented this yet.

    startWrite();
    for (yy = 0; yy < h; yy++) {
    1946:	c3 94       	inc	r12
    1948:	8a cf       	rjmp	.-236    	; 0x185e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)+0x320>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1235
      }
    }
    endWrite();

  } // End classic vs custom font
}
    194a:	6a 96       	adiw	r28, 0x1a	; 26
    194c:	cd bf       	out	0x3d, r28	; 61
    194e:	de bf       	out	0x3e, r29	; 62
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	df 90       	pop	r13
    195e:	cf 90       	pop	r12
    1960:	bf 90       	pop	r11
    1962:	af 90       	pop	r10
    1964:	9f 90       	pop	r9
    1966:	8f 90       	pop	r8
    1968:	7f 90       	pop	r7
    196a:	6f 90       	pop	r6
    196c:	5f 90       	pop	r5
    196e:	4f 90       	pop	r4
    1970:	3f 90       	pop	r3
    1972:	2f 90       	pop	r2
    1974:	08 95       	ret

00001976 <Adafruit_GFX::write(unsigned char)>:
write():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1242
/*!
    @brief  Print one byte/character of data, used to support print()
    @param  c  The 8-bit ascii character to write
*/
/**************************************************************************/
size_t Adafruit_GFX::write(uint8_t c) {
    1976:	8f 92       	push	r8
    1978:	9f 92       	push	r9
    197a:	af 92       	push	r10
    197c:	cf 92       	push	r12
    197e:	ef 92       	push	r14
    1980:	ff 92       	push	r15
    1982:	0f 93       	push	r16
    1984:	1f 93       	push	r17
    1986:	cf 93       	push	r28
    1988:	df 93       	push	r29
    198a:	ec 01       	movw	r28, r24
    198c:	26 2f       	mov	r18, r22
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1243
  if (!gfxFont) { // 'Classic' built-in font
    198e:	89 8d       	ldd	r24, Y+25	; 0x19
    1990:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1992:	00 97       	sbiw	r24, 0x00	; 0
    1994:	09 f0       	breq	.+2      	; 0x1998 <Adafruit_GFX::write(unsigned char)+0x22>
    1996:	50 c0       	rjmp	.+160    	; 0x1a38 <Adafruit_GFX::write(unsigned char)+0xc2>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1245

    if (c == '\n') {              // Newline?
    1998:	6a 30       	cpi	r22, 0x0A	; 10
    199a:	d1 f4       	brne	.+52     	; 0x19d0 <Adafruit_GFX::write(unsigned char)+0x5a>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1246
      cursor_x = 0;               // Reset x to zero,
    199c:	1c 86       	std	Y+12, r1	; 0x0c
    199e:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1247
      cursor_y += textsize_y * 8; // advance y one line
    19a0:	8d 89       	ldd	r24, Y+21	; 0x15
    19a2:	48 e0       	ldi	r20, 0x08	; 8
    19a4:	84 9f       	mul	r24, r20
    19a6:	90 01       	movw	r18, r0
    19a8:	11 24       	eor	r1, r1
    19aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    19ac:	9f 85       	ldd	r25, Y+15	; 0x0f
    19ae:	82 0f       	add	r24, r18
    19b0:	93 1f       	adc	r25, r19
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1262

  } else { // Custom font

    if (c == '\n') {
      cursor_x = 0;
      cursor_y +=
    19b2:	8e 87       	std	Y+14, r24	; 0x0e
    19b4:	9f 87       	std	Y+15, r25	; 0x0f
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1286
            (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
      }
    }
  }
  return 1;
}
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	90 e0       	ldi	r25, 0x00	; 0
    19ba:	df 91       	pop	r29
    19bc:	cf 91       	pop	r28
    19be:	1f 91       	pop	r17
    19c0:	0f 91       	pop	r16
    19c2:	ff 90       	pop	r15
    19c4:	ef 90       	pop	r14
    19c6:	cf 90       	pop	r12
    19c8:	af 90       	pop	r10
    19ca:	9f 90       	pop	r9
    19cc:	8f 90       	pop	r8
    19ce:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1248
  if (!gfxFont) { // 'Classic' built-in font

    if (c == '\n') {              // Newline?
      cursor_x = 0;               // Reset x to zero,
      cursor_y += textsize_y * 8; // advance y one line
    } else if (c != '\r') {       // Ignore carriage returns
    19d0:	6d 30       	cpi	r22, 0x0D	; 13
    19d2:	89 f3       	breq	.-30     	; 0x19b6 <Adafruit_GFX::write(unsigned char)+0x40>
    19d4:	cc 88       	ldd	r12, Y+20	; 0x14
    19d6:	ad 88       	ldd	r10, Y+21	; 0x15
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1249
      if (wrap && ((cursor_x + textsize_x * 6) > _width)) { // Off right?
    19d8:	8f 89       	ldd	r24, Y+23	; 0x17
    19da:	88 23       	and	r24, r24
    19dc:	c1 f0       	breq	.+48     	; 0x1a0e <Adafruit_GFX::write(unsigned char)+0x98>
    19de:	8c 85       	ldd	r24, Y+12	; 0x0c
    19e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    19e2:	36 e0       	ldi	r19, 0x06	; 6
    19e4:	c3 9e       	mul	r12, r19
    19e6:	80 0d       	add	r24, r0
    19e8:	91 1d       	adc	r25, r1
    19ea:	11 24       	eor	r1, r1
    19ec:	48 85       	ldd	r20, Y+8	; 0x08
    19ee:	59 85       	ldd	r21, Y+9	; 0x09
    19f0:	48 17       	cp	r20, r24
    19f2:	59 07       	cpc	r21, r25
    19f4:	64 f4       	brge	.+24     	; 0x1a0e <Adafruit_GFX::write(unsigned char)+0x98>
    19f6:	4e 85       	ldd	r20, Y+14	; 0x0e
    19f8:	5f 85       	ldd	r21, Y+15	; 0x0f
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1250
        cursor_x = 0;                                       // Reset x to zero,
    19fa:	1c 86       	std	Y+12, r1	; 0x0c
    19fc:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1251
        cursor_y += textsize_y * 8; // advance y one line
    19fe:	38 e0       	ldi	r19, 0x08	; 8
    1a00:	a3 9e       	mul	r10, r19
    1a02:	c0 01       	movw	r24, r0
    1a04:	11 24       	eor	r1, r1
    1a06:	84 0f       	add	r24, r20
    1a08:	95 1f       	adc	r25, r21
    1a0a:	8e 87       	std	Y+14, r24	; 0x0e
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1253
      }
      drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
    1a0c:	9f 87       	std	Y+15, r25	; 0x0f
    1a0e:	ea 88       	ldd	r14, Y+18	; 0x12
    1a10:	fb 88       	ldd	r15, Y+19	; 0x13
    1a12:	08 89       	ldd	r16, Y+16	; 0x10
    1a14:	19 89       	ldd	r17, Y+17	; 0x11
    1a16:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a18:	5f 85       	ldd	r21, Y+15	; 0x0f
    1a1a:	6c 85       	ldd	r22, Y+12	; 0x0c
    1a1c:	7d 85       	ldd	r23, Y+13	; 0x0d
    1a1e:	ce 01       	movw	r24, r28
    1a20:	8e dd       	rcall	.-1252   	; 0x153e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1255
               textsize_y);
      cursor_x += textsize_x * 6; // Advance x one char
    1a22:	2c 89       	ldd	r18, Y+20	; 0x14
    1a24:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a26:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a28:	46 e0       	ldi	r20, 0x06	; 6
    1a2a:	24 9f       	mul	r18, r20
    1a2c:	80 0d       	add	r24, r0
    1a2e:	91 1d       	adc	r25, r1
    1a30:	11 24       	eor	r1, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1280
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
          }
          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
                   textsize_y);
        }
        cursor_x +=
    1a32:	8c 87       	std	Y+12, r24	; 0x0c
    1a34:	9d 87       	std	Y+13, r25	; 0x0d
    1a36:	bf cf       	rjmp	.-130    	; 0x19b6 <Adafruit_GFX::write(unsigned char)+0x40>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1260
      cursor_x += textsize_x * 6; // Advance x one char
    }

  } else { // Custom font

    if (c == '\n') {
    1a38:	6a 30       	cpi	r22, 0x0A	; 10
    1a3a:	69 f4       	brne	.+26     	; 0x1a56 <Adafruit_GFX::write(unsigned char)+0xe0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1261
      cursor_x = 0;
    1a3c:	1c 86       	std	Y+12, r1	; 0x0c
    1a3e:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1263
      cursor_y +=
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    1a40:	fc 01       	movw	r30, r24
    1a42:	38 96       	adiw	r30, 0x08	; 8
    1a44:	e4 91       	lpm	r30, Z
    1a46:	2d 89       	ldd	r18, Y+21	; 0x15
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1262

  } else { // Custom font

    if (c == '\n') {
      cursor_x = 0;
      cursor_y +=
    1a48:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a4a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a4c:	e2 9f       	mul	r30, r18
    1a4e:	80 0d       	add	r24, r0
    1a50:	91 1d       	adc	r25, r1
    1a52:	11 24       	eor	r1, r1
    1a54:	ae cf       	rjmp	.-164    	; 0x19b2 <Adafruit_GFX::write(unsigned char)+0x3c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1264
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    } else if (c != '\r') {
    1a56:	6d 30       	cpi	r22, 0x0D	; 13
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <Adafruit_GFX::write(unsigned char)+0xe6>
    1a5a:	ad cf       	rjmp	.-166    	; 0x19b6 <Adafruit_GFX::write(unsigned char)+0x40>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1265
      uint8_t first = pgm_read_byte(&gfxFont->first);
    1a5c:	fc 01       	movw	r30, r24
    1a5e:	34 96       	adiw	r30, 0x04	; 4
    1a60:	34 91       	lpm	r19, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1266
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
    1a62:	63 17       	cp	r22, r19
    1a64:	08 f4       	brcc	.+2      	; 0x1a68 <Adafruit_GFX::write(unsigned char)+0xf2>
    1a66:	a7 cf       	rjmp	.-178    	; 0x19b6 <Adafruit_GFX::write(unsigned char)+0x40>
    1a68:	32 96       	adiw	r30, 0x02	; 2
    1a6a:	e4 91       	lpm	r30, Z
    1a6c:	e6 17       	cp	r30, r22
    1a6e:	08 f4       	brcc	.+2      	; 0x1a72 <Adafruit_GFX::write(unsigned char)+0xfc>
    1a70:	a2 cf       	rjmp	.-188    	; 0x19b6 <Adafruit_GFX::write(unsigned char)+0x40>
pgm_read_glyph_ptr():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:67
#define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))
#endif

inline GFXglyph *pgm_read_glyph_ptr(const GFXfont *gfxFont, uint8_t c) {
#ifdef __AVR__
  return &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    1a72:	fc 01       	movw	r30, r24
    1a74:	32 96       	adiw	r30, 0x02	; 2
    1a76:	85 90       	lpm	r8, Z+
    1a78:	94 90       	lpm	r9, Z
write():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1267
      cursor_y +=
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    } else if (c != '\r') {
      uint8_t first = pgm_read_byte(&gfxFont->first);
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
    1a7a:	46 2f       	mov	r20, r22
    1a7c:	43 1b       	sub	r20, r19
    1a7e:	34 2f       	mov	r19, r20
pgm_read_glyph_ptr():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:67
#define pgm_read_pointer(addr) ((void *)pgm_read_word(addr))
#endif

inline GFXglyph *pgm_read_glyph_ptr(const GFXfont *gfxFont, uint8_t c) {
#ifdef __AVR__
  return &(((GFXglyph *)pgm_read_pointer(&gfxFont->glyph))[c]);
    1a80:	47 e0       	ldi	r20, 0x07	; 7
    1a82:	34 9f       	mul	r19, r20
    1a84:	80 0c       	add	r8, r0
    1a86:	91 1c       	adc	r9, r1
    1a88:	11 24       	eor	r1, r1
write():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1268
          (int16_t)textsize_y * (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    } else if (c != '\r') {
      uint8_t first = pgm_read_byte(&gfxFont->first);
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
        uint8_t w = pgm_read_byte(&glyph->width),
    1a8a:	f4 01       	movw	r30, r8
    1a8c:	32 96       	adiw	r30, 0x02	; 2
    1a8e:	34 91       	lpm	r19, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1269
                h = pgm_read_byte(&glyph->height);
    1a90:	31 96       	adiw	r30, 0x01	; 1
    1a92:	e4 91       	lpm	r30, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1270
        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?
    1a94:	33 23       	and	r19, r19
    1a96:	a1 f1       	breq	.+104    	; 0x1b00 <Adafruit_GFX::write(unsigned char)+0x18a>
    1a98:	ee 23       	and	r30, r30
    1a9a:	91 f1       	breq	.+100    	; 0x1b00 <Adafruit_GFX::write(unsigned char)+0x18a>
    1a9c:	cc 88       	ldd	r12, Y+20	; 0x14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1271
          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
    1a9e:	f4 01       	movw	r30, r8
    1aa0:	35 96       	adiw	r30, 0x05	; 5
    1aa2:	e4 91       	lpm	r30, Z
    1aa4:	ad 88       	ldd	r10, Y+21	; 0x15
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1272
          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
    1aa6:	4f 89       	ldd	r20, Y+23	; 0x17
    1aa8:	44 23       	and	r20, r20
    1aaa:	01 f1       	breq	.+64     	; 0x1aec <Adafruit_GFX::write(unsigned char)+0x176>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1271
      if ((c >= first) && (c <= (uint8_t)pgm_read_byte(&gfxFont->last))) {
        GFXglyph *glyph = pgm_read_glyph_ptr(gfxFont, c - first);
        uint8_t w = pgm_read_byte(&glyph->width),
                h = pgm_read_byte(&glyph->height);
        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?
          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
    1aac:	0e 2e       	mov	r0, r30
    1aae:	00 0c       	add	r0, r0
    1ab0:	ff 0b       	sbc	r31, r31
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1272
          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
    1ab2:	e3 0f       	add	r30, r19
    1ab4:	f1 1d       	adc	r31, r1
    1ab6:	ce 9e       	mul	r12, r30
    1ab8:	a0 01       	movw	r20, r0
    1aba:	cf 9e       	mul	r12, r31
    1abc:	50 0d       	add	r21, r0
    1abe:	11 24       	eor	r1, r1
    1ac0:	6c 85       	ldd	r22, Y+12	; 0x0c
    1ac2:	7d 85       	ldd	r23, Y+13	; 0x0d
    1ac4:	46 0f       	add	r20, r22
    1ac6:	57 1f       	adc	r21, r23
    1ac8:	68 85       	ldd	r22, Y+8	; 0x08
    1aca:	79 85       	ldd	r23, Y+9	; 0x09
    1acc:	64 17       	cp	r22, r20
    1ace:	75 07       	cpc	r23, r21
    1ad0:	6c f4       	brge	.+26     	; 0x1aec <Adafruit_GFX::write(unsigned char)+0x176>
    1ad2:	4e 85       	ldd	r20, Y+14	; 0x0e
    1ad4:	5f 85       	ldd	r21, Y+15	; 0x0f
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1273
            cursor_x = 0;
    1ad6:	1c 86       	std	Y+12, r1	; 0x0c
    1ad8:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1275
            cursor_y += (int16_t)textsize_y *
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
    1ada:	fc 01       	movw	r30, r24
    1adc:	38 96       	adiw	r30, 0x08	; 8
    1ade:	e4 91       	lpm	r30, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1274
                h = pgm_read_byte(&glyph->height);
        if ((w > 0) && (h > 0)) { // Is there an associated bitmap?
          int16_t xo = (int8_t)pgm_read_byte(&glyph->xOffset); // sic
          if (wrap && ((cursor_x + textsize_x * (xo + w)) > _width)) {
            cursor_x = 0;
            cursor_y += (int16_t)textsize_y *
    1ae0:	ae 9e       	mul	r10, r30
    1ae2:	40 0d       	add	r20, r0
    1ae4:	51 1d       	adc	r21, r1
    1ae6:	11 24       	eor	r1, r1
    1ae8:	4e 87       	std	Y+14, r20	; 0x0e
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1277
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
          }
          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
    1aea:	5f 87       	std	Y+15, r21	; 0x0f
    1aec:	ea 88       	ldd	r14, Y+18	; 0x12
    1aee:	fb 88       	ldd	r15, Y+19	; 0x13
    1af0:	08 89       	ldd	r16, Y+16	; 0x10
    1af2:	19 89       	ldd	r17, Y+17	; 0x11
    1af4:	4e 85       	ldd	r20, Y+14	; 0x0e
    1af6:	5f 85       	ldd	r21, Y+15	; 0x0f
    1af8:	6c 85       	ldd	r22, Y+12	; 0x0c
    1afa:	7d 85       	ldd	r23, Y+13	; 0x0d
    1afc:	ce 01       	movw	r24, r28
    1afe:	1f dd       	rcall	.-1474   	; 0x153e <Adafruit_GFX::drawChar(int, int, unsigned char, unsigned int, unsigned int, unsigned char, unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1281
                   textsize_y);
        }
        cursor_x +=
            (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)textsize_x;
    1b00:	f4 01       	movw	r30, r8
    1b02:	34 96       	adiw	r30, 0x04	; 4
    1b04:	e4 91       	lpm	r30, Z
    1b06:	2c 89       	ldd	r18, Y+20	; 0x14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:1280
                        (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
          }
          drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize_x,
                   textsize_y);
        }
        cursor_x +=
    1b08:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b0c:	e2 9f       	mul	r30, r18
    1b0e:	80 0d       	add	r24, r0
    1b10:	91 1d       	adc	r25, r1
    1b12:	11 24       	eor	r1, r1
    1b14:	8e cf       	rjmp	.-228    	; 0x1a32 <Adafruit_GFX::write(unsigned char)+0xbc>

00001b16 <Adafruit_GFX::drawRect(int, int, int, int, unsigned int)>:
drawRect():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:524
    @param    h   Height in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
    1b16:	6f 92       	push	r6
    1b18:	7f 92       	push	r7
    1b1a:	8f 92       	push	r8
    1b1c:	9f 92       	push	r9
    1b1e:	af 92       	push	r10
    1b20:	bf 92       	push	r11
    1b22:	cf 92       	push	r12
    1b24:	df 92       	push	r13
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	0f 93       	push	r16
    1b2c:	1f 93       	push	r17
    1b2e:	cf 93       	push	r28
    1b30:	df 93       	push	r29
    1b32:	ec 01       	movw	r28, r24
    1b34:	6b 01       	movw	r12, r22
    1b36:	5a 01       	movw	r10, r20
    1b38:	39 01       	movw	r6, r18
    1b3a:	48 01       	movw	r8, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:525
  startWrite();
    1b3c:	e8 81       	ld	r30, Y
    1b3e:	f9 81       	ldd	r31, Y+1	; 0x01
    1b40:	02 84       	ldd	r0, Z+10	; 0x0a
    1b42:	f3 85       	ldd	r31, Z+11	; 0x0b
    1b44:	e0 2d       	mov	r30, r0
    1b46:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:526
  writeFastHLine(x, y, w, color);
    1b48:	e8 81       	ld	r30, Y
    1b4a:	f9 81       	ldd	r31, Y+1	; 0x01
    1b4c:	02 88       	ldd	r0, Z+18	; 0x12
    1b4e:	f3 89       	ldd	r31, Z+19	; 0x13
    1b50:	e0 2d       	mov	r30, r0
    1b52:	87 01       	movw	r16, r14
    1b54:	93 01       	movw	r18, r6
    1b56:	a5 01       	movw	r20, r10
    1b58:	b6 01       	movw	r22, r12
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:527
  writeFastHLine(x, y + h - 1, w, color);
    1b5e:	a5 01       	movw	r20, r10
    1b60:	48 0d       	add	r20, r8
    1b62:	59 1d       	adc	r21, r9
    1b64:	41 50       	subi	r20, 0x01	; 1
    1b66:	51 09       	sbc	r21, r1
    1b68:	e8 81       	ld	r30, Y
    1b6a:	f9 81       	ldd	r31, Y+1	; 0x01
    1b6c:	02 88       	ldd	r0, Z+18	; 0x12
    1b6e:	f3 89       	ldd	r31, Z+19	; 0x13
    1b70:	e0 2d       	mov	r30, r0
    1b72:	93 01       	movw	r18, r6
    1b74:	b6 01       	movw	r22, r12
    1b76:	ce 01       	movw	r24, r28
    1b78:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:528
  writeFastVLine(x, y, h, color);
    1b7a:	e8 81       	ld	r30, Y
    1b7c:	f9 81       	ldd	r31, Y+1	; 0x01
    1b7e:	00 88       	ldd	r0, Z+16	; 0x10
    1b80:	f1 89       	ldd	r31, Z+17	; 0x11
    1b82:	e0 2d       	mov	r30, r0
    1b84:	94 01       	movw	r18, r8
    1b86:	a5 01       	movw	r20, r10
    1b88:	b6 01       	movw	r22, r12
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:529
  writeFastVLine(x + w - 1, y, h, color);
    1b8e:	c6 0c       	add	r12, r6
    1b90:	d7 1c       	adc	r13, r7
    1b92:	b6 01       	movw	r22, r12
    1b94:	61 50       	subi	r22, 0x01	; 1
    1b96:	71 09       	sbc	r23, r1
    1b98:	e8 81       	ld	r30, Y
    1b9a:	f9 81       	ldd	r31, Y+1	; 0x01
    1b9c:	00 88       	ldd	r0, Z+16	; 0x10
    1b9e:	f1 89       	ldd	r31, Z+17	; 0x11
    1ba0:	e0 2d       	mov	r30, r0
    1ba2:	94 01       	movw	r18, r8
    1ba4:	a5 01       	movw	r20, r10
    1ba6:	ce 01       	movw	r24, r28
    1ba8:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:530
  endWrite();
    1baa:	e8 81       	ld	r30, Y
    1bac:	f9 81       	ldd	r31, Y+1	; 0x01
    1bae:	06 88       	ldd	r0, Z+22	; 0x16
    1bb0:	f7 89       	ldd	r31, Z+23	; 0x17
    1bb2:	e0 2d       	mov	r30, r0
    1bb4:	ce 01       	movw	r24, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:531
}
    1bb6:	df 91       	pop	r29
    1bb8:	cf 91       	pop	r28
    1bba:	1f 91       	pop	r17
    1bbc:	0f 91       	pop	r16
    1bbe:	ff 90       	pop	r15
    1bc0:	ef 90       	pop	r14
    1bc2:	df 90       	pop	r13
    1bc4:	cf 90       	pop	r12
    1bc6:	bf 90       	pop	r11
    1bc8:	af 90       	pop	r10
    1bca:	9f 90       	pop	r9
    1bcc:	8f 90       	pop	r8
    1bce:	7f 90       	pop	r7
    1bd0:	6f 90       	pop	r6
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:530
  startWrite();
  writeFastHLine(x, y, w, color);
  writeFastHLine(x, y + h - 1, w, color);
  writeFastVLine(x, y, h, color);
  writeFastVLine(x + w - 1, y, h, color);
  endWrite();
    1bd2:	09 94       	ijmp

00001bd4 <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)>:
drawLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:331
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                            uint16_t color) {
    1bd4:	6f 92       	push	r6
    1bd6:	7f 92       	push	r7
    1bd8:	8f 92       	push	r8
    1bda:	9f 92       	push	r9
    1bdc:	af 92       	push	r10
    1bde:	bf 92       	push	r11
    1be0:	cf 92       	push	r12
    1be2:	df 92       	push	r13
    1be4:	ef 92       	push	r14
    1be6:	ff 92       	push	r15
    1be8:	0f 93       	push	r16
    1bea:	1f 93       	push	r17
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	5c 01       	movw	r10, r24
    1bf2:	eb 01       	movw	r28, r22
    1bf4:	6a 01       	movw	r12, r20
    1bf6:	49 01       	movw	r8, r18
    1bf8:	38 01       	movw	r6, r16
    1bfa:	87 01       	movw	r16, r14
    1bfc:	dc 01       	movw	r26, r24
    1bfe:	ed 91       	ld	r30, X+
    1c00:	fc 91       	ld	r31, X
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:333
  // Update in subclasses if desired!
  if (x0 == x1) {
    1c02:	62 17       	cp	r22, r18
    1c04:	73 07       	cpc	r23, r19
    1c06:	19 f5       	brne	.+70     	; 0x1c4e <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)+0x7a>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:334
    if (y0 > y1)
    1c08:	64 16       	cp	r6, r20
    1c0a:	75 06       	cpc	r7, r21
    1c0c:	2c f0       	brlt	.+10     	; 0x1c18 <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)+0x44>
    1c0e:	96 2d       	mov	r25, r6
    1c10:	87 2d       	mov	r24, r7
    1c12:	3a 01       	movw	r6, r20
    1c14:	c9 2e       	mov	r12, r25
    1c16:	d8 2e       	mov	r13, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:336
      _swap_int16_t(y0, y1);
    drawFastVLine(x0, y0, y1 - y0 + 1, color);
    1c18:	96 01       	movw	r18, r12
    1c1a:	26 19       	sub	r18, r6
    1c1c:	37 09       	sbc	r19, r7
    1c1e:	2f 5f       	subi	r18, 0xFF	; 255
    1c20:	3f 4f       	sbci	r19, 0xFF	; 255
    1c22:	04 8c       	ldd	r0, Z+28	; 0x1c
    1c24:	f5 8d       	ldd	r31, Z+29	; 0x1d
    1c26:	e0 2d       	mov	r30, r0
    1c28:	a3 01       	movw	r20, r6
    1c2a:	be 01       	movw	r22, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:340
  } else if (y0 == y1) {
    if (x0 > x1)
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
    1c2c:	c5 01       	movw	r24, r10
    1c2e:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:346
  } else {
    startWrite();
    writeLine(x0, y0, x1, y1, color);
    endWrite();
  }
}
    1c30:	df 91       	pop	r29
    1c32:	cf 91       	pop	r28
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	ef 90       	pop	r14
    1c3c:	df 90       	pop	r13
    1c3e:	cf 90       	pop	r12
    1c40:	bf 90       	pop	r11
    1c42:	af 90       	pop	r10
    1c44:	9f 90       	pop	r9
    1c46:	8f 90       	pop	r8
    1c48:	7f 90       	pop	r7
    1c4a:	6f 90       	pop	r6
    1c4c:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:337
  // Update in subclasses if desired!
  if (x0 == x1) {
    if (y0 > y1)
      _swap_int16_t(y0, y1);
    drawFastVLine(x0, y0, y1 - y0 + 1, color);
  } else if (y0 == y1) {
    1c4e:	46 15       	cp	r20, r6
    1c50:	57 05       	cpc	r21, r7
    1c52:	91 f4       	brne	.+36     	; 0x1c78 <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)+0xa4>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:338
    if (x0 > x1)
    1c54:	26 17       	cp	r18, r22
    1c56:	37 07       	cpc	r19, r23
    1c58:	24 f0       	brlt	.+8      	; 0x1c62 <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)+0x8e>
    1c5a:	89 2d       	mov	r24, r9
    1c5c:	4b 01       	movw	r8, r22
    1c5e:	c2 2f       	mov	r28, r18
    1c60:	d8 2f       	mov	r29, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:340
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
    1c62:	9e 01       	movw	r18, r28
    1c64:	28 19       	sub	r18, r8
    1c66:	39 09       	sbc	r19, r9
    1c68:	2f 5f       	subi	r18, 0xFF	; 255
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	06 8c       	ldd	r0, Z+30	; 0x1e
    1c6e:	f7 8d       	ldd	r31, Z+31	; 0x1f
    1c70:	e0 2d       	mov	r30, r0
    1c72:	a6 01       	movw	r20, r12
    1c74:	b4 01       	movw	r22, r8
    1c76:	da cf       	rjmp	.-76     	; 0x1c2c <Adafruit_GFX::drawLine(int, int, int, int, unsigned int)+0x58>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:342
  } else {
    startWrite();
    1c78:	02 84       	ldd	r0, Z+10	; 0x0a
    1c7a:	f3 85       	ldd	r31, Z+11	; 0x0b
    1c7c:	e0 2d       	mov	r30, r0
    1c7e:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:343
    writeLine(x0, y0, x1, y1, color);
    1c80:	d5 01       	movw	r26, r10
    1c82:	ed 91       	ld	r30, X+
    1c84:	fc 91       	ld	r31, X
    1c86:	04 88       	ldd	r0, Z+20	; 0x14
    1c88:	f5 89       	ldd	r31, Z+21	; 0x15
    1c8a:	e0 2d       	mov	r30, r0
    1c8c:	83 01       	movw	r16, r6
    1c8e:	94 01       	movw	r18, r8
    1c90:	a6 01       	movw	r20, r12
    1c92:	be 01       	movw	r22, r28
    1c94:	c5 01       	movw	r24, r10
    1c96:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:344
    endWrite();
    1c98:	d5 01       	movw	r26, r10
    1c9a:	ed 91       	ld	r30, X+
    1c9c:	fc 91       	ld	r31, X
    1c9e:	06 88       	ldd	r0, Z+22	; 0x16
    1ca0:	f7 89       	ldd	r31, Z+23	; 0x17
    1ca2:	e0 2d       	mov	r30, r0
    1ca4:	c5 01       	movw	r24, r10
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:346
  }
}
    1ca6:	df 91       	pop	r29
    1ca8:	cf 91       	pop	r28
    1caa:	1f 91       	pop	r17
    1cac:	0f 91       	pop	r16
    1cae:	ff 90       	pop	r15
    1cb0:	ef 90       	pop	r14
    1cb2:	df 90       	pop	r13
    1cb4:	cf 90       	pop	r12
    1cb6:	bf 90       	pop	r11
    1cb8:	af 90       	pop	r10
    1cba:	9f 90       	pop	r9
    1cbc:	8f 90       	pop	r8
    1cbe:	7f 90       	pop	r7
    1cc0:	6f 90       	pop	r6
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:344
      _swap_int16_t(x0, x1);
    drawFastHLine(x0, y0, x1 - x0 + 1, color);
  } else {
    startWrite();
    writeLine(x0, y0, x1, y1, color);
    endWrite();
    1cc2:	09 94       	ijmp

00001cc4 <Adafruit_GFX::fillScreen(unsigned int)>:
fillScreen():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:316
   @brief    Fill the screen completely with one color. Update in subclasses if
   desired!
    @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillScreen(uint16_t color) {
    1cc4:	ef 92       	push	r14
    1cc6:	ff 92       	push	r15
    1cc8:	0f 93       	push	r16
    1cca:	1f 93       	push	r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:317
  fillRect(0, 0, _width, _height, color);
    1ccc:	dc 01       	movw	r26, r24
    1cce:	1a 96       	adiw	r26, 0x0a	; 10
    1cd0:	0d 91       	ld	r16, X+
    1cd2:	1c 91       	ld	r17, X
    1cd4:	1b 97       	sbiw	r26, 0x0b	; 11
    1cd6:	18 96       	adiw	r26, 0x08	; 8
    1cd8:	2d 91       	ld	r18, X+
    1cda:	3c 91       	ld	r19, X
    1cdc:	19 97       	sbiw	r26, 0x09	; 9
    1cde:	ed 91       	ld	r30, X+
    1ce0:	fc 91       	ld	r31, X
    1ce2:	00 a0       	ldd	r0, Z+32	; 0x20
    1ce4:	f1 a1       	ldd	r31, Z+33	; 0x21
    1ce6:	e0 2d       	mov	r30, r0
    1ce8:	7b 01       	movw	r14, r22
    1cea:	50 e0       	ldi	r21, 0x00	; 0
    1cec:	40 e0       	ldi	r20, 0x00	; 0
    1cee:	70 e0       	ldi	r23, 0x00	; 0
    1cf0:	60 e0       	ldi	r22, 0x00	; 0
    1cf2:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:318
}
    1cf4:	1f 91       	pop	r17
    1cf6:	0f 91       	pop	r16
    1cf8:	ff 90       	pop	r15
    1cfa:	ef 90       	pop	r14
    1cfc:	08 95       	ret

00001cfe <Adafruit_GFX::fillRect(int, int, int, int, unsigned int)>:
fillRect():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:301
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
    1cfe:	4f 92       	push	r4
    1d00:	5f 92       	push	r5
    1d02:	6f 92       	push	r6
    1d04:	7f 92       	push	r7
    1d06:	8f 92       	push	r8
    1d08:	9f 92       	push	r9
    1d0a:	af 92       	push	r10
    1d0c:	bf 92       	push	r11
    1d0e:	cf 92       	push	r12
    1d10:	df 92       	push	r13
    1d12:	ef 92       	push	r14
    1d14:	ff 92       	push	r15
    1d16:	0f 93       	push	r16
    1d18:	1f 93       	push	r17
    1d1a:	cf 93       	push	r28
    1d1c:	df 93       	push	r29
    1d1e:	6c 01       	movw	r12, r24
    1d20:	2b 01       	movw	r4, r22
    1d22:	5a 01       	movw	r10, r20
    1d24:	39 01       	movw	r6, r18
    1d26:	48 01       	movw	r8, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:302
  startWrite();
    1d28:	dc 01       	movw	r26, r24
    1d2a:	ed 91       	ld	r30, X+
    1d2c:	fc 91       	ld	r31, X
    1d2e:	02 84       	ldd	r0, Z+10	; 0x0a
    1d30:	f3 85       	ldd	r31, Z+11	; 0x0b
    1d32:	e0 2d       	mov	r30, r0
    1d34:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:303
  for (int16_t i = x; i < x + w; i++) {
    1d36:	e2 01       	movw	r28, r4
    1d38:	64 0c       	add	r6, r4
    1d3a:	75 1c       	adc	r7, r5
    1d3c:	d6 01       	movw	r26, r12
    1d3e:	ed 91       	ld	r30, X+
    1d40:	fc 91       	ld	r31, X
    1d42:	c6 15       	cp	r28, r6
    1d44:	d7 05       	cpc	r29, r7
    1d46:	5c f4       	brge	.+22     	; 0x1d5e <Adafruit_GFX::fillRect(int, int, int, int, unsigned int)+0x60>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:304
    writeFastVLine(i, y, h, color);
    1d48:	00 88       	ldd	r0, Z+16	; 0x10
    1d4a:	f1 89       	ldd	r31, Z+17	; 0x11
    1d4c:	e0 2d       	mov	r30, r0
    1d4e:	87 01       	movw	r16, r14
    1d50:	94 01       	movw	r18, r8
    1d52:	a5 01       	movw	r20, r10
    1d54:	be 01       	movw	r22, r28
    1d56:	c6 01       	movw	r24, r12
    1d58:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:303
*/
/**************************************************************************/
void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                            uint16_t color) {
  startWrite();
  for (int16_t i = x; i < x + w; i++) {
    1d5a:	21 96       	adiw	r28, 0x01	; 1
    1d5c:	ef cf       	rjmp	.-34     	; 0x1d3c <Adafruit_GFX::fillRect(int, int, int, int, unsigned int)+0x3e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:306
    writeFastVLine(i, y, h, color);
  }
  endWrite();
    1d5e:	06 88       	ldd	r0, Z+22	; 0x16
    1d60:	f7 89       	ldd	r31, Z+23	; 0x17
    1d62:	e0 2d       	mov	r30, r0
    1d64:	c6 01       	movw	r24, r12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:307
}
    1d66:	df 91       	pop	r29
    1d68:	cf 91       	pop	r28
    1d6a:	1f 91       	pop	r17
    1d6c:	0f 91       	pop	r16
    1d6e:	ff 90       	pop	r15
    1d70:	ef 90       	pop	r14
    1d72:	df 90       	pop	r13
    1d74:	cf 90       	pop	r12
    1d76:	bf 90       	pop	r11
    1d78:	af 90       	pop	r10
    1d7a:	9f 90       	pop	r9
    1d7c:	8f 90       	pop	r8
    1d7e:	7f 90       	pop	r7
    1d80:	6f 90       	pop	r6
    1d82:	5f 90       	pop	r5
    1d84:	4f 90       	pop	r4
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:306
                            uint16_t color) {
  startWrite();
  for (int16_t i = x; i < x + w; i++) {
    writeFastVLine(i, y, h, color);
  }
  endWrite();
    1d86:	09 94       	ijmp

00001d88 <Adafruit_GFX::drawFastHLine(int, int, int, unsigned int)>:
drawFastHLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:283
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                 uint16_t color) {
    1d88:	8f 92       	push	r8
    1d8a:	9f 92       	push	r9
    1d8c:	af 92       	push	r10
    1d8e:	bf 92       	push	r11
    1d90:	cf 92       	push	r12
    1d92:	df 92       	push	r13
    1d94:	ef 92       	push	r14
    1d96:	ff 92       	push	r15
    1d98:	0f 93       	push	r16
    1d9a:	1f 93       	push	r17
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	ec 01       	movw	r28, r24
    1da2:	5b 01       	movw	r10, r22
    1da4:	4a 01       	movw	r8, r20
    1da6:	69 01       	movw	r12, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:284
  startWrite();
    1da8:	e8 81       	ld	r30, Y
    1daa:	f9 81       	ldd	r31, Y+1	; 0x01
    1dac:	02 84       	ldd	r0, Z+10	; 0x0a
    1dae:	f3 85       	ldd	r31, Z+11	; 0x0b
    1db0:	e0 2d       	mov	r30, r0
    1db2:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:285
  writeLine(x, y, x + w - 1, y, color);
    1db4:	95 01       	movw	r18, r10
    1db6:	2c 0d       	add	r18, r12
    1db8:	3d 1d       	adc	r19, r13
    1dba:	21 50       	subi	r18, 0x01	; 1
    1dbc:	31 09       	sbc	r19, r1
    1dbe:	e8 81       	ld	r30, Y
    1dc0:	f9 81       	ldd	r31, Y+1	; 0x01
    1dc2:	04 88       	ldd	r0, Z+20	; 0x14
    1dc4:	f5 89       	ldd	r31, Z+21	; 0x15
    1dc6:	e0 2d       	mov	r30, r0
    1dc8:	78 01       	movw	r14, r16
    1dca:	84 01       	movw	r16, r8
    1dcc:	a4 01       	movw	r20, r8
    1dce:	b5 01       	movw	r22, r10
    1dd0:	ce 01       	movw	r24, r28
    1dd2:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:286
  endWrite();
    1dd4:	e8 81       	ld	r30, Y
    1dd6:	f9 81       	ldd	r31, Y+1	; 0x01
    1dd8:	06 88       	ldd	r0, Z+22	; 0x16
    1dda:	f7 89       	ldd	r31, Z+23	; 0x17
    1ddc:	e0 2d       	mov	r30, r0
    1dde:	ce 01       	movw	r24, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:287
}
    1de0:	df 91       	pop	r29
    1de2:	cf 91       	pop	r28
    1de4:	1f 91       	pop	r17
    1de6:	0f 91       	pop	r16
    1de8:	ff 90       	pop	r15
    1dea:	ef 90       	pop	r14
    1dec:	df 90       	pop	r13
    1dee:	cf 90       	pop	r12
    1df0:	bf 90       	pop	r11
    1df2:	af 90       	pop	r10
    1df4:	9f 90       	pop	r9
    1df6:	8f 90       	pop	r8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:286
/**************************************************************************/
void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                 uint16_t color) {
  startWrite();
  writeLine(x, y, x + w - 1, y, color);
  endWrite();
    1df8:	09 94       	ijmp

00001dfa <Adafruit_GFX::drawFastVLine(int, int, int, unsigned int)>:
drawFastVLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:266
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
    1dfa:	8f 92       	push	r8
    1dfc:	9f 92       	push	r9
    1dfe:	af 92       	push	r10
    1e00:	bf 92       	push	r11
    1e02:	cf 92       	push	r12
    1e04:	df 92       	push	r13
    1e06:	ef 92       	push	r14
    1e08:	ff 92       	push	r15
    1e0a:	0f 93       	push	r16
    1e0c:	1f 93       	push	r17
    1e0e:	cf 93       	push	r28
    1e10:	df 93       	push	r29
    1e12:	ec 01       	movw	r28, r24
    1e14:	5b 01       	movw	r10, r22
    1e16:	4a 01       	movw	r8, r20
    1e18:	69 01       	movw	r12, r18
    1e1a:	78 01       	movw	r14, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:267
  startWrite();
    1e1c:	e8 81       	ld	r30, Y
    1e1e:	f9 81       	ldd	r31, Y+1	; 0x01
    1e20:	02 84       	ldd	r0, Z+10	; 0x0a
    1e22:	f3 85       	ldd	r31, Z+11	; 0x0b
    1e24:	e0 2d       	mov	r30, r0
    1e26:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:268
  writeLine(x, y, x, y + h - 1, color);
    1e28:	c8 0c       	add	r12, r8
    1e2a:	d9 1c       	adc	r13, r9
    1e2c:	86 01       	movw	r16, r12
    1e2e:	01 50       	subi	r16, 0x01	; 1
    1e30:	11 09       	sbc	r17, r1
    1e32:	e8 81       	ld	r30, Y
    1e34:	f9 81       	ldd	r31, Y+1	; 0x01
    1e36:	04 88       	ldd	r0, Z+20	; 0x14
    1e38:	f5 89       	ldd	r31, Z+21	; 0x15
    1e3a:	e0 2d       	mov	r30, r0
    1e3c:	95 01       	movw	r18, r10
    1e3e:	a4 01       	movw	r20, r8
    1e40:	b5 01       	movw	r22, r10
    1e42:	ce 01       	movw	r24, r28
    1e44:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:269
  endWrite();
    1e46:	e8 81       	ld	r30, Y
    1e48:	f9 81       	ldd	r31, Y+1	; 0x01
    1e4a:	06 88       	ldd	r0, Z+22	; 0x16
    1e4c:	f7 89       	ldd	r31, Z+23	; 0x17
    1e4e:	e0 2d       	mov	r30, r0
    1e50:	ce 01       	movw	r24, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:270
}
    1e52:	df 91       	pop	r29
    1e54:	cf 91       	pop	r28
    1e56:	1f 91       	pop	r17
    1e58:	0f 91       	pop	r16
    1e5a:	ff 90       	pop	r15
    1e5c:	ef 90       	pop	r14
    1e5e:	df 90       	pop	r13
    1e60:	cf 90       	pop	r12
    1e62:	bf 90       	pop	r11
    1e64:	af 90       	pop	r10
    1e66:	9f 90       	pop	r9
    1e68:	8f 90       	pop	r8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:269
/**************************************************************************/
void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                 uint16_t color) {
  startWrite();
  writeLine(x, y, x, y + h - 1, color);
  endWrite();
    1e6a:	09 94       	ijmp

00001e6c <Adafruit_GFX::writeFillRect(int, int, int, int, unsigned int)>:
writeFillRect():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:242
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFillRect(int16_t x, int16_t y, int16_t w, int16_t h,
                                 uint16_t color) {
    1e6c:	ef 92       	push	r14
    1e6e:	ff 92       	push	r15
    1e70:	0f 93       	push	r16
    1e72:	1f 93       	push	r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:244
  // Overwrite in subclasses if desired!
  fillRect(x, y, w, h, color);
    1e74:	dc 01       	movw	r26, r24
    1e76:	ed 91       	ld	r30, X+
    1e78:	fc 91       	ld	r31, X
    1e7a:	00 a0       	ldd	r0, Z+32	; 0x20
    1e7c:	f1 a1       	ldd	r31, Z+33	; 0x21
    1e7e:	e0 2d       	mov	r30, r0
    1e80:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:245
}
    1e82:	1f 91       	pop	r17
    1e84:	0f 91       	pop	r16
    1e86:	ff 90       	pop	r15
    1e88:	ef 90       	pop	r14
    1e8a:	08 95       	ret

00001e8c <Adafruit_GFX::writeFastHLine(int, int, int, unsigned int)>:
writeFastHLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:223
    @param    w   Width in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastHLine(int16_t x, int16_t y, int16_t w,
                                  uint16_t color) {
    1e8c:	0f 93       	push	r16
    1e8e:	1f 93       	push	r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:227
  // Overwrite in subclasses if startWrite is defined!
  // Example: writeLine(x, y, x+w-1, y, color);
  // or writeFillRect(x, y, w, 1, color);
  drawFastHLine(x, y, w, color);
    1e90:	dc 01       	movw	r26, r24
    1e92:	ed 91       	ld	r30, X+
    1e94:	fc 91       	ld	r31, X
    1e96:	06 8c       	ldd	r0, Z+30	; 0x1e
    1e98:	f7 8d       	ldd	r31, Z+31	; 0x1f
    1e9a:	e0 2d       	mov	r30, r0
    1e9c:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:228
}
    1e9e:	1f 91       	pop	r17
    1ea0:	0f 91       	pop	r16
    1ea2:	08 95       	ret

00001ea4 <Adafruit_GFX::writeFastVLine(int, int, int, unsigned int)>:
writeFastVLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:205
    @param    h   Height in pixels
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writeFastVLine(int16_t x, int16_t y, int16_t h,
                                  uint16_t color) {
    1ea4:	0f 93       	push	r16
    1ea6:	1f 93       	push	r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:209
  // Overwrite in subclasses if startWrite is defined!
  // Can be just writeLine(x, y, x, y+h-1, color);
  // or writeFillRect(x, y, 1, h, color);
  drawFastVLine(x, y, h, color);
    1ea8:	dc 01       	movw	r26, r24
    1eaa:	ed 91       	ld	r30, X+
    1eac:	fc 91       	ld	r31, X
    1eae:	04 8c       	ldd	r0, Z+28	; 0x1c
    1eb0:	f5 8d       	ldd	r31, Z+29	; 0x1d
    1eb2:	e0 2d       	mov	r30, r0
    1eb4:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:210
}
    1eb6:	1f 91       	pop	r17
    1eb8:	0f 91       	pop	r16
    1eba:	08 95       	ret

00001ebc <Adafruit_GFX::writePixel(int, int, unsigned int)>:
writePixel():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:191
    @param   y   y coordinate
   @param    color 16-bit 5-6-5 Color to fill with
*/
/**************************************************************************/
void Adafruit_GFX::writePixel(int16_t x, int16_t y, uint16_t color) {
  drawPixel(x, y, color);
    1ebc:	dc 01       	movw	r26, r24
    1ebe:	ed 91       	ld	r30, X+
    1ec0:	fc 91       	ld	r31, X
    1ec2:	00 84       	ldd	r0, Z+8	; 0x08
    1ec4:	f1 85       	ldd	r31, Z+9	; 0x09
    1ec6:	e0 2d       	mov	r30, r0
    1ec8:	09 94       	ijmp

00001eca <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]>:
drawBitmap():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:717
    @param    w   Width of bitmap in pixels
    @param    h   Height of bitmap in pixels
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[],
    1eca:	3f 92       	push	r3
    1ecc:	4f 92       	push	r4
    1ece:	5f 92       	push	r5
    1ed0:	6f 92       	push	r6
    1ed2:	7f 92       	push	r7
    1ed4:	8f 92       	push	r8
    1ed6:	9f 92       	push	r9
    1ed8:	af 92       	push	r10
    1eda:	bf 92       	push	r11
    1edc:	cf 92       	push	r12
    1ede:	df 92       	push	r13
    1ee0:	ef 92       	push	r14
    1ee2:	ff 92       	push	r15
    1ee4:	0f 93       	push	r16
    1ee6:	1f 93       	push	r17
    1ee8:	cf 93       	push	r28
    1eea:	df 93       	push	r29
    1eec:	00 d0       	rcall	.+0      	; 0x1eee <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x24>
    1eee:	00 d0       	rcall	.+0      	; 0x1ef0 <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x26>
    1ef0:	cd b7       	in	r28, 0x3d	; 61
    1ef2:	de b7       	in	r29, 0x3e	; 62
    1ef4:	5c 01       	movw	r10, r24
    1ef6:	3b 01       	movw	r6, r22
    1ef8:	6a 01       	movw	r12, r20
    1efa:	49 01       	movw	r8, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:720
                              int16_t w, int16_t h, uint16_t color) {

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
    1efc:	28 01       	movw	r4, r16
    1efe:	87 e0       	ldi	r24, 0x07	; 7
    1f00:	48 0e       	add	r4, r24
    1f02:	51 1c       	adc	r5, r1
    1f04:	93 e0       	ldi	r25, 0x03	; 3
    1f06:	55 94       	asr	r5
    1f08:	47 94       	ror	r4
    1f0a:	9a 95       	dec	r25
    1f0c:	e1 f7       	brne	.-8      	; 0x1f06 <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x3c>
    1f0e:	ca 01       	movw	r24, r20
    1f10:	8e 0d       	add	r24, r14
    1f12:	9f 1d       	adc	r25, r15
    1f14:	89 83       	std	Y+1, r24	; 0x01
    1f16:	9a 83       	std	Y+2, r25	; 0x02
    1f18:	f1 2c       	mov	r15, r1
    1f1a:	e1 2c       	mov	r14, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:721
  uint8_t b = 0;
    1f1c:	31 2c       	mov	r3, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:725

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
    1f1e:	1b 82       	std	Y+3, r1	; 0x03
    1f20:	1c 82       	std	Y+4, r1	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:726
      if (i & 7)
    1f22:	8b 81       	ldd	r24, Y+3	; 0x03
    1f24:	9c 81       	ldd	r25, Y+4	; 0x04
    1f26:	87 70       	andi	r24, 0x07	; 7
    1f28:	99 27       	eor	r25, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:727
        b <<= 1;
    1f2a:	33 0c       	add	r3, r3
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:726
  uint8_t b = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
      if (i & 7)
    1f2c:	89 2b       	or	r24, r25
    1f2e:	61 f4       	brne	.+24     	; 0x1f48 <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x7e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:729
        b <<= 1;
      else
        b = pgm_read_byte(&bitmap[j * byteWidth + i / 8]);
    1f30:	eb 81       	ldd	r30, Y+3	; 0x03
    1f32:	fc 81       	ldd	r31, Y+4	; 0x04
    1f34:	83 e0       	ldi	r24, 0x03	; 3
    1f36:	f5 95       	asr	r31
    1f38:	e7 95       	ror	r30
    1f3a:	8a 95       	dec	r24
    1f3c:	e1 f7       	brne	.-8      	; 0x1f36 <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x6c>
    1f3e:	ee 0d       	add	r30, r14
    1f40:	ff 1d       	adc	r31, r15
    1f42:	e8 0d       	add	r30, r8
    1f44:	f9 1d       	adc	r31, r9
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:730
      if (b & 0x80)
    1f46:	34 90       	lpm	r3, Z
    1f48:	37 fe       	sbrs	r3, 7
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:731
        writePixel(x + i, y, color);
    1f4a:	09 c0       	rjmp	.+18     	; 0x1f5e <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x94>
    1f4c:	21 e0       	ldi	r18, 0x01	; 1
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	a6 01       	movw	r20, r12
    1f52:	6b 81       	ldd	r22, Y+3	; 0x03
    1f54:	7c 81       	ldd	r23, Y+4	; 0x04
    1f56:	66 0d       	add	r22, r6
    1f58:	77 1d       	adc	r23, r7
    1f5a:	c5 01       	movw	r24, r10
    1f5c:	af df       	rcall	.-162    	; 0x1ebc <Adafruit_GFX::writePixel(int, int, unsigned int)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:725
  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t b = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    for (int16_t i = 0; i < w; i++) {
    1f5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f60:	9c 81       	ldd	r25, Y+4	; 0x04
    1f62:	01 96       	adiw	r24, 0x01	; 1
    1f64:	8b 83       	std	Y+3, r24	; 0x03
    1f66:	9c 83       	std	Y+4, r25	; 0x04
    1f68:	08 17       	cp	r16, r24
    1f6a:	19 07       	cpc	r17, r25
    1f6c:	d1 f6       	brne	.-76     	; 0x1f22 <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x58>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:724

  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
  uint8_t b = 0;

  startWrite();
  for (int16_t j = 0; j < h; j++, y++) {
    1f6e:	9f ef       	ldi	r25, 0xFF	; 255
    1f70:	c9 1a       	sub	r12, r25
    1f72:	d9 0a       	sbc	r13, r25
    1f74:	e4 0c       	add	r14, r4
    1f76:	f5 1c       	adc	r15, r5
    1f78:	89 81       	ldd	r24, Y+1	; 0x01
    1f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f7c:	c8 16       	cp	r12, r24
    1f7e:	d9 06       	cpc	r13, r25
    1f80:	71 f6       	brne	.-100    	; 0x1f1e <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]+0x54>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:735
      if (b & 0x80)
        writePixel(x + i, y, color);
    }
  }
  endWrite();
}
    1f82:	24 96       	adiw	r28, 0x04	; 4
    1f84:	cd bf       	out	0x3d, r28	; 61
    1f86:	de bf       	out	0x3e, r29	; 62
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	1f 91       	pop	r17
    1f8e:	0f 91       	pop	r16
    1f90:	ff 90       	pop	r15
    1f92:	ef 90       	pop	r14
    1f94:	df 90       	pop	r13
    1f96:	cf 90       	pop	r12
    1f98:	bf 90       	pop	r11
    1f9a:	af 90       	pop	r10
    1f9c:	9f 90       	pop	r9
    1f9e:	8f 90       	pop	r8
    1fa0:	7f 90       	pop	r7
    1fa2:	6f 90       	pop	r6
    1fa4:	5f 90       	pop	r5
    1fa6:	4f 90       	pop	r4
    1fa8:	3f 90       	pop	r3
    1faa:	08 95       	ret

00001fac <Adafruit_GFX::writeLine(int, int, int, int, unsigned int)>:
writeLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:133
    @param    y1  End point y coordinate
    @param    color 16-bit 5-6-5 Color to draw with
*/
/**************************************************************************/
void Adafruit_GFX::writeLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1,
                             uint16_t color) {
    1fac:	2f 92       	push	r2
    1fae:	3f 92       	push	r3
    1fb0:	4f 92       	push	r4
    1fb2:	5f 92       	push	r5
    1fb4:	6f 92       	push	r6
    1fb6:	7f 92       	push	r7
    1fb8:	8f 92       	push	r8
    1fba:	9f 92       	push	r9
    1fbc:	af 92       	push	r10
    1fbe:	bf 92       	push	r11
    1fc0:	cf 92       	push	r12
    1fc2:	df 92       	push	r13
    1fc4:	ef 92       	push	r14
    1fc6:	ff 92       	push	r15
    1fc8:	0f 93       	push	r16
    1fca:	1f 93       	push	r17
    1fcc:	cf 93       	push	r28
    1fce:	df 93       	push	r29
    1fd0:	cd b7       	in	r28, 0x3d	; 61
    1fd2:	de b7       	in	r29, 0x3e	; 62
    1fd4:	26 97       	sbiw	r28, 0x06	; 6
    1fd6:	cd bf       	out	0x3d, r28	; 61
    1fd8:	de bf       	out	0x3e, r29	; 62
    1fda:	3c 01       	movw	r6, r24
    1fdc:	6a 01       	movw	r12, r20
    1fde:	2d 83       	std	Y+5, r18	; 0x05
    1fe0:	3e 83       	std	Y+6, r19	; 0x06
    1fe2:	eb 82       	std	Y+3, r14	; 0x03
    1fe4:	fc 82       	std	Y+4, r15	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:137
#if defined(ESP8266)
  yield();
#endif
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
    1fe6:	58 01       	movw	r10, r16
    1fe8:	a4 1a       	sub	r10, r20
    1fea:	b5 0a       	sbc	r11, r21
    1fec:	b7 fe       	sbrs	r11, 7
    1fee:	03 c0       	rjmp	.+6      	; 0x1ff6 <Adafruit_GFX::writeLine(int, int, int, int, unsigned int)+0x4a>
    1ff0:	b1 94       	neg	r11
    1ff2:	a1 94       	neg	r10
    1ff4:	b1 08       	sbc	r11, r1
    1ff6:	8d 80       	ldd	r8, Y+5	; 0x05
    1ff8:	9e 80       	ldd	r9, Y+6	; 0x06
    1ffa:	86 1a       	sub	r8, r22
    1ffc:	97 0a       	sbc	r9, r23
    1ffe:	97 fe       	sbrs	r9, 7
    2000:	03 c0       	rjmp	.+6      	; 0x2008 <__DATA_REGION_LENGTH__+0x8>
    2002:	91 94       	neg	r9
    2004:	81 94       	neg	r8
    2006:	91 08       	sbc	r9, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:138
  if (steep) {
    2008:	8a 14       	cp	r8, r10
    200a:	9b 04       	cpc	r9, r11
    200c:	5c f0       	brlt	.+22     	; 0x2024 <__DATA_REGION_LENGTH__+0x24>
    200e:	90 2f       	mov	r25, r16
    2010:	81 2f       	mov	r24, r17
    2012:	0d 81       	ldd	r16, Y+5	; 0x05
    2014:	1e 81       	ldd	r17, Y+6	; 0x06
    2016:	9d 83       	std	Y+5, r25	; 0x05
    2018:	8e 83       	std	Y+6, r24	; 0x06
    201a:	9c 2d       	mov	r25, r12
    201c:	8d 2d       	mov	r24, r13
    201e:	6b 01       	movw	r12, r22
    2020:	69 2f       	mov	r22, r25
    2022:	78 2f       	mov	r23, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:143
    _swap_int16_t(x0, y0);
    _swap_int16_t(x1, y1);
  }

  if (x0 > x1) {
    2024:	0c 15       	cp	r16, r12
    2026:	1d 05       	cpc	r17, r13
    2028:	5c f0       	brlt	.+22     	; 0x2040 <__DATA_REGION_LENGTH__+0x40>
    202a:	9d 81       	ldd	r25, Y+5	; 0x05
    202c:	8e 81       	ldd	r24, Y+6	; 0x06
    202e:	6d 83       	std	Y+5, r22	; 0x05
    2030:	7e 83       	std	Y+6, r23	; 0x06
    2032:	69 2f       	mov	r22, r25
    2034:	78 2f       	mov	r23, r24
    2036:	90 2f       	mov	r25, r16
    2038:	81 2f       	mov	r24, r17
    203a:	86 01       	movw	r16, r12
    203c:	c9 2e       	mov	r12, r25
    203e:	d8 2e       	mov	r13, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:149
    _swap_int16_t(x0, x1);
    _swap_int16_t(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
    2040:	16 01       	movw	r2, r12
    2042:	20 1a       	sub	r2, r16
    2044:	31 0a       	sbc	r3, r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:150
  dy = abs(y1 - y0);
    2046:	2b 01       	movw	r4, r22
    2048:	2d 81       	ldd	r18, Y+5	; 0x05
    204a:	3e 81       	ldd	r19, Y+6	; 0x06
    204c:	42 1a       	sub	r4, r18
    204e:	53 0a       	sbc	r5, r19
    2050:	57 fe       	sbrs	r5, 7
    2052:	03 c0       	rjmp	.+6      	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
    2054:	51 94       	neg	r5
    2056:	41 94       	neg	r4
    2058:	51 08       	sbc	r5, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:152

  int16_t err = dx / 2;
    205a:	71 01       	movw	r14, r2
    205c:	37 fe       	sbrs	r3, 7
    205e:	03 c0       	rjmp	.+6      	; 0x2066 <__DATA_REGION_LENGTH__+0x66>
    2060:	3f ef       	ldi	r19, 0xFF	; 255
    2062:	e3 1a       	sub	r14, r19
    2064:	f3 0a       	sbc	r15, r19
    2066:	f5 94       	asr	r15
    2068:	e7 94       	ror	r14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:155
  int16_t ystep;

  if (y0 < y1) {
    206a:	8d 81       	ldd	r24, Y+5	; 0x05
    206c:	9e 81       	ldd	r25, Y+6	; 0x06
    206e:	86 17       	cp	r24, r22
    2070:	97 07       	cpc	r25, r23
    2072:	5c f5       	brge	.+86     	; 0x20ca <__DATA_REGION_LENGTH__+0xca>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:156
    ystep = 1;
    2074:	a1 e0       	ldi	r26, 0x01	; 1
    2076:	b0 e0       	ldi	r27, 0x00	; 0
    2078:	a9 83       	std	Y+1, r26	; 0x01
    207a:	ba 83       	std	Y+2, r27	; 0x02
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:161
  } else {
    ystep = -1;
  }

  for (; x0 <= x1; x0++) {
    207c:	c0 16       	cp	r12, r16
    207e:	d1 06       	cpc	r13, r17
    2080:	4c f1       	brlt	.+82     	; 0x20d4 <__DATA_REGION_LENGTH__+0xd4>
    2082:	d3 01       	movw	r26, r6
    2084:	ed 91       	ld	r30, X+
    2086:	fc 91       	ld	r31, X
    2088:	04 84       	ldd	r0, Z+12	; 0x0c
    208a:	f5 85       	ldd	r31, Z+13	; 0x0d
    208c:	e0 2d       	mov	r30, r0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:163
    if (steep) {
      writePixel(y0, x0, color);
    208e:	2b 81       	ldd	r18, Y+3	; 0x03
    2090:	3c 81       	ldd	r19, Y+4	; 0x04
    2092:	a8 01       	movw	r20, r16
    2094:	6d 81       	ldd	r22, Y+5	; 0x05
    2096:	7e 81       	ldd	r23, Y+6	; 0x06
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:162
  } else {
    ystep = -1;
  }

  for (; x0 <= x1; x0++) {
    if (steep) {
    2098:	8a 14       	cp	r8, r10
    209a:	9b 04       	cpc	r9, r11
    209c:	1c f0       	brlt	.+6      	; 0x20a4 <__DATA_REGION_LENGTH__+0xa4>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:165
      writePixel(y0, x0, color);
    } else {
      writePixel(x0, y0, color);
    209e:	4d 81       	ldd	r20, Y+5	; 0x05
    20a0:	5e 81       	ldd	r21, Y+6	; 0x06
    20a2:	b8 01       	movw	r22, r16
    20a4:	c3 01       	movw	r24, r6
    20a6:	09 95       	icall
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:167
    }
    err -= dy;
    20a8:	e4 18       	sub	r14, r4
    20aa:	f5 08       	sbc	r15, r5
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:168
    if (err < 0) {
    20ac:	f7 fe       	sbrs	r15, 7
    20ae:	0a c0       	rjmp	.+20     	; 0x20c4 <__DATA_REGION_LENGTH__+0xc4>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:169
      y0 += ystep;
    20b0:	2d 81       	ldd	r18, Y+5	; 0x05
    20b2:	3e 81       	ldd	r19, Y+6	; 0x06
    20b4:	89 81       	ldd	r24, Y+1	; 0x01
    20b6:	9a 81       	ldd	r25, Y+2	; 0x02
    20b8:	28 0f       	add	r18, r24
    20ba:	39 1f       	adc	r19, r25
    20bc:	2d 83       	std	Y+5, r18	; 0x05
    20be:	3e 83       	std	Y+6, r19	; 0x06
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:170
      err += dx;
    20c0:	e2 0c       	add	r14, r2
    20c2:	f3 1c       	adc	r15, r3
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:161
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0 <= x1; x0++) {
    20c4:	0f 5f       	subi	r16, 0xFF	; 255
    20c6:	1f 4f       	sbci	r17, 0xFF	; 255
    20c8:	d9 cf       	rjmp	.-78     	; 0x207c <__DATA_REGION_LENGTH__+0x7c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:158
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
    20ca:	2f ef       	ldi	r18, 0xFF	; 255
    20cc:	3f ef       	ldi	r19, 0xFF	; 255
    20ce:	29 83       	std	Y+1, r18	; 0x01
    20d0:	3a 83       	std	Y+2, r19	; 0x02
    20d2:	d4 cf       	rjmp	.-88     	; 0x207c <__DATA_REGION_LENGTH__+0x7c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_GFX_Library/Adafruit_GFX.cpp:173
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
    20d4:	26 96       	adiw	r28, 0x06	; 6
    20d6:	cd bf       	out	0x3d, r28	; 61
    20d8:	de bf       	out	0x3e, r29	; 62
    20da:	df 91       	pop	r29
    20dc:	cf 91       	pop	r28
    20de:	1f 91       	pop	r17
    20e0:	0f 91       	pop	r16
    20e2:	ff 90       	pop	r15
    20e4:	ef 90       	pop	r14
    20e6:	df 90       	pop	r13
    20e8:	cf 90       	pop	r12
    20ea:	bf 90       	pop	r11
    20ec:	af 90       	pop	r10
    20ee:	9f 90       	pop	r9
    20f0:	8f 90       	pop	r8
    20f2:	7f 90       	pop	r7
    20f4:	6f 90       	pop	r6
    20f6:	5f 90       	pop	r5
    20f8:	4f 90       	pop	r4
    20fa:	3f 90       	pop	r3
    20fc:	2f 90       	pop	r2
    20fe:	08 95       	ret

00002100 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]>:
_ZN16Adafruit_SSD130621drawFastVLineInternalEiiij.part.8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:847
    @return None (void).
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y,
    2100:	ef 92       	push	r14
    2102:	ff 92       	push	r15
    2104:	0f 93       	push	r16
    2106:	1f 93       	push	r17
    2108:	cf 93       	push	r28
    210a:	df 93       	push	r29
    210c:	ec 01       	movw	r28, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:850
                                             int16_t __h, uint16_t color) {

  if ((x >= 0) && (x < WIDTH)) { // X coord in bounds?
    210e:	ec 80       	ldd	r14, Y+4	; 0x04
    2110:	fd 80       	ldd	r15, Y+5	; 0x05
    2112:	6e 15       	cp	r22, r14
    2114:	7f 05       	cpc	r23, r15
    2116:	0c f0       	brlt	.+2      	; 0x211a <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x1a>
    2118:	70 c0       	rjmp	.+224    	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:851
    if (__y < 0) {               // Clip top
    211a:	57 ff       	sbrs	r21, 7
    211c:	04 c0       	rjmp	.+8      	; 0x2126 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x26>
    211e:	24 0f       	add	r18, r20
    2120:	35 1f       	adc	r19, r21
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:853
      __h += __y;
      __y = 0;
    2122:	50 e0       	ldi	r21, 0x00	; 0
    2124:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:855
    }
    if ((__y + __h) > HEIGHT) { // Clip bottom
    2126:	8e 81       	ldd	r24, Y+6	; 0x06
    2128:	9f 81       	ldd	r25, Y+7	; 0x07
    212a:	fa 01       	movw	r30, r20
    212c:	e2 0f       	add	r30, r18
    212e:	f3 1f       	adc	r31, r19
    2130:	8e 17       	cp	r24, r30
    2132:	9f 07       	cpc	r25, r31
    2134:	1c f4       	brge	.+6      	; 0x213c <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x3c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:856
      __h = (HEIGHT - __y);
    2136:	9c 01       	movw	r18, r24
    2138:	24 1b       	sub	r18, r20
    213a:	35 0b       	sbc	r19, r21
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:858
    }
    if (__h > 0) { // Proceed only if height is now positive
    213c:	12 16       	cp	r1, r18
    213e:	13 06       	cpc	r1, r19
    2140:	0c f0       	brlt	.+2      	; 0x2144 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x44>
    2142:	5b c0       	rjmp	.+182    	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:861
      // this display doesn't need ints for coordinates,
      // use local byte registers for faster juggling
      uint8_t y = __y, h = __h;
    2144:	92 2f       	mov	r25, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:862
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x];
    2146:	84 2f       	mov	r24, r20
    2148:	86 95       	lsr	r24
    214a:	86 95       	lsr	r24
    214c:	86 95       	lsr	r24
    214e:	8e 9d       	mul	r24, r14
    2150:	d0 01       	movw	r26, r0
    2152:	8f 9d       	mul	r24, r15
    2154:	b0 0d       	add	r27, r0
    2156:	11 24       	eor	r1, r1
    2158:	6a 0f       	add	r22, r26
    215a:	7b 1f       	adc	r23, r27
    215c:	af 8d       	ldd	r26, Y+31	; 0x1f
    215e:	b8 a1       	ldd	r27, Y+32	; 0x20
    2160:	a6 0f       	add	r26, r22
    2162:	b7 1f       	adc	r27, r23
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:865

      // do the first partial byte, if necessary - this requires some masking
      uint8_t mod = (y & 7);
    2164:	47 70       	andi	r20, 0x07	; 7
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:866
      if (mod) {
    2166:	49 f1       	breq	.+82     	; 0x21ba <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xba>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:868
        // mask off the high n bits we want to set
        mod = 8 - mod;
    2168:	88 e0       	ldi	r24, 0x08	; 8
    216a:	84 1b       	sub	r24, r20
    216c:	48 2f       	mov	r20, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:874
        // note - lookup table results in a nearly 10% performance
        // improvement in fill* functions
        // uint8_t mask = ~(0xFF >> mod);
        static const uint8_t PROGMEM premask[8] = {0x00, 0x80, 0xC0, 0xE0,
                                                   0xF0, 0xF8, 0xFC, 0xFE};
        uint8_t mask = pgm_read_byte(&premask[mod]);
    216e:	68 2f       	mov	r22, r24
    2170:	70 e0       	ldi	r23, 0x00	; 0
    2172:	fb 01       	movw	r30, r22
    2174:	e8 56       	subi	r30, 0x68	; 104
    2176:	ff 4f       	sbci	r31, 0xFF	; 255
    2178:	e4 91       	lpm	r30, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:876
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
    217a:	28 17       	cp	r18, r24
    217c:	08 f0       	brcs	.+2      	; 0x2180 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x80>
    217e:	63 c0       	rjmp	.+198    	; 0x2246 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x146>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:877
          mask &= (0XFF >> (mod - h));
    2180:	62 1b       	sub	r22, r18
    2182:	71 09       	sbc	r23, r1
    2184:	2f ef       	ldi	r18, 0xFF	; 255
    2186:	30 e0       	ldi	r19, 0x00	; 0
    2188:	02 c0       	rjmp	.+4      	; 0x218e <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x8e>
    218a:	35 95       	asr	r19
    218c:	27 95       	ror	r18
    218e:	6a 95       	dec	r22
    2190:	e2 f7       	brpl	.-8      	; 0x218a <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x8a>
    2192:	e2 23       	and	r30, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:879

        switch (color) {
    2194:	01 30       	cpi	r16, 0x01	; 1
    2196:	11 05       	cpc	r17, r1
    2198:	39 f0       	breq	.+14     	; 0x21a8 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xa8>
    219a:	b0 f1       	brcs	.+108    	; 0x2208 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x108>
    219c:	02 30       	cpi	r16, 0x02	; 2
    219e:	11 05       	cpc	r17, r1
    21a0:	61 f5       	brne	.+88     	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:887
          break;
        case SSD1306_BLACK:
          *pBuf &= ~mask;
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
    21a2:	8c 91       	ld	r24, X
    21a4:	e8 27       	eor	r30, r24
    21a6:	02 c0       	rjmp	.+4      	; 0x21ac <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xac>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:881
        if (h < mod)
          mask &= (0XFF >> (mod - h));

        switch (color) {
        case SSD1306_WHITE:
          *pBuf |= mask;
    21a8:	8c 91       	ld	r24, X
    21aa:	e8 2b       	or	r30, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:887
          break;
        case SSD1306_BLACK:
          *pBuf &= ~mask;
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
    21ac:	ec 93       	st	X, r30
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:893
          break;
        }
        pBuf += WIDTH;
      }

      if (h >= mod) { // More to go?
    21ae:	94 17       	cp	r25, r20
    21b0:	20 f1       	brcs	.+72     	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:890
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
          break;
        }
        pBuf += WIDTH;
    21b2:	2c 81       	ldd	r18, Y+4	; 0x04
    21b4:	3d 81       	ldd	r19, Y+5	; 0x05
    21b6:	a2 0f       	add	r26, r18
    21b8:	b3 1f       	adc	r27, r19
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:894
      }

      if (h >= mod) { // More to go?
        h -= mod;
    21ba:	e9 2f       	mov	r30, r25
    21bc:	e4 1b       	sub	r30, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:896
        // Write solid bytes while we can - effectively 8 rows at a time
        if (h >= 8) {
    21be:	e8 30       	cpi	r30, 0x08	; 8
    21c0:	78 f0       	brcs	.+30     	; 0x21e0 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xe0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:897
          if (color == SSD1306_INVERSE) {
    21c2:	02 30       	cpi	r16, 0x02	; 2
    21c4:	11 05       	cpc	r17, r1
    21c6:	21 f5       	brne	.+72     	; 0x2210 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x110>
    21c8:	8e 2f       	mov	r24, r30
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:901
            // separate copy of the code so we don't impact performance of
            // black/white write version with an extra comparison per loop
            do {
              *pBuf ^= 0xFF; // Invert byte
    21ca:	9c 91       	ld	r25, X
    21cc:	90 95       	com	r25
    21ce:	9c 93       	st	X, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:902
              pBuf += WIDTH; // Advance pointer 8 rows
    21d0:	2c 81       	ldd	r18, Y+4	; 0x04
    21d2:	3d 81       	ldd	r19, Y+5	; 0x05
    21d4:	a2 0f       	add	r26, r18
    21d6:	b3 1f       	adc	r27, r19
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:903
              h -= 8;        // Subtract 8 rows from height
    21d8:	88 50       	subi	r24, 0x08	; 8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:904
            } while (h >= 8);
    21da:	88 30       	cpi	r24, 0x08	; 8
    21dc:	b0 f7       	brcc	.-20     	; 0x21ca <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xca>
    21de:	e7 70       	andi	r30, 0x07	; 7
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:916
              h -= 8;        // Subtract 8 rows from height
            } while (h >= 8);
          }
        }

        if (h) { // Do the final partial byte, if necessary
    21e0:	ee 23       	and	r30, r30
    21e2:	59 f0       	breq	.+22     	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:925
          // uint8_t mask = (1 << mod) - 1;
          // note - lookup table results in a nearly 10% performance
          // improvement in fill* functions
          static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
                                                      0x0F, 0x1F, 0x3F, 0x7F};
          uint8_t mask = pgm_read_byte(&postmask[mod]);
    21e4:	f0 e0       	ldi	r31, 0x00	; 0
    21e6:	e0 57       	subi	r30, 0x70	; 112
    21e8:	ff 4f       	sbci	r31, 0xFF	; 255
    21ea:	e4 91       	lpm	r30, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:926
          switch (color) {
    21ec:	01 30       	cpi	r16, 0x01	; 1
    21ee:	11 05       	cpc	r17, r1
    21f0:	f9 f0       	breq	.+62     	; 0x2230 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x130>
    21f2:	10 f1       	brcs	.+68     	; 0x2238 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x138>
    21f4:	02 30       	cpi	r16, 0x02	; 2
    21f6:	11 05       	cpc	r17, r1
    21f8:	19 f1       	breq	.+70     	; 0x2240 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x140>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:941
          }
        }
      }
    } // endif positive height
  }   // endif x in bounds
}
    21fa:	df 91       	pop	r29
    21fc:	cf 91       	pop	r28
    21fe:	1f 91       	pop	r17
    2200:	0f 91       	pop	r16
    2202:	ff 90       	pop	r15
    2204:	ef 90       	pop	r14
    2206:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:884
        switch (color) {
        case SSD1306_WHITE:
          *pBuf |= mask;
          break;
        case SSD1306_BLACK:
          *pBuf &= ~mask;
    2208:	e0 95       	com	r30
    220a:	8c 91       	ld	r24, X
    220c:	e8 23       	and	r30, r24
    220e:	ce cf       	rjmp	.-100    	; 0x21ac <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xac>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:907
              pBuf += WIDTH; // Advance pointer 8 rows
              h -= 8;        // Subtract 8 rows from height
            } while (h >= 8);
          } else {
            // store a local value to work with
            uint8_t val = (color != SSD1306_BLACK) ? 255 : 0;
    2210:	81 e0       	ldi	r24, 0x01	; 1
    2212:	01 15       	cp	r16, r1
    2214:	11 05       	cpc	r17, r1
    2216:	09 f4       	brne	.+2      	; 0x221a <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x11a>
    2218:	80 e0       	ldi	r24, 0x00	; 0
    221a:	81 95       	neg	r24
    221c:	9e 2f       	mov	r25, r30
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:909
            do {
              *pBuf = val;   // Set byte
    221e:	8c 93       	st	X, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:910
              pBuf += WIDTH; // Advance pointer 8 rows
    2220:	2c 81       	ldd	r18, Y+4	; 0x04
    2222:	3d 81       	ldd	r19, Y+5	; 0x05
    2224:	a2 0f       	add	r26, r18
    2226:	b3 1f       	adc	r27, r19
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:911
              h -= 8;        // Subtract 8 rows from height
    2228:	98 50       	subi	r25, 0x08	; 8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:912
            } while (h >= 8);
    222a:	98 30       	cpi	r25, 0x08	; 8
    222c:	c0 f7       	brcc	.-16     	; 0x221e <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x11e>
    222e:	d7 cf       	rjmp	.-82     	; 0x21de <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xde>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:928
          static const uint8_t PROGMEM postmask[8] = {0x00, 0x01, 0x03, 0x07,
                                                      0x0F, 0x1F, 0x3F, 0x7F};
          uint8_t mask = pgm_read_byte(&postmask[mod]);
          switch (color) {
          case SSD1306_WHITE:
            *pBuf |= mask;
    2230:	8c 91       	ld	r24, X
    2232:	e8 2b       	or	r30, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:934
            break;
          case SSD1306_BLACK:
            *pBuf &= ~mask;
            break;
          case SSD1306_INVERSE:
            *pBuf ^= mask;
    2234:	ec 93       	st	X, r30
    2236:	e1 cf       	rjmp	.-62     	; 0x21fa <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xfa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:931
          switch (color) {
          case SSD1306_WHITE:
            *pBuf |= mask;
            break;
          case SSD1306_BLACK:
            *pBuf &= ~mask;
    2238:	e0 95       	com	r30
    223a:	8c 91       	ld	r24, X
    223c:	e8 23       	and	r30, r24
    223e:	fa cf       	rjmp	.-12     	; 0x2234 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x134>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:934
            break;
          case SSD1306_INVERSE:
            *pBuf ^= mask;
    2240:	8c 91       	ld	r24, X
    2242:	e8 27       	eor	r30, r24
    2244:	f7 cf       	rjmp	.-18     	; 0x2234 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x134>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:879
        uint8_t mask = pgm_read_byte(&premask[mod]);
        // adjust the mask if we're not going to reach the end of this byte
        if (h < mod)
          mask &= (0XFF >> (mod - h));

        switch (color) {
    2246:	01 30       	cpi	r16, 0x01	; 1
    2248:	11 05       	cpc	r17, r1
    224a:	09 f4       	brne	.+2      	; 0x224e <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x14e>
    224c:	ad cf       	rjmp	.-166    	; 0x21a8 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xa8>
    224e:	e0 f2       	brcs	.-72     	; 0x2208 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x108>
    2250:	02 30       	cpi	r16, 0x02	; 2
    2252:	11 05       	cpc	r17, r1
    2254:	09 f4       	brne	.+2      	; 0x2258 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0x158>
    2256:	a5 cf       	rjmp	.-182    	; 0x21a2 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xa2>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:890
          break;
        case SSD1306_INVERSE:
          *pBuf ^= mask;
          break;
        }
        pBuf += WIDTH;
    2258:	ae 0d       	add	r26, r14
    225a:	bf 1d       	adc	r27, r15
    225c:	ae cf       	rjmp	.-164    	; 0x21ba <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]+0xba>

0000225e <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]>:
_ZN16Adafruit_SSD130621drawFastHLineInternalEiiij.part.7():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:748
    @return None (void).
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w,
    225e:	0f 93       	push	r16
    2260:	1f 93       	push	r17
    2262:	cf 93       	push	r28
    2264:	df 93       	push	r29
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:752
                                             uint16_t color) {

  if ((y >= 0) && (y < HEIGHT)) { // Y coord in bounds?
    if (x < 0) {                  // Clip left
    2266:	77 ff       	sbrs	r23, 7
    2268:	04 c0       	rjmp	.+8      	; 0x2272 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x14>
    226a:	26 0f       	add	r18, r22
    226c:	37 1f       	adc	r19, r23
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:754
      w += x;
      x = 0;
    226e:	70 e0       	ldi	r23, 0x00	; 0
    2270:	60 e0       	ldi	r22, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:756
    }
    if ((x + w) > WIDTH) { // Clip right
    2272:	dc 01       	movw	r26, r24
    2274:	14 96       	adiw	r26, 0x04	; 4
    2276:	cd 91       	ld	r28, X+
    2278:	dc 91       	ld	r29, X
    227a:	fb 01       	movw	r30, r22
    227c:	e2 0f       	add	r30, r18
    227e:	f3 1f       	adc	r31, r19
    2280:	ce 17       	cp	r28, r30
    2282:	df 07       	cpc	r29, r31
    2284:	1c f4       	brge	.+6      	; 0x228c <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x2e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:757
      w = (WIDTH - x);
    2286:	9e 01       	movw	r18, r28
    2288:	26 1b       	sub	r18, r22
    228a:	37 0b       	sbc	r19, r23
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:759
    }
    if (w > 0) { // Proceed only if width is positive
    228c:	12 16       	cp	r1, r18
    228e:	13 06       	cpc	r1, r19
    2290:	4c f5       	brge	.+82     	; 0x22e4 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x86>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:760
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x], mask = 1 << (y & 7);
    2292:	fa 01       	movw	r30, r20
    2294:	57 fd       	sbrc	r21, 7
    2296:	37 96       	adiw	r30, 0x07	; 7
    2298:	a3 e0       	ldi	r26, 0x03	; 3
    229a:	f5 95       	asr	r31
    229c:	e7 95       	ror	r30
    229e:	aa 95       	dec	r26
    22a0:	e1 f7       	brne	.-8      	; 0x229a <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x3c>
    22a2:	ec 9f       	mul	r30, r28
    22a4:	d0 01       	movw	r26, r0
    22a6:	ed 9f       	mul	r30, r29
    22a8:	b0 0d       	add	r27, r0
    22aa:	fc 9f       	mul	r31, r28
    22ac:	b0 0d       	add	r27, r0
    22ae:	11 24       	eor	r1, r1
    22b0:	6a 0f       	add	r22, r26
    22b2:	7b 1f       	adc	r23, r27
    22b4:	dc 01       	movw	r26, r24
    22b6:	5f 96       	adiw	r26, 0x1f	; 31
    22b8:	ed 91       	ld	r30, X+
    22ba:	fc 91       	ld	r31, X
    22bc:	e6 0f       	add	r30, r22
    22be:	f7 1f       	adc	r31, r23
    22c0:	47 70       	andi	r20, 0x07	; 7
    22c2:	55 27       	eor	r21, r21
    22c4:	81 e0       	ldi	r24, 0x01	; 1
    22c6:	90 e0       	ldi	r25, 0x00	; 0
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x6e>
    22ca:	88 0f       	add	r24, r24
    22cc:	4a 95       	dec	r20
    22ce:	ea f7       	brpl	.-6      	; 0x22ca <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x6c>
    22d0:	48 2f       	mov	r20, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:761
      switch (color) {
    22d2:	01 30       	cpi	r16, 0x01	; 1
    22d4:	11 05       	cpc	r17, r1
    22d6:	59 f0       	breq	.+22     	; 0x22ee <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x90>
    22d8:	a8 f0       	brcs	.+42     	; 0x2304 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0xa6>
    22da:	2e 0f       	add	r18, r30
    22dc:	3f 1f       	adc	r19, r31
    22de:	02 30       	cpi	r16, 0x02	; 2
    22e0:	11 05       	cpc	r17, r1
    22e2:	e1 f0       	breq	.+56     	; 0x231c <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0xbe>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:781
        };
        break;
      }
    }
  }
}
    22e4:	df 91       	pop	r29
    22e6:	cf 91       	pop	r28
    22e8:	1f 91       	pop	r17
    22ea:	0f 91       	pop	r16
    22ec:	08 95       	ret
    22ee:	2e 0f       	add	r18, r30
    22f0:	3f 1f       	adc	r19, r31
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:763
    }
    if (w > 0) { // Proceed only if width is positive
      uint8_t *pBuf = &buffer[(y / 8) * WIDTH + x], mask = 1 << (y & 7);
      switch (color) {
      case SSD1306_WHITE:
        while (w--) {
    22f2:	e2 17       	cp	r30, r18
    22f4:	f3 07       	cpc	r31, r19
    22f6:	b1 f3       	breq	.-20     	; 0x22e4 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x86>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:764
          *pBuf++ |= mask;
    22f8:	81 91       	ld	r24, Z+
    22fa:	df 01       	movw	r26, r30
    22fc:	11 97       	sbiw	r26, 0x01	; 1
    22fe:	84 2b       	or	r24, r20
    2300:	8c 93       	st	X, r24
    2302:	f7 cf       	rjmp	.-18     	; 0x22f2 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x94>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:768
        };
        break;
      case SSD1306_BLACK:
        mask = ~mask;
    2304:	80 95       	com	r24
    2306:	2e 0f       	add	r18, r30
    2308:	3f 1f       	adc	r19, r31
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:769
        while (w--) {
    230a:	e2 17       	cp	r30, r18
    230c:	f3 07       	cpc	r31, r19
    230e:	51 f3       	breq	.-44     	; 0x22e4 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x86>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:770
          *pBuf++ &= mask;
    2310:	91 91       	ld	r25, Z+
    2312:	df 01       	movw	r26, r30
    2314:	11 97       	sbiw	r26, 0x01	; 1
    2316:	98 23       	and	r25, r24
    2318:	9c 93       	st	X, r25
    231a:	f7 cf       	rjmp	.-18     	; 0x230a <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0xac>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:774
        };
        break;
      case SSD1306_INVERSE:
        while (w--) {
    231c:	e2 17       	cp	r30, r18
    231e:	f3 07       	cpc	r31, r19
    2320:	09 f3       	breq	.-62     	; 0x22e4 <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0x86>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:775
          *pBuf++ ^= mask;
    2322:	81 91       	ld	r24, Z+
    2324:	df 01       	movw	r26, r30
    2326:	11 97       	sbiw	r26, 0x01	; 1
    2328:	84 27       	eor	r24, r20
    232a:	8c 93       	st	X, r24
    232c:	f7 cf       	rjmp	.-18     	; 0x231c <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]+0xbe>

0000232e <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)>:
drawFastVLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:800
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h,
                                     uint16_t color) {
    232e:	0f 93       	push	r16
    2330:	1f 93       	push	r17
    2332:	fa 01       	movw	r30, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:802
  bool bSwap = false;
  switch (rotation) {
    2334:	dc 01       	movw	r26, r24
    2336:	56 96       	adiw	r26, 0x16	; 22
    2338:	4c 91       	ld	r20, X
    233a:	56 97       	sbiw	r26, 0x16	; 22
    233c:	42 30       	cpi	r20, 0x02	; 2
    233e:	e1 f0       	breq	.+56     	; 0x2378 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x4a>
    2340:	43 30       	cpi	r20, 0x03	; 3
    2342:	91 f1       	breq	.+100    	; 0x23a8 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x7a>
    2344:	41 30       	cpi	r20, 0x01	; 1
    2346:	59 f5       	brne	.+86     	; 0x239e <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x70>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:808
  case 1:
    // 90 degree rotation, swap x & y for rotation,
    // then invert x and adjust x for h (now to become w)
    bSwap = true;
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
    2348:	14 96       	adiw	r26, 0x04	; 4
    234a:	4d 91       	ld	r20, X+
    234c:	5c 91       	ld	r21, X
    234e:	da 01       	movw	r26, r20
    2350:	ae 1b       	sub	r26, r30
    2352:	bf 0b       	sbc	r27, r31
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:809
    x -= (h - 1);
    2354:	fd 01       	movw	r30, r26
    2356:	e2 1b       	sub	r30, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:751
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w,
                                             uint16_t color) {

  if ((y >= 0) && (y < HEIGHT)) { // Y coord in bounds?
    2358:	f3 0b       	sbc	r31, r19
drawFastHLineInternal():
    235a:	77 fd       	sbrc	r23, 7
    235c:	0a c0       	rjmp	.+20     	; 0x2372 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x44>
    235e:	dc 01       	movw	r26, r24
    2360:	16 96       	adiw	r26, 0x06	; 6
    2362:	4d 91       	ld	r20, X+
    2364:	5c 91       	ld	r21, X
    2366:	64 17       	cp	r22, r20
    2368:	75 07       	cpc	r23, r21
    236a:	1c f4       	brge	.+6      	; 0x2372 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x44>
    236c:	ab 01       	movw	r20, r22
    236e:	bf 01       	movw	r22, r30
    2370:	76 df       	rcall	.-276    	; 0x225e <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]>
drawFastVLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:829

  if (bSwap)
    drawFastHLineInternal(x, y, h, color);
  else
    drawFastVLineInternal(x, y, h, color);
}
    2372:	1f 91       	pop	r17
    2374:	0f 91       	pop	r16
    2376:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:813
    x = WIDTH - x - 1;
    x -= (h - 1);
    break;
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
    2378:	14 96       	adiw	r26, 0x04	; 4
    237a:	4d 91       	ld	r20, X+
    237c:	5c 91       	ld	r21, X
    237e:	da 01       	movw	r26, r20
    2380:	a6 1b       	sub	r26, r22
    2382:	b7 0b       	sbc	r27, r23
    2384:	bd 01       	movw	r22, r26
    2386:	61 50       	subi	r22, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:814
    y = HEIGHT - y - 1;
    2388:	71 09       	sbc	r23, r1
    238a:	dc 01       	movw	r26, r24
    238c:	16 96       	adiw	r26, 0x06	; 6
    238e:	4d 91       	ld	r20, X+
    2390:	5c 91       	ld	r21, X
    2392:	da 01       	movw	r26, r20
    2394:	ae 1b       	sub	r26, r30
    2396:	bf 0b       	sbc	r27, r31
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:815
    y -= (h - 1);
    2398:	fd 01       	movw	r30, r26
    239a:	e2 1b       	sub	r30, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:850
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y,
                                             int16_t __h, uint16_t color) {

  if ((x >= 0) && (x < WIDTH)) { // X coord in bounds?
    239c:	f3 0b       	sbc	r31, r19
drawFastVLineInternal():
    239e:	77 fd       	sbrc	r23, 7
    23a0:	e8 cf       	rjmp	.-48     	; 0x2372 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x44>
    23a2:	af 01       	movw	r20, r30
    23a4:	ad de       	rcall	.-678    	; 0x2100 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]>
    23a6:	e5 cf       	rjmp	.-54     	; 0x2372 <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x44>
drawFastVLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:821
    break;
  case 3:
    // 270 degree rotation, swap x & y for rotation, then invert y
    bSwap = true;
    ssd1306_swap(x, y);
    y = HEIGHT - y - 1;
    23a8:	16 96       	adiw	r26, 0x06	; 6
    23aa:	4d 91       	ld	r20, X+
    23ac:	5c 91       	ld	r21, X
    23ae:	da 01       	movw	r26, r20
    23b0:	a6 1b       	sub	r26, r22
    23b2:	b7 0b       	sbc	r27, r23
    23b4:	bd 01       	movw	r22, r26
    23b6:	61 50       	subi	r22, 0x01	; 1
    23b8:	71 09       	sbc	r23, r1
    23ba:	cf cf       	rjmp	.-98     	; 0x235a <Adafruit_SSD1306::drawFastVLine(int, int, int, unsigned int)+0x2c>

000023bc <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)>:
drawFastHLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:700
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w,
                                     uint16_t color) {
    23bc:	0f 93       	push	r16
    23be:	1f 93       	push	r17
    23c0:	fa 01       	movw	r30, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:702
  bool bSwap = false;
  switch (rotation) {
    23c2:	dc 01       	movw	r26, r24
    23c4:	56 96       	adiw	r26, 0x16	; 22
    23c6:	4c 91       	ld	r20, X
    23c8:	56 97       	sbiw	r26, 0x16	; 22
    23ca:	42 30       	cpi	r20, 0x02	; 2
    23cc:	a1 f0       	breq	.+40     	; 0x23f6 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x3a>
    23ce:	43 30       	cpi	r20, 0x03	; 3
    23d0:	81 f1       	breq	.+96     	; 0x2432 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x76>
    23d2:	41 30       	cpi	r20, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:707
  case 1:
    // 90 degree rotation, swap x & y for rotation, then invert x
    bSwap = true;
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
    23d4:	11 f5       	brne	.+68     	; 0x241a <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x5e>
    23d6:	14 96       	adiw	r26, 0x04	; 4
    23d8:	4d 91       	ld	r20, X+
    23da:	5c 91       	ld	r21, X
    23dc:	da 01       	movw	r26, r20
    23de:	ae 1b       	sub	r26, r30
    23e0:	bf 0b       	sbc	r27, r31
    23e2:	fd 01       	movw	r30, r26
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:850
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y,
                                             int16_t __h, uint16_t color) {

  if ((x >= 0) && (x < WIDTH)) { // X coord in bounds?
    23e4:	31 97       	sbiw	r30, 0x01	; 1
drawFastVLineInternal():
    23e6:	f7 fd       	sbrc	r31, 7
    23e8:	03 c0       	rjmp	.+6      	; 0x23f0 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x34>
    23ea:	ab 01       	movw	r20, r22
    23ec:	bf 01       	movw	r22, r30
    23ee:	88 de       	rcall	.-752    	; 0x2100 <Adafruit_SSD1306::drawFastVLineInternal(int, int, int, unsigned int) [clone .part.8]>
drawFastHLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:729

  if (bSwap)
    drawFastVLineInternal(x, y, w, color);
  else
    drawFastHLineInternal(x, y, w, color);
}
    23f0:	1f 91       	pop	r17
    23f2:	0f 91       	pop	r16
    23f4:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:712
    x = WIDTH - x - 1;
    break;
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    23f6:	16 96       	adiw	r26, 0x06	; 6
    23f8:	4d 91       	ld	r20, X+
    23fa:	5c 91       	ld	r21, X
    23fc:	da 01       	movw	r26, r20
    23fe:	ae 1b       	sub	r26, r30
    2400:	bf 0b       	sbc	r27, r31
    2402:	fd 01       	movw	r30, r26
    2404:	31 97       	sbiw	r30, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:711
    ssd1306_swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    // 180 degree rotation, invert x and y, then shift y around for height.
    x = WIDTH - x - 1;
    2406:	dc 01       	movw	r26, r24
    2408:	14 96       	adiw	r26, 0x04	; 4
    240a:	4d 91       	ld	r20, X+
    240c:	5c 91       	ld	r21, X
    240e:	da 01       	movw	r26, r20
    2410:	a6 1b       	sub	r26, r22
    2412:	b7 0b       	sbc	r27, r23
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:713
    y = HEIGHT - y - 1;
    x -= (w - 1);
    2414:	bd 01       	movw	r22, r26
    2416:	62 1b       	sub	r22, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:751
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w,
                                             uint16_t color) {

  if ((y >= 0) && (y < HEIGHT)) { // Y coord in bounds?
    2418:	73 0b       	sbc	r23, r19
drawFastHLineInternal():
    241a:	f7 fd       	sbrc	r31, 7
    241c:	e9 cf       	rjmp	.-46     	; 0x23f0 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x34>
    241e:	dc 01       	movw	r26, r24
    2420:	16 96       	adiw	r26, 0x06	; 6
    2422:	4d 91       	ld	r20, X+
    2424:	5c 91       	ld	r21, X
    2426:	e4 17       	cp	r30, r20
    2428:	f5 07       	cpc	r31, r21
    242a:	14 f7       	brge	.-60     	; 0x23f0 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x34>
    242c:	af 01       	movw	r20, r30
    242e:	17 df       	rcall	.-466    	; 0x225e <Adafruit_SSD1306::drawFastHLineInternal(int, int, int, unsigned int) [clone .part.7]>
    2430:	df cf       	rjmp	.-66     	; 0x23f0 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x34>
drawFastHLine():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:720
  case 3:
    // 270 degree rotation, swap x & y for rotation,
    // then invert y and adjust y for w (not to become h)
    bSwap = true;
    ssd1306_swap(x, y);
    y = HEIGHT - y - 1;
    2432:	16 96       	adiw	r26, 0x06	; 6
    2434:	4d 91       	ld	r20, X+
    2436:	5c 91       	ld	r21, X
    2438:	da 01       	movw	r26, r20
    243a:	a6 1b       	sub	r26, r22
    243c:	b7 0b       	sbc	r27, r23
    243e:	bd 01       	movw	r22, r26
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:721
    y -= (w - 1);
    2440:	62 1b       	sub	r22, r18
    2442:	73 0b       	sbc	r23, r19
    2444:	d0 cf       	rjmp	.-96     	; 0x23e6 <Adafruit_SSD1306::drawFastHLine(int, int, int, unsigned int)+0x2a>

00002446 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)>:
drawPixel():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:641
    @return None (void).
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
    2446:	fc 01       	movw	r30, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:642
  if ((x >= 0) && (x < width()) && (y >= 0) && (y < height())) {
    2448:	77 fd       	sbrc	r23, 7
    244a:	64 c0       	rjmp	.+200    	; 0x2514 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xce>
    244c:	80 85       	ldd	r24, Z+8	; 0x08
    244e:	91 85       	ldd	r25, Z+9	; 0x09
    2450:	68 17       	cp	r22, r24
    2452:	79 07       	cpc	r23, r25
    2454:	0c f0       	brlt	.+2      	; 0x2458 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x12>
    2456:	5e c0       	rjmp	.+188    	; 0x2514 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xce>
    2458:	57 fd       	sbrc	r21, 7
    245a:	5c c0       	rjmp	.+184    	; 0x2514 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xce>
    245c:	82 85       	ldd	r24, Z+10	; 0x0a
    245e:	93 85       	ldd	r25, Z+11	; 0x0b
    2460:	48 17       	cp	r20, r24
    2462:	59 07       	cpc	r21, r25
    2464:	0c f0       	brlt	.+2      	; 0x2468 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x22>
    2466:	56 c0       	rjmp	.+172    	; 0x2514 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xce>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:644
    // Pixel is in-bounds. Rotate coordinates if needed.
    switch (getRotation()) {
    2468:	86 89       	ldd	r24, Z+22	; 0x16
    246a:	82 30       	cpi	r24, 0x02	; 2
    246c:	b1 f0       	breq	.+44     	; 0x249a <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x54>
    246e:	83 30       	cpi	r24, 0x03	; 3
    2470:	29 f1       	breq	.+74     	; 0x24bc <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x76>
    2472:	81 30       	cpi	r24, 0x01	; 1
    2474:	41 f4       	brne	.+16     	; 0x2486 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x40>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:647
    case 1:
      ssd1306_swap(x, y);
      x = WIDTH - x - 1;
    2476:	84 81       	ldd	r24, Z+4	; 0x04
    2478:	95 81       	ldd	r25, Z+5	; 0x05
    247a:	84 1b       	sub	r24, r20
    247c:	95 0b       	sbc	r25, r21
    247e:	ab 01       	movw	r20, r22
    2480:	bc 01       	movw	r22, r24
    2482:	61 50       	subi	r22, 0x01	; 1
    2484:	71 09       	sbc	r23, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:658
    case 3:
      ssd1306_swap(x, y);
      y = HEIGHT - y - 1;
      break;
    }
    switch (color) {
    2486:	21 30       	cpi	r18, 0x01	; 1
    2488:	31 05       	cpc	r19, r1
    248a:	09 f1       	breq	.+66     	; 0x24ce <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x88>
    248c:	08 f4       	brcc	.+2      	; 0x2490 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x4a>
    248e:	43 c0       	rjmp	.+134    	; 0x2516 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xd0>
    2490:	22 30       	cpi	r18, 0x02	; 2
    2492:	31 05       	cpc	r19, r1
    2494:	09 f4       	brne	.+2      	; 0x2498 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x52>
    2496:	63 c0       	rjmp	.+198    	; 0x255e <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x118>
    2498:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:650
    case 1:
      ssd1306_swap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      x = WIDTH - x - 1;
    249a:	84 81       	ldd	r24, Z+4	; 0x04
    249c:	95 81       	ldd	r25, Z+5	; 0x05
    249e:	dc 01       	movw	r26, r24
    24a0:	a6 1b       	sub	r26, r22
    24a2:	b7 0b       	sbc	r27, r23
    24a4:	bd 01       	movw	r22, r26
    24a6:	61 50       	subi	r22, 0x01	; 1
    24a8:	71 09       	sbc	r23, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:651
      y = HEIGHT - y - 1;
    24aa:	86 81       	ldd	r24, Z+6	; 0x06
    24ac:	97 81       	ldd	r25, Z+7	; 0x07
    24ae:	dc 01       	movw	r26, r24
    24b0:	a4 1b       	sub	r26, r20
    24b2:	b5 0b       	sbc	r27, r21
    24b4:	ad 01       	movw	r20, r26
    24b6:	41 50       	subi	r20, 0x01	; 1
    24b8:	51 09       	sbc	r21, r1
    24ba:	e5 cf       	rjmp	.-54     	; 0x2486 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x40>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:655
      break;
    case 3:
      ssd1306_swap(x, y);
      y = HEIGHT - y - 1;
    24bc:	86 81       	ldd	r24, Z+6	; 0x06
    24be:	97 81       	ldd	r25, Z+7	; 0x07
    24c0:	86 1b       	sub	r24, r22
    24c2:	97 0b       	sbc	r25, r23
    24c4:	ba 01       	movw	r22, r20
    24c6:	ac 01       	movw	r20, r24
    24c8:	41 50       	subi	r20, 0x01	; 1
    24ca:	51 09       	sbc	r21, r1
    24cc:	dc cf       	rjmp	.-72     	; 0x2486 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x40>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:660
      break;
    }
    switch (color) {
    case SSD1306_WHITE:
      buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
    24ce:	ca 01       	movw	r24, r20
    24d0:	57 fd       	sbrc	r21, 7
    24d2:	07 96       	adiw	r24, 0x07	; 7
    24d4:	a3 e0       	ldi	r26, 0x03	; 3
    24d6:	95 95       	asr	r25
    24d8:	87 95       	ror	r24
    24da:	aa 95       	dec	r26
    24dc:	e1 f7       	brne	.-8      	; 0x24d6 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x90>
    24de:	a4 81       	ldd	r26, Z+4	; 0x04
    24e0:	b5 81       	ldd	r27, Z+5	; 0x05
    24e2:	8a 9f       	mul	r24, r26
    24e4:	90 01       	movw	r18, r0
    24e6:	8b 9f       	mul	r24, r27
    24e8:	30 0d       	add	r19, r0
    24ea:	9a 9f       	mul	r25, r26
    24ec:	30 0d       	add	r19, r0
    24ee:	11 24       	eor	r1, r1
    24f0:	62 0f       	add	r22, r18
    24f2:	73 1f       	adc	r23, r19
    24f4:	07 8c       	ldd	r0, Z+31	; 0x1f
    24f6:	f0 a1       	ldd	r31, Z+32	; 0x20
    24f8:	e0 2d       	mov	r30, r0
    24fa:	e6 0f       	add	r30, r22
    24fc:	f7 1f       	adc	r31, r23
    24fe:	47 70       	andi	r20, 0x07	; 7
    2500:	55 27       	eor	r21, r21
    2502:	21 e0       	ldi	r18, 0x01	; 1
    2504:	30 e0       	ldi	r19, 0x00	; 0
    2506:	01 c0       	rjmp	.+2      	; 0x250a <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xc4>
    2508:	22 0f       	add	r18, r18
    250a:	4a 95       	dec	r20
    250c:	ea f7       	brpl	.-6      	; 0x2508 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xc2>
    250e:	80 81       	ld	r24, Z
    2510:	82 2b       	or	r24, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:666
      break;
    case SSD1306_BLACK:
      buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));
      break;
    case SSD1306_INVERSE:
      buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
    2512:	80 83       	st	Z, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:670
      break;
    }
  }
}
    2514:	08 95       	ret
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:663
    switch (color) {
    case SSD1306_WHITE:
      buffer[x + (y / 8) * WIDTH] |= (1 << (y & 7));
      break;
    case SSD1306_BLACK:
      buffer[x + (y / 8) * WIDTH] &= ~(1 << (y & 7));
    2516:	ca 01       	movw	r24, r20
    2518:	57 fd       	sbrc	r21, 7
    251a:	07 96       	adiw	r24, 0x07	; 7
    251c:	33 e0       	ldi	r19, 0x03	; 3
    251e:	95 95       	asr	r25
    2520:	87 95       	ror	r24
    2522:	3a 95       	dec	r19
    2524:	e1 f7       	brne	.-8      	; 0x251e <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xd8>
    2526:	a4 81       	ldd	r26, Z+4	; 0x04
    2528:	b5 81       	ldd	r27, Z+5	; 0x05
    252a:	8a 9f       	mul	r24, r26
    252c:	90 01       	movw	r18, r0
    252e:	8b 9f       	mul	r24, r27
    2530:	30 0d       	add	r19, r0
    2532:	9a 9f       	mul	r25, r26
    2534:	30 0d       	add	r19, r0
    2536:	11 24       	eor	r1, r1
    2538:	62 0f       	add	r22, r18
    253a:	73 1f       	adc	r23, r19
    253c:	07 8c       	ldd	r0, Z+31	; 0x1f
    253e:	f0 a1       	ldd	r31, Z+32	; 0x20
    2540:	e0 2d       	mov	r30, r0
    2542:	e6 0f       	add	r30, r22
    2544:	f7 1f       	adc	r31, r23
    2546:	47 70       	andi	r20, 0x07	; 7
    2548:	55 27       	eor	r21, r21
    254a:	81 e0       	ldi	r24, 0x01	; 1
    254c:	90 e0       	ldi	r25, 0x00	; 0
    254e:	01 c0       	rjmp	.+2      	; 0x2552 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x10c>
    2550:	88 0f       	add	r24, r24
    2552:	4a 95       	dec	r20
    2554:	ea f7       	brpl	.-6      	; 0x2550 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x10a>
    2556:	80 95       	com	r24
    2558:	90 81       	ld	r25, Z
    255a:	89 23       	and	r24, r25
    255c:	da cf       	rjmp	.-76     	; 0x2512 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xcc>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:666
      break;
    case SSD1306_INVERSE:
      buffer[x + (y / 8) * WIDTH] ^= (1 << (y & 7));
    255e:	ca 01       	movw	r24, r20
    2560:	57 fd       	sbrc	r21, 7
    2562:	07 96       	adiw	r24, 0x07	; 7
    2564:	23 e0       	ldi	r18, 0x03	; 3
    2566:	95 95       	asr	r25
    2568:	87 95       	ror	r24
    256a:	2a 95       	dec	r18
    256c:	e1 f7       	brne	.-8      	; 0x2566 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x120>
    256e:	a4 81       	ldd	r26, Z+4	; 0x04
    2570:	b5 81       	ldd	r27, Z+5	; 0x05
    2572:	8a 9f       	mul	r24, r26
    2574:	90 01       	movw	r18, r0
    2576:	8b 9f       	mul	r24, r27
    2578:	30 0d       	add	r19, r0
    257a:	9a 9f       	mul	r25, r26
    257c:	30 0d       	add	r19, r0
    257e:	11 24       	eor	r1, r1
    2580:	62 0f       	add	r22, r18
    2582:	73 1f       	adc	r23, r19
    2584:	07 8c       	ldd	r0, Z+31	; 0x1f
    2586:	f0 a1       	ldd	r31, Z+32	; 0x20
    2588:	e0 2d       	mov	r30, r0
    258a:	e6 0f       	add	r30, r22
    258c:	f7 1f       	adc	r31, r23
    258e:	47 70       	andi	r20, 0x07	; 7
    2590:	55 27       	eor	r21, r21
    2592:	21 e0       	ldi	r18, 0x01	; 1
    2594:	30 e0       	ldi	r19, 0x00	; 0
    2596:	01 c0       	rjmp	.+2      	; 0x259a <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x154>
    2598:	22 0f       	add	r18, r18
    259a:	4a 95       	dec	r20
    259c:	ea f7       	brpl	.-6      	; 0x2598 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0x152>
    259e:	80 81       	ld	r24, Z
    25a0:	82 27       	eor	r24, r18
    25a2:	b7 cf       	rjmp	.-146    	; 0x2512 <Adafruit_SSD1306::drawPixel(int, int, unsigned int)+0xcc>

000025a4 <TwoWire::endTransmission()>:
endTransmission():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:518
    25a4:	61 e0       	ldi	r22, 0x01	; 1
    25a6:	08 96       	adiw	r24, 0x08	; 8
    25a8:	0c 94 e6 08 	jmp	0x11cc	; 0x11cc <TWI_MasterWrite>

000025ac <Print::flush()>:
flush():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.h:95
    size_t println(void);

    int16_t printf(const char *format, ...) __attribute__ ((format (printf, 2, 3)));
    int16_t printf(const __FlashStringHelper *format, ...);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
    25ac:	08 95       	ret

000025ae <Print::availableForWrite()>:
availableForWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	80 e0       	ldi	r24, 0x00	; 0
    25b2:	08 95       	ret

000025b4 <SPIClass::endTransaction()>:
endTransaction():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:563
  }
  in_transaction = 1;
  config(settings);
}

void SPIClass::endTransaction(void) {
    25b4:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:564
  if (in_transaction) {
    25b6:	82 85       	ldd	r24, Z+10	; 0x0a
    25b8:	88 23       	and	r24, r24
    25ba:	31 f0       	breq	.+12     	; 0x25c8 <SPIClass::endTransaction()+0x14>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:565
    in_transaction = 0;
    25bc:	12 86       	std	Z+10, r1	; 0x0a
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:566
    if (interruptMode != SPI_IMODE_NONE) {
    25be:	80 85       	ldd	r24, Z+8	; 0x08
    25c0:	88 23       	and	r24, r24
    25c2:	11 f0       	breq	.+4      	; 0x25c8 <SPIClass::endTransaction()+0x14>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:567
      SREG = old_sreg;
    25c4:	81 85       	ldd	r24, Z+9	; 0x09
    25c6:	8f bf       	out	0x3f, r24	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:570
    }
  }
}
    25c8:	08 95       	ret

000025ca <SPIClass::beginTransaction(SPISettings)>:
beginTransaction():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:554
    return;
  }
  interruptMode = SPI_IMODE_NONE;
}

void SPIClass::beginTransaction(SPISettings settings) {
    25ca:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:555
  if (interruptMode != SPI_IMODE_NONE) {
    25cc:	80 85       	ldd	r24, Z+8	; 0x08
    25ce:	88 23       	and	r24, r24
    25d0:	19 f0       	breq	.+6      	; 0x25d8 <SPIClass::beginTransaction(SPISettings)+0xe>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:556
    old_sreg = SREG;
    25d2:	8f b7       	in	r24, 0x3f	; 63
    25d4:	81 87       	std	Z+9, r24	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:557
    cli(); // NoInterrupts();
    25d6:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:559
  }
  in_transaction = 1;
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	82 87       	std	Z+10, r24	; 0x0a
config():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:385
  #endif
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI_MODULE.CTRLA = settings.ctrla;
    25dc:	60 93 40 09 	sts	0x0940, r22	; 0x800940 <__TEXT_REGION_LENGTH__+0x7f0940>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:386
  SPI_MODULE.CTRLB = settings.ctrlb;
    25e0:	70 93 41 09 	sts	0x0941, r23	; 0x800941 <__TEXT_REGION_LENGTH__+0x7f0941>
beginTransaction():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:561
    old_sreg = SREG;
    cli(); // NoInterrupts();
  }
  in_transaction = 1;
  config(settings);
}
    25e4:	08 95       	ret

000025e6 <SPIClass::begin()>:
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:332
    }
  #endif
  return false;
}

void SPIClass::begin() {
    25e6:	cf 93       	push	r28
    25e8:	df 93       	push	r29
    25ea:	fc 01       	movw	r30, r24
init():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:370
  // We don't call this now because we are about to call config which does the same thing.
  config(DEFAULT_SPI_SETTINGS);
}

void SPIClass::init() {
  if (initialized)
    25ec:	87 81       	ldd	r24, Z+7	; 0x07
    25ee:	81 11       	cpse	r24, r1
    25f0:	06 c0       	rjmp	.+12     	; 0x25fe <SPIClass::begin()+0x18>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:372
    return;
  interruptMode = SPI_IMODE_NONE;
    25f2:	10 86       	std	Z+8, r1	; 0x08
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:378
  #ifdef CORE_ATTACH_OLD
  interruptSave = 0;
  interruptMask_lo = 0;
  interruptMask_hi = 0;
  #else
  in_transaction = 0;
    25f4:	12 86       	std	Z+10, r1	; 0x0a
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:379
  old_sreg = 0x80;
    25f6:	80 e8       	ldi	r24, 0x80	; 128
    25f8:	81 87       	std	Z+9, r24	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:381
  #endif
  initialized = true;
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	87 83       	std	Z+7, r24	; 0x07
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:339
  #if !defined(SPI1)
    // Implementation for tinyAVR 0/1/2-series, megaAVR 0-series and AVR DD-series, which only have a single SPI interface.
    // First, configure PORTMUX.
    #if defined(PORTMUX_SPIROUTEA)
      // AVR DD-series, tinyAVR 2-series
      PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & ~PORTMUX_SPI0_gm);
    25fe:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7f05e5>
    2602:	88 7f       	andi	r24, 0xF8	; 248
    2604:	96 81       	ldd	r25, Z+6	; 0x06
    2606:	89 2b       	or	r24, r25
    2608:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7f05e5>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:361
      // we're set to use SPI1
      PORTMUX.SPIROUTEA = _uc_mux | (PORTMUX.SPIROUTEA & (~PORTMUX_SPI1_gm));
    }
  #endif
  // no matter what we had to do about the mux; MOSI and SCK need to be set output - but now we set that up already instead of doing it here.
  pinMode(_uc_pinSCK,  OUTPUT);
    260c:	84 81       	ldd	r24, Z+4	; 0x04
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    260e:	8c 31       	cpi	r24, 0x1C	; 28
    2610:	90 f4       	brcc	.+36     	; 0x2636 <SPIClass::begin()+0x50>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
    2612:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    2614:	dc 01       	movw	r26, r24
    2616:	ae 5e       	subi	r26, 0xEE	; 238
    2618:	bd 49       	sbci	r27, 0x9D	; 157
    261a:	2c 91       	ld	r18, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    261c:	2f 3f       	cpi	r18, 0xFF	; 255
    261e:	59 f0       	breq	.+22     	; 0x2636 <SPIClass::begin()+0x50>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    2620:	82 5d       	subi	r24, 0xD2	; 210
    2622:	9d 49       	sbci	r25, 0x9D	; 157
    2624:	ec 01       	movw	r28, r24
    2626:	a8 81       	ld	r26, Y
    2628:	d0 e2       	ldi	r29, 0x20	; 32
    262a:	ad 9f       	mul	r26, r29
    262c:	d0 01       	movw	r26, r0
    262e:	11 24       	eor	r1, r1
    2630:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    2632:	11 96       	adiw	r26, 0x01	; 1
    2634:	2c 93       	st	X, r18
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:362
  pinMode(_uc_pinMOSI, OUTPUT);
    2636:	83 81       	ldd	r24, Z+3	; 0x03
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    2638:	8c 31       	cpi	r24, 0x1C	; 28
    263a:	88 f4       	brcc	.+34     	; 0x265e <SPIClass::begin()+0x78>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    263c:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    263e:	fc 01       	movw	r30, r24
    2640:	ee 5e       	subi	r30, 0xEE	; 238
    2642:	fd 49       	sbci	r31, 0x9D	; 157
    2644:	20 81       	ld	r18, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    2646:	2f 3f       	cpi	r18, 0xFF	; 255
    2648:	51 f0       	breq	.+20     	; 0x265e <SPIClass::begin()+0x78>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    264a:	82 5d       	subi	r24, 0xD2	; 210
    264c:	9d 49       	sbci	r25, 0x9D	; 157
    264e:	dc 01       	movw	r26, r24
    2650:	ec 91       	ld	r30, X
    2652:	b0 e2       	ldi	r27, 0x20	; 32
    2654:	eb 9f       	mul	r30, r27
    2656:	f0 01       	movw	r30, r0
    2658:	11 24       	eor	r1, r1
    265a:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    265c:	21 83       	std	Z+1, r18	; 0x01
    265e:	90 91 35 64 	lds	r25, 0x6435	; 0x806435 <DEFAULT_SPI_SETTINGS>
    2662:	80 91 36 64 	lds	r24, 0x6436	; 0x806436 <DEFAULT_SPI_SETTINGS+0x1>
config():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:385
  #endif
  initialized = true;
}

void SPIClass::config(SPISettings settings) {
  SPI_MODULE.CTRLA = settings.ctrla;
    2666:	90 93 40 09 	sts	0x0940, r25	; 0x800940 <__TEXT_REGION_LENGTH__+0x7f0940>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:386
  SPI_MODULE.CTRLB = settings.ctrlb;
    266a:	80 93 41 09 	sts	0x0941, r24	; 0x800941 <__TEXT_REGION_LENGTH__+0x7f0941>
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.cpp:367
  pinMode(_uc_pinMOSI, OUTPUT);
  //SPI_MODULE.CTRLB |= (SPI_SSD_bm);
  //SPI_MODULE.CTRLA |= (SPI_ENABLE_bm | SPI_MASTER_bm);
  // We don't call this now because we are about to call config which does the same thing.
  config(DEFAULT_SPI_SETTINGS);
}
    266e:	df 91       	pop	r29
    2670:	cf 91       	pop	r28
    2672:	08 95       	ret

00002674 <Adafruit_SSD1306::clearDisplay() [clone .constprop.47]>:
clearDisplay():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:680
    @note   Changes buffer contents only, no immediate effect on display.
            Follow up with a call to display(), or with other graphics
            commands as needed by one's own application.
*/
void Adafruit_SSD1306::clearDisplay(void) {
  memset(buffer, 0, WIDTH * ((HEIGHT + 7) / 8));
    2674:	20 91 6f 65 	lds	r18, 0x656F	; 0x80656f <display+0x6>
    2678:	30 91 70 65 	lds	r19, 0x6570	; 0x806570 <display+0x7>
    267c:	c9 01       	movw	r24, r18
    267e:	07 96       	adiw	r24, 0x07	; 7
    2680:	97 fd       	sbrc	r25, 7
    2682:	07 96       	adiw	r24, 0x07	; 7
    2684:	23 e0       	ldi	r18, 0x03	; 3
    2686:	95 95       	asr	r25
    2688:	87 95       	ror	r24
    268a:	2a 95       	dec	r18
    268c:	e1 f7       	brne	.-8      	; 0x2686 <Adafruit_SSD1306::clearDisplay() [clone .constprop.47]+0x12>
    268e:	20 91 6d 65 	lds	r18, 0x656D	; 0x80656d <display+0x4>
    2692:	30 91 6e 65 	lds	r19, 0x656E	; 0x80656e <display+0x5>
    2696:	82 9f       	mul	r24, r18
    2698:	a0 01       	movw	r20, r0
    269a:	83 9f       	mul	r24, r19
    269c:	50 0d       	add	r21, r0
    269e:	92 9f       	mul	r25, r18
    26a0:	50 0d       	add	r21, r0
    26a2:	11 24       	eor	r1, r1
    26a4:	70 e0       	ldi	r23, 0x00	; 0
    26a6:	60 e0       	ldi	r22, 0x00	; 0
    26a8:	80 91 88 65 	lds	r24, 0x6588	; 0x806588 <display+0x1f>
    26ac:	90 91 89 65 	lds	r25, 0x6589	; 0x806589 <display+0x20>
    26b0:	0c 94 cd 27 	jmp	0x4f9a	; 0x4f9a <memset>

000026b4 <digitalWrite>:
digitalWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:209
  default:
    break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
    26b4:	0f 93       	push	r16
    26b6:	1f 93       	push	r17
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:212
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
    26bc:	8c 31       	cpi	r24, 0x1C	; 28
    26be:	08 f0       	brcs	.+2      	; 0x26c2 <digitalWrite+0xe>
    26c0:	b2 c0       	rjmp	.+356    	; 0x2826 <digitalWrite+0x172>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    26c2:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:212
    26c4:	dc 01       	movw	r26, r24
    26c6:	ae 5e       	subi	r26, 0xEE	; 238
    26c8:	bd 49       	sbci	r27, 0x9D	; 157
    26ca:	2c 91       	ld	r18, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:213
  if (bit_mask == NOT_A_PIN) {
    26cc:	2f 3f       	cpi	r18, 0xFF	; 255
    26ce:	09 f4       	brne	.+2      	; 0x26d2 <digitalWrite+0x1e>
    26d0:	aa c0       	rjmp	.+340    	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:218
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
    26d2:	8c 01       	movw	r16, r24
    26d4:	02 5d       	subi	r16, 0xD2	; 210
    26d6:	1d 49       	sbci	r17, 0x9D	; 157
    26d8:	e8 01       	movw	r28, r16
    26da:	e8 81       	ld	r30, Y
    26dc:	d0 e2       	ldi	r29, 0x20	; 32
    26de:	ed 9f       	mul	r30, r29
    26e0:	f0 01       	movw	r30, r0
    26e2:	11 24       	eor	r1, r1
    26e4:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    26e6:	61 11       	cpse	r22, r1
    26e8:	32 c0       	rjmp	.+100    	; 0x274e <digitalWrite+0x9a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
    26ea:	26 83       	std	Z+6, r18	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
    26ec:	30 81       	ld	r19, Z
    26ee:	23 23       	and	r18, r19
    26f0:	ac 01       	movw	r20, r24
    26f2:	4a 50       	subi	r20, 0x0A	; 10
    26f4:	5e 49       	sbci	r21, 0x9E	; 158
    26f6:	21 11       	cpse	r18, r1
    26f8:	11 c0       	rjmp	.+34     	; 0x271c <digitalWrite+0x68>
    26fa:	ea 01       	movw	r28, r20
    26fc:	28 81       	ld	r18, Y
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    26fe:	30 97       	sbiw	r30, 0x00	; 0
    2700:	79 f1       	breq	.+94     	; 0x2760 <digitalWrite+0xac>
    2702:	28 30       	cpi	r18, 0x08	; 8
    2704:	68 f5       	brcc	.+90     	; 0x2760 <digitalWrite+0xac>
    2706:	70 96       	adiw	r30, 0x10	; 16
    2708:	e2 0f       	add	r30, r18
    270a:	f1 1d       	adc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:264

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    270c:	3f b7       	in	r19, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:265
    cli();
    270e:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:269

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    2710:	20 81       	ld	r18, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:267

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
    2712:	61 11       	cpse	r22, r1
    2714:	28 c0       	rjmp	.+80     	; 0x2766 <digitalWrite+0xb2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    2716:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    2718:	20 83       	st	Z, r18
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
    271a:	3f bf       	out	0x3f, r19	; 63
digitalPinToTimerNow():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:531
  badCall("Resuming core control of type D timer not supported.");
}
#endif

uint8_t digitalPinToTimerNow(uint8_t p) {
  uint8_t bit_pos = digitalPinToBitPosition(p);
    271c:	fa 01       	movw	r30, r20
    271e:	30 81       	ld	r19, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:532
  if (bit_pos == NOT_A_PIN) return NOT_ON_TIMER;     /* Use bit position to check for invalid pins */
    2720:	3f 3f       	cpi	r19, 0xFF	; 255
    2722:	09 f4       	brne	.+2      	; 0x2726 <digitalWrite+0x72>
    2724:	80 c0       	rjmp	.+256    	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:533
  uint8_t port = digitalPinToPort(p);                /* If bit_pos is valid, port will be too      */
    2726:	e8 01       	movw	r28, r16
    2728:	28 81       	ld	r18, Y
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:534
  if ( bit_pos < 6) {                                /* SPLIT MODE TCA output is on pins 0-5       */
    272a:	36 30       	cpi	r19, 0x06	; 6
    272c:	f0 f4       	brcc	.+60     	; 0x276a <digitalWrite+0xb6>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:550
        return TIMERA1;                              /* mux options, not 3-channel ones on bit 4:6 */
      }
    }
  #elif defined(TCA0)
    if (__PeripheralControl & TIMERA0) {               /* here we don't need to store tcamux */
      if ((PORTMUX.TCAROUTEA & PORTMUX_TCA0_gm) == port) { /* because it is only used once */
    272e:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
    2732:	37 70       	andi	r19, 0x07	; 7
    2734:	23 13       	cpse	r18, r19
    2736:	19 c0       	rjmp	.+50     	; 0x276a <digitalWrite+0xb6>
turnOffPWM():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    2738:	ec 91       	ld	r30, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:128
  switch (timer) {

  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
    273a:	e5 30       	cpi	r30, 0x05	; 5
    273c:	08 f0       	brcs	.+2      	; 0x2740 <digitalWrite+0x8c>
    273e:	ee 0f       	add	r30, r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:130
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    2740:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
    2744:	e0 95       	com	r30
    2746:	e8 23       	and	r30, r24
    2748:	e0 93 01 0a 	sts	0x0A01, r30	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
    274c:	6c c0       	rjmp	.+216    	; 0x2826 <digitalWrite+0x172>
digitalWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:228
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
  } else if (val == CHANGE) { /* If TOGGLE
    274e:	64 30       	cpi	r22, 0x04	; 4
    2750:	29 f4       	brne	.+10     	; 0x275c <digitalWrite+0xa8>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:235
     * we need to know if it's been set high or low
     * otherwise the pullup state could get out of
     * sync with the output bit. Annoying! But we should
     * have to read it before writing OUTTGL, since that can
     * have a 1 clock delay. So read first + invert */
    val = !(port->OUT & bit_mask);
    2752:	34 81       	ldd	r19, Z+4	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:236
    port->OUTTGL = bit_mask;
    2754:	27 83       	std	Z+7, r18	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:241
    // Now, for the pullup setting part below
    // we need to know if it's been set high or low
    // otherwise the pullup state could get out of
    // sync with the output bit. Annoying!
    val = port->OUT & bit_mask;
    2756:	64 81       	ldd	r22, Z+4	; 0x04
    2758:	62 23       	and	r22, r18
    275a:	c8 cf       	rjmp	.-112    	; 0x26ec <digitalWrite+0x38>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
    275c:	25 83       	std	Z+5, r18	; 0x05
    275e:	c6 cf       	rjmp	.-116    	; 0x26ec <digitalWrite+0x38>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    2760:	f0 e0       	ldi	r31, 0x00	; 0
    2762:	e0 e0       	ldi	r30, 0x00	; 0
    2764:	d3 cf       	rjmp	.-90     	; 0x270c <digitalWrite+0x58>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    2766:	28 60       	ori	r18, 0x08	; 8
    2768:	d7 cf       	rjmp	.-82     	; 0x2718 <digitalWrite+0x64>
digitalPinToTimerNow():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:564
     * TCE and WEX will move much like a TCA, as a whole
     * Not like TCA channels on tiny, or TCB channels.
     */
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
    276a:	8a 54       	subi	r24, 0x4A	; 74
    276c:	9e 49       	sbci	r25, 0x9E	; 158
    276e:	fc 01       	movw	r30, r24
    2770:	80 81       	ld	r24, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:567
  #if defined(TCD0)
    if ( __PeripheralControl & TIMERD0) {
      if (timer & TIMERD0) {
    2772:	86 ff       	sbrs	r24, 6
    2774:	42 c0       	rjmp	.+132    	; 0x27fa <digitalWrite+0x146>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:568
        byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
    2776:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
    277a:	97 70       	andi	r25, 0x07	; 7
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:567
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
  #if defined(TCD0)
    if ( __PeripheralControl & TIMERD0) {
      if (timer & TIMERD0) {
    277c:	48 2f       	mov	r20, r24
    277e:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:569
        byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
        if (tcdmux == (timer & ~TIMERD0)) {
    2780:	4f 7b       	andi	r20, 0xBF	; 191
    2782:	94 17       	cp	r25, r20
    2784:	15 06       	cpc	r1, r21
    2786:	c9 f5       	brne	.+114    	; 0x27fa <digitalWrite+0x146>
turnOffPWM():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    2788:	ec 91       	ld	r30, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:169
        uint8_t fcset = TCD0.FAULTCTRL & (bit_mask == 0x02 ? 0x80 : 0x40 );
      #else
        // on the DA series, it could be any of them
        #if !defined(ERRATA_TCD_PORTMUX) || ERRATA_TCD_PORTMUX == 0
          //                                Px4-Px7
          uint8_t fcset = TCD0.FAULTCTRL & (bit_mask > 0x0F ? bit_mask : bit_mask << 4 ); // hopefully that gets rendereed as swap, not 4 leftshifts
    278a:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
    278e:	9e 2f       	mov	r25, r30
    2790:	e0 31       	cpi	r30, 0x10	; 16
    2792:	10 f4       	brcc	.+4      	; 0x2798 <digitalWrite+0xe4>
    2794:	92 95       	swap	r25
    2796:	90 7f       	andi	r25, 0xF0	; 240
    2798:	89 23       	and	r24, r25
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:174
        #else
          uint8_t fcset = TCD0.FAULTCTRL & bit_mask;
        #endif
      #endif
      if (fcset) {
    279a:	09 f4       	brne	.+2      	; 0x279e <digitalWrite+0xea>
    279c:	44 c0       	rjmp	.+136    	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:179
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    279e:	c0 e2       	ldi	r28, 0x20	; 32
    27a0:	2c 9f       	mul	r18, r28
    27a2:	90 01       	movw	r18, r0
    27a4:	11 24       	eor	r1, r1
    27a6:	3c 5f       	subi	r19, 0xFC	; 252
    27a8:	e8 30       	cpi	r30, 0x08	; 8
    27aa:	08 f0       	brcs	.+2      	; 0x27ae <digitalWrite+0xfa>
    27ac:	52 c0       	rjmp	.+164    	; 0x2852 <digitalWrite+0x19e>
    27ae:	20 5f       	subi	r18, 0xF0	; 240
    27b0:	3f 4f       	sbci	r19, 0xFF	; 255
    27b2:	e2 0f       	add	r30, r18
    27b4:	f3 2f       	mov	r31, r19
    27b6:	f1 1d       	adc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:188
        // it was currently set to output PWM, so it's very hard to imagine triggering it with just innocent calls to digitalWrite
        // in a constructor - we do not promise core functions will behave if users are reconfiguring peripherals in arbitrary ways.
        // Starting pwm manually (analogWrite won't start it until init starts the timers) in a constructor and then digitalWriting the same pin,
        // when the pin uses TCD0 for PWM is not expected to to produce correct behavior. If you modify the configuration except as described in
        // REF_TCD.md, you must takeOverTCD0() and assume full responsibility for all TCD configuration.
        uint8_t oldSREG = SREG;
    27b8:	4f b7       	in	r20, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:189
        cli();
    27ba:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:190
        TCD0.CTRLA &= ~TCD_ENABLE_bm; // stop the timer
    27bc:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
    27c0:	9e 7f       	andi	r25, 0xFE	; 254
    27c2:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:192
        // Experimentally found ENRDY must be set set to configure FAULTCTRL
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
    27c6:	90 91 8e 0b 	lds	r25, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7f0b8e>
    27ca:	90 ff       	sbrs	r25, 0
    27cc:	fc cf       	rjmp	.-8      	; 0x27c6 <digitalWrite+0x112>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:193
        _PROTECTED_WRITE(TCD0.FAULTCTRL,TCD0.FAULTCTRL & ~fcset);
    27ce:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
    27d2:	90 e0       	ldi	r25, 0x00	; 0
    27d4:	80 95       	com	r24
    27d6:	90 95       	com	r25
    27d8:	30 e0       	ldi	r19, 0x00	; 0
    27da:	82 23       	and	r24, r18
    27dc:	93 23       	and	r25, r19
    27de:	28 ed       	ldi	r18, 0xD8	; 216
    27e0:	24 bf       	out	0x34, r18	; 52
    27e2:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7f0b92>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:195
        // while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA |= TCD_ENABLE_bm;  // re-enable it
    27e6:	80 91 80 0b 	lds	r24, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
    27ea:	81 60       	ori	r24, 0x01	; 1
    27ec:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:197
        #if defined(NO_GLITCH_TIMERD0)
          *pin_ctrl_reg &= ~(PORT_INVEN_bm);
    27f0:	80 81       	ld	r24, Z
    27f2:	8f 77       	andi	r24, 0x7F	; 127
    27f4:	80 83       	st	Z, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:199
        #endif
        SREG = oldSREG;
    27f6:	4f bf       	out	0x3f, r20	; 63
    27f8:	16 c0       	rjmp	.+44     	; 0x2826 <digitalWrite+0x172>
digitalPinToTimerNow():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:583
     * the alphabet. Time will tell if that F'ing timer is any good for PWM, or if
     * it's an F'ing utility timer like TCB - lord knows with how stingy they were
     * with peripherals on the EB, it needs it.
     */
  #endif
  if (timer & TIMERB0) { /* Finally check TCBn, if we made it here w/out returning */
    27fa:	85 ff       	sbrs	r24, 5
    27fc:	12 c0       	rjmp	.+36     	; 0x2822 <digitalWrite+0x16e>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:585
    TCB_t* timer_B;
    timer_B = ((TCB_t *)&TCB0 + (timer - TIMERB0)); /* get timer struct */
    27fe:	30 e1       	ldi	r19, 0x10	; 16
    2800:	83 9f       	mul	r24, r19
    2802:	f0 01       	movw	r30, r0
    2804:	11 24       	eor	r1, r1
    2806:	f7 5f       	subi	r31, 0xF7	; 247
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_analog.c:586
    if (((timer_B->CTRLB) &  TCB_CNTMODE_gm) != TCB_CNTMODE_PWM8_gc )
    2808:	91 81       	ldd	r25, Z+1	; 0x01
    280a:	97 70       	andi	r25, 0x07	; 7
    280c:	97 30       	cpi	r25, 0x07	; 7
    280e:	59 f4       	brne	.+22     	; 0x2826 <digitalWrite+0x172>
turnOffPWM():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    2810:	ec 91       	ld	r30, X
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:123
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    2812:	85 32       	cpi	r24, 0x25	; 37
    2814:	68 f4       	brcc	.+26     	; 0x2830 <digitalWrite+0x17c>
    2816:	80 32       	cpi	r24, 0x20	; 32
    2818:	98 f4       	brcc	.+38     	; 0x2840 <digitalWrite+0x18c>
    281a:	80 31       	cpi	r24, 0x10	; 16
    281c:	09 f4       	brne	.+2      	; 0x2820 <digitalWrite+0x16c>
    281e:	8d cf       	rjmp	.-230    	; 0x273a <digitalWrite+0x86>
    2820:	02 c0       	rjmp	.+4      	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:116
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;
    2822:	81 11       	cpse	r24, r1
    2824:	f5 cf       	rjmp	.-22     	; 0x2810 <digitalWrite+0x15c>
digitalWrite():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
    2826:	df 91       	pop	r29
    2828:	cf 91       	pop	r28
    282a:	1f 91       	pop	r17
    282c:	0f 91       	pop	r16
    282e:	08 95       	ret
turnOffPWM():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:123
  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    2830:	80 34       	cpi	r24, 0x40	; 64
    2832:	09 f4       	brne	.+2      	; 0x2836 <digitalWrite+0x182>
    2834:	aa cf       	rjmp	.-172    	; 0x278a <digitalWrite+0xd6>
    2836:	80 38       	cpi	r24, 0x80	; 128
    2838:	b1 f7       	brne	.-20     	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:155
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);

    break;
  #if defined(DAC0)
  case DACOUT:
    DAC0.CTRLA = 0x00;
    283a:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7f06a0>
    283e:	f3 cf       	rjmp	.-26     	; 0x2826 <digitalWrite+0x172>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:147
  case TIMERB1:
  case TIMERB2:
  case TIMERB3:
  case TIMERB4:

    timerB = (TCB_t *) &TCB0 + (timer - TIMERB0);
    2840:	90 e1       	ldi	r25, 0x10	; 16
    2842:	89 9f       	mul	r24, r25
    2844:	f0 01       	movw	r30, r0
    2846:	11 24       	eor	r1, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:150

     // Disable TCB compare channel
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);
    2848:	f7 5f       	subi	r31, 0xF7	; 247
    284a:	81 81       	ldd	r24, Z+1	; 0x01
    284c:	8f 7e       	andi	r24, 0xEF	; 239
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:179
      if (fcset) {
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    284e:	81 83       	std	Z+1, r24	; 0x01
    2850:	ea cf       	rjmp	.-44     	; 0x2826 <digitalWrite+0x172>
digitalWrite():
    2852:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:327

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
    2854:	e0 e0       	ldi	r30, 0x00	; 0
    2856:	b0 cf       	rjmp	.-160    	; 0x27b8 <digitalWrite+0x104>

00002858 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>:
endTransactionWithDeassertingCS():
    2858:	cf 93       	push	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:307
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    285a:	df 93       	push	r29
    285c:	ec 01       	movw	r28, r24
setChipSelect():
    285e:	8b 85       	ldd	r24, Y+11	; 0x0b
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:308
    digitalWrite(_cs, value);
    2860:	8f 3f       	cpi	r24, 0xFF	; 255
    2862:	11 f0       	breq	.+4      	; 0x2868 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x10>
    2864:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:295

/*!
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
    2866:	26 df       	rcall	.-436    	; 0x26b4 <digitalWrite>
endTransaction():
    2868:	88 81       	ld	r24, Y
    286a:	99 81       	ldd	r25, Y+1	; 0x01
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:330
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
}
    286c:	00 97       	sbiw	r24, 0x00	; 0
    286e:	19 f0       	breq	.+6      	; 0x2876 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()+0x1e>
endTransactionWithDeassertingCS():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:297
 *    @brief  Manually end a transaction (calls endTransaction if hardware SPI)
 */
void Adafruit_SPIDevice::endTransaction(void) {
  if (_spi) {
#ifdef BUSIO_HAS_HW_SPI
    _spi->endTransaction();
    2870:	df 91       	pop	r29
    2872:	cf 91       	pop	r28
endTransaction():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:330
 *            with deasserting the CS pin
 */
void Adafruit_SPIDevice::endTransactionWithDeassertingCS() {
  setChipSelect(HIGH);
  endTransaction();
}
    2874:	9f ce       	rjmp	.-706    	; 0x25b4 <SPIClass::endTransaction()>
endTransactionWithDeassertingCS():
    2876:	df 91       	pop	r29
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:318
 *    @brief  Write a buffer or two to the SPI device, with transaction
 * management.
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
    2878:	cf 91       	pop	r28
    287a:	08 95       	ret

0000287c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>:
beginTransactionWithAssertingCS():
    287c:	cf 93       	push	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:284
/*!
 *    @brief  Manually begin a transaction (calls beginTransaction if hardware
 * SPI)
 */
void Adafruit_SPIDevice::beginTransaction(void) {
  if (_spi) {
    287e:	df 93       	push	r29
    2880:	ec 01       	movw	r28, r24
beginTransaction():
    2882:	88 81       	ld	r24, Y
    2884:	99 81       	ldd	r25, Y+1	; 0x01
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:286
#ifdef BUSIO_HAS_HW_SPI
    _spi->beginTransaction(*_spiSetting);
    2886:	00 97       	sbiw	r24, 0x00	; 0
    2888:	29 f0       	breq	.+10     	; 0x2894 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x18>
    288a:	ea 81       	ldd	r30, Y+2	; 0x02
    288c:	fb 81       	ldd	r31, Y+3	; 0x03
    288e:	60 81       	ld	r22, Z
    2890:	71 81       	ldd	r23, Z+1	; 0x01
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:307
/*!
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    2892:	9b de       	rcall	.-714    	; 0x25ca <SPIClass::beginTransaction(SPISettings)>
setChipSelect():
    2894:	8b 85       	ldd	r24, Y+11	; 0x0b
    2896:	8f 3f       	cpi	r24, 0xFF	; 255
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:308
    digitalWrite(_cs, value);
    2898:	21 f0       	breq	.+8      	; 0x28a2 <Adafruit_SPIDevice::beginTransactionWithAssertingCS()+0x26>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:321
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    289a:	60 e0       	ldi	r22, 0x00	; 0
beginTransactionWithAssertingCS():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:308
 *    @brief  Assert/Deassert the CS pin if it is defined
 *    @param  value The state the CS is set to
 */
void Adafruit_SPIDevice::setChipSelect(int value) {
  if (_cs != -1) {
    digitalWrite(_cs, value);
    289c:	df 91       	pop	r29
    289e:	cf 91       	pop	r28
setChipSelect():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:321
 *            SPI) with asserting the CS pin
 */
void Adafruit_SPIDevice::beginTransactionWithAssertingCS() {
  beginTransaction();
  setChipSelect(LOW);
}
    28a0:	09 cf       	rjmp	.-494    	; 0x26b4 <digitalWrite>
beginTransactionWithAssertingCS():
    28a2:	df 91       	pop	r29
    28a4:	cf 91       	pop	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:438
 *    @param  sendvalue The 8-bits of data to write when doing the data read,
 * defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(const uint8_t *write_buffer,
    28a6:	08 95       	ret

000028a8 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.42]>:
write_then_read():
    28a8:	8f 92       	push	r8
    28aa:	9f 92       	push	r9
    28ac:	af 92       	push	r10
    28ae:	bf 92       	push	r11
    28b0:	cf 92       	push	r12
    28b2:	df 92       	push	r13
    28b4:	ef 92       	push	r14
    28b6:	ff 92       	push	r15
    28b8:	0f 93       	push	r16
    28ba:	1f 93       	push	r17
    28bc:	cf 93       	push	r28
    28be:	df 93       	push	r29
    28c0:	7c 01       	movw	r14, r24
    28c2:	4b 01       	movw	r8, r22
    28c4:	6a 01       	movw	r12, r20
    28c6:	b2 2e       	mov	r11, r18
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:441
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
  beginTransactionWithAssertingCS();
    28c8:	a3 2e       	mov	r10, r19
    28ca:	d8 df       	rcall	.-80     	; 0x287c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
    28cc:	e4 01       	movw	r28, r8
    28ce:	c8 0c       	add	r12, r8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:451
      _spi->transferBytes((uint8_t *)write_buffer, nullptr, write_len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
    28d0:	d9 1c       	adc	r13, r9
    28d2:	cc 15       	cp	r28, r12
    28d4:	dd 05       	cpc	r29, r13
    28d6:	69 f4       	brne	.+26     	; 0x28f2 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.42]+0x4a>
    28d8:	cb 2d       	mov	r28, r11
    28da:	da 2d       	mov	r29, r10
    28dc:	0c 0f       	add	r16, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:470
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    28de:	1d 1f       	adc	r17, r29
    28e0:	c0 17       	cp	r28, r16
    28e2:	d1 07       	cpc	r29, r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:471
    read_buffer[i] = transfer(sendvalue);
    28e4:	59 f0       	breq	.+22     	; 0x28fc <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.42]+0x54>
    28e6:	6f ef       	ldi	r22, 0xFF	; 255
    28e8:	c7 01       	movw	r24, r14
    28ea:	0e 94 a8 09 	call	0x1350	; 0x1350 <Adafruit_SPIDevice::transfer(unsigned char)>
    28ee:	89 93       	st	Y+, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:452
    }
  } else
#endif
  {
    for (size_t i = 0; i < write_len; i++) {
      transfer(write_buffer[i]);
    28f0:	f7 cf       	rjmp	.-18     	; 0x28e0 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.42]+0x38>
    28f2:	69 91       	ld	r22, Y+
    28f4:	c7 01       	movw	r24, r14
    28f6:	0e 94 a8 09 	call	0x1350	; 0x1350 <Adafruit_SPIDevice::transfer(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:487
    }
  }
  DEBUG_SERIAL.println();
#endif

  endTransactionWithDeassertingCS();
    28fa:	eb cf       	rjmp	.-42     	; 0x28d2 <Adafruit_SPIDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.42]+0x2a>
    28fc:	c7 01       	movw	r24, r14
    28fe:	ac df       	rcall	.-168    	; 0x2858 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:490

  return true;
}
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	df 91       	pop	r29
    2904:	cf 91       	pop	r28
    2906:	1f 91       	pop	r17
    2908:	0f 91       	pop	r16
    290a:	ff 90       	pop	r15
    290c:	ef 90       	pop	r14
    290e:	df 90       	pop	r13
    2910:	cf 90       	pop	r12
    2912:	bf 90       	pop	r11
    2914:	af 90       	pop	r10
    2916:	9f 90       	pop	r9
    2918:	8f 90       	pop	r8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:345
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(const uint8_t *buffer, size_t len,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
    291a:	08 95       	ret

0000291c <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)>:
write():
    291c:	8f 92       	push	r8
    291e:	9f 92       	push	r9
    2920:	af 92       	push	r10
    2922:	bf 92       	push	r11
    2924:	cf 92       	push	r12
    2926:	df 92       	push	r13
    2928:	ef 92       	push	r14
    292a:	ff 92       	push	r15
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	cf 93       	push	r28
    2932:	df 93       	push	r29
    2934:	7c 01       	movw	r14, r24
    2936:	b6 2e       	mov	r11, r22
    2938:	a7 2e       	mov	r10, r23
    293a:	6a 01       	movw	r12, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:346
  beginTransactionWithAssertingCS();
    293c:	49 01       	movw	r8, r18
    293e:	9e df       	rcall	.-196    	; 0x287c <Adafruit_SPIDevice::beginTransactionWithAssertingCS()>
    2940:	e4 01       	movw	r28, r8
    2942:	08 0d       	add	r16, r8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:360
      _spi->transferBytes((uint8_t *)buffer, nullptr, len);
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
    2944:	19 1d       	adc	r17, r9
    2946:	c0 17       	cp	r28, r16
    2948:	d1 07       	cpc	r29, r17
    294a:	61 f4       	brne	.+24     	; 0x2964 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x48>
    294c:	cb 2d       	mov	r28, r11
    294e:	da 2d       	mov	r29, r10
    2950:	cc 0e       	add	r12, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:363
      transfer(prefix_buffer[i]);
    }
    for (size_t i = 0; i < len; i++) {
    2952:	dd 1e       	adc	r13, r29
    2954:	cc 15       	cp	r28, r12
    2956:	dd 05       	cpc	r29, r13
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:364
      transfer(buffer[i]);
    2958:	51 f0       	breq	.+20     	; 0x296e <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x52>
    295a:	69 91       	ld	r22, Y+
    295c:	c7 01       	movw	r24, r14
    295e:	0e 94 a8 09 	call	0x1350	; 0x1350 <Adafruit_SPIDevice::transfer(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:361
    }
  } else
#endif
  {
    for (size_t i = 0; i < prefix_len; i++) {
      transfer(prefix_buffer[i]);
    2962:	f8 cf       	rjmp	.-16     	; 0x2954 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x38>
    2964:	69 91       	ld	r22, Y+
    2966:	c7 01       	movw	r24, r14
    2968:	0e 94 a8 09 	call	0x1350	; 0x1350 <Adafruit_SPIDevice::transfer(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:367
    }
    for (size_t i = 0; i < len; i++) {
      transfer(buffer[i]);
    }
  }
  endTransactionWithDeassertingCS();
    296c:	ec cf       	rjmp	.-40     	; 0x2946 <Adafruit_SPIDevice::write(unsigned char const*, unsigned int, unsigned char const*, unsigned int)+0x2a>
    296e:	c7 01       	movw	r24, r14
    2970:	73 df       	rcall	.-282    	; 0x2858 <Adafruit_SPIDevice::endTransactionWithDeassertingCS()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_SPIDevice.cpp:390
  }
  DEBUG_SERIAL.println();
#endif

  return true;
}
    2972:	81 e0       	ldi	r24, 0x01	; 1
    2974:	df 91       	pop	r29
    2976:	cf 91       	pop	r28
    2978:	1f 91       	pop	r17
    297a:	0f 91       	pop	r16
    297c:	ff 90       	pop	r15
    297e:	ef 90       	pop	r14
    2980:	df 90       	pop	r13
    2982:	cf 90       	pop	r12
    2984:	bf 90       	pop	r11
    2986:	af 90       	pop	r10
    2988:	9f 90       	pop	r9
    298a:	8f 90       	pop	r8
    298c:	08 95       	ret

0000298e <TWI_MasterSetBaud>:
TWI_MasterSetBaud():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:211
    if ((frequency < 1000) || (frequency > 15000000)) {
      badArg("Invalid frequency was passed for SCL clock!");
      return 1;
    }
  } else {
    if (frequency < 1000) {
    298e:	48 3e       	cpi	r20, 0xE8	; 232
    2990:	23 e0       	ldi	r18, 0x03	; 3
    2992:	52 07       	cpc	r21, r18
    2994:	61 05       	cpc	r22, r1
    2996:	71 05       	cpc	r23, r1
    2998:	28 f0       	brcs	.+10     	; 0x29a4 <TWI_MasterSetBaud+0x16>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:215
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    299a:	fc 01       	movw	r30, r24
    299c:	22 81       	ldd	r18, Z+2	; 0x02
    299e:	21 fd       	sbrc	r18, 1
    29a0:	0c 94 8e 08 	jmp	0x111c	; 0x111c <TWI_MasterSetBaud.part.3>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:235
      }
    }
    return 0;
  }
  return 1;
}
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	08 95       	ret

000029a8 <TWI_MasterInit.part.4>:
TWI_MasterInit.part.4():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:67
    }
  #else                                             // Only one TWI is used
    TWI0_ClearPins();                               // Only one option is possible
  #endif

  _data->_bools._hostEnabled    = 1;
    29a8:	dc 01       	movw	r26, r24
    29aa:	12 96       	adiw	r26, 0x02	; 2
    29ac:	2c 91       	ld	r18, X
    29ae:	12 97       	sbiw	r26, 0x02	; 2
    29b0:	22 60       	ori	r18, 0x02	; 2
    29b2:	12 96       	adiw	r26, 0x02	; 2
    29b4:	2c 93       	st	X, r18
    29b6:	12 97       	sbiw	r26, 0x02	; 2
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:68
  _data->_module->MCTRLA        = TWI_ENABLE_bm;  // Master Interrupt flags stay disabled
    29b8:	ed 91       	ld	r30, X+
    29ba:	fc 91       	ld	r31, X
    29bc:	11 97       	sbiw	r26, 0x01	; 1
    29be:	21 e0       	ldi	r18, 0x01	; 1
    29c0:	23 83       	std	Z+3, r18	; 0x03
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:69
  _data->_module->MSTATUS       = TWI_BUSSTATE_IDLE_gc;
    29c2:	25 83       	std	Z+5, r18	; 0x05
TWI_MasterSetBaud():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:215
  } else {
    if (frequency < 1000) {
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    29c4:	12 96       	adiw	r26, 0x02	; 2
    29c6:	2c 91       	ld	r18, X
    29c8:	21 ff       	sbrs	r18, 1
    29ca:	06 c0       	rjmp	.+12     	; 0x29d8 <TWI_MasterInit.part.4+0x30>
    29cc:	40 ea       	ldi	r20, 0xA0	; 160
    29ce:	56 e8       	ldi	r21, 0x86	; 134
    29d0:	61 e0       	ldi	r22, 0x01	; 1
    29d2:	70 e0       	ldi	r23, 0x00	; 0
    29d4:	0c 94 8e 08 	jmp	0x111c	; 0x111c <TWI_MasterSetBaud.part.3>
TWI_MasterInit.part.4():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:484
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
    29d8:	08 95       	ret

000029da <TwoWire::beginTransmission(unsigned char)>:
beginTransmission():
    29da:	66 0f       	add	r22, r22
    29dc:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:485
  (*txHead) = 0;  // fill buffer from 0
    29de:	64 87       	std	Z+12, r22	; 0x0c
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:486
}
    29e0:	15 86       	std	Z+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:416
                   number of commands in the list

    @return None (void).
    @note
*/
void Adafruit_SSD1306::ssd1306_commandList(const uint8_t *c, uint8_t n) {
    29e2:	08 95       	ret

000029e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>:
ssd1306_commandList():
    29e4:	ef 92       	push	r14
    29e6:	ff 92       	push	r15
    29e8:	0f 93       	push	r16
    29ea:	1f 93       	push	r17
    29ec:	cf 93       	push	r28
    29ee:	7c 01       	movw	r14, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:417
  if (wire) { // I2C
    29f0:	c6 2f       	mov	r28, r22
    29f2:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    29f6:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    29fa:	00 97       	sbiw	r24, 0x00	; 0
    29fc:	09 f4       	brne	.+2      	; 0x2a00 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x1c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.h:91
    void endMaster(void);
    void endSlave(void);

    void beginTransmission(uint8_t address);
    void beginTransmission(int     address) {
      beginTransmission((uint8_t)address);
    29fe:	4e c0       	rjmp	.+156    	; 0x2a9c <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xb8>
_ZN7TwoWire17beginTransmissionEi():
    2a00:	60 91 8a 65 	lds	r22, 0x658A	; 0x80658a <display+0x21>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:419
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    2a04:	ea df       	rcall	.-44     	; 0x29da <TwoWire::beginTransmission(unsigned char)>
ssd1306_commandList():
    2a06:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    2a0a:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    2a0e:	dc 01       	movw	r26, r24
    2a10:	ed 91       	ld	r30, X+
    2a12:	fc 91       	ld	r31, X
    2a14:	01 90       	ld	r0, Z+
    2a16:	f0 81       	ld	r31, Z
    2a18:	e0 2d       	mov	r30, r0
    2a1a:	60 e0       	ldi	r22, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:420
    uint16_t bytesOut = 1;
    2a1c:	09 95       	icall
    2a1e:	87 01       	movw	r16, r14
    2a20:	ee 24       	eor	r14, r14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:421
    while (n--) {
    2a22:	e3 94       	inc	r14
    2a24:	f1 2c       	mov	r15, r1
    2a26:	c1 50       	subi	r28, 0x01	; 1
    2a28:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    2a2c:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:422
      if (bytesOut >= WIRE_MAX) {
    2a30:	cf 3f       	cpi	r28, 0xFF	; 255
    2a32:	71 f1       	breq	.+92     	; 0x2a90 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xac>
    2a34:	b2 e8       	ldi	r27, 0x82	; 130
    2a36:	eb 16       	cp	r14, r27
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:423
        wire->endTransmission();
    2a38:	f1 04       	cpc	r15, r1
    2a3a:	b8 f0       	brcs	.+46     	; 0x2a6a <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x86>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.h:91
    2a3c:	b3 dd       	rcall	.-1178   	; 0x25a4 <TwoWire::endTransmission()>
_ZN7TwoWire17beginTransmissionEi():
    2a3e:	60 91 8a 65 	lds	r22, 0x658A	; 0x80658a <display+0x21>
    2a42:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    2a46:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    2a4a:	c7 df       	rcall	.-114    	; 0x29da <TwoWire::beginTransmission(unsigned char)>
ssd1306_commandList():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:425
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    2a4c:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    2a50:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    2a54:	dc 01       	movw	r26, r24
    2a56:	ed 91       	ld	r30, X+
    2a58:	fc 91       	ld	r31, X
    2a5a:	01 90       	ld	r0, Z+
    2a5c:	f0 81       	ld	r31, Z
    2a5e:	e0 2d       	mov	r30, r0
    2a60:	60 e0       	ldi	r22, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:426
        bytesOut = 1;
    2a62:	09 95       	icall
    2a64:	ee 24       	eor	r14, r14
    2a66:	e3 94       	inc	r14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:428
      }
      WIRE_WRITE(pgm_read_byte(c++));
    2a68:	f1 2c       	mov	r15, r1
    2a6a:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    2a6e:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    2a72:	f8 01       	movw	r30, r16
    2a74:	64 91       	lpm	r22, Z
    2a76:	dc 01       	movw	r26, r24
    2a78:	ed 91       	ld	r30, X+
    2a7a:	fc 91       	ld	r31, X
    2a7c:	01 90       	ld	r0, Z+
    2a7e:	f0 81       	ld	r31, Z
    2a80:	e0 2d       	mov	r30, r0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:429
      bytesOut++;
    2a82:	09 95       	icall
    2a84:	bf ef       	ldi	r27, 0xFF	; 255
    2a86:	eb 1a       	sub	r14, r27
    2a88:	fb 0a       	sbc	r15, r27
    2a8a:	0f 5f       	subi	r16, 0xFF	; 255
    2a8c:	1f 4f       	sbci	r17, 0xFF	; 255
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:437
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
    while (n--)
      SPIwrite(pgm_read_byte(c++));
  }
}
    2a8e:	cb cf       	rjmp	.-106    	; 0x2a26 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x42>
    2a90:	cf 91       	pop	r28
    2a92:	1f 91       	pop	r17
    2a94:	0f 91       	pop	r16
    2a96:	ff 90       	pop	r15
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:431
        bytesOut = 1;
      }
      WIRE_WRITE(pgm_read_byte(c++));
      bytesOut++;
    }
    wire->endTransmission();
    2a98:	ef 90       	pop	r14
    2a9a:	84 cd       	rjmp	.-1272   	; 0x25a4 <TwoWire::endTransmission()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:433
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
    2a9c:	e0 91 96 65 	lds	r30, 0x6596	; 0x806596 <display+0x2d>
    2aa0:	f0 91 97 65 	lds	r31, 0x6597	; 0x806597 <display+0x2e>
    2aa4:	90 81       	ld	r25, Z
    2aa6:	80 91 9c 65 	lds	r24, 0x659C	; 0x80659c <display+0x33>
    2aaa:	80 95       	com	r24
    2aac:	89 23       	and	r24, r25
    2aae:	80 83       	st	Z, r24
    2ab0:	87 01       	movw	r16, r14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:434
    while (n--)
    2ab2:	c1 50       	subi	r28, 0x01	; 1
    2ab4:	08 f4       	brcc	.+2      	; 0x2ab8 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xd4>
    2ab6:	38 c0       	rjmp	.+112    	; 0x2b28 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x144>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:435
      SPIwrite(pgm_read_byte(c++));
    2ab8:	f8 01       	movw	r30, r16
    2aba:	84 91       	lpm	r24, Z
_ZN16Adafruit_SSD13068SPIwriteEh():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    2abc:	20 91 84 65 	lds	r18, 0x6584	; 0x806584 <display+0x1b>
    2ac0:	30 91 85 65 	lds	r19, 0x6585	; 0x806585 <display+0x1c>
    2ac4:	23 2b       	or	r18, r19
    2ac6:	29 f0       	breq	.+10     	; 0x2ad2 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xee>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:361
    (void)spi->transfer(d);
    2ac8:	0e 94 3d 06 	call	0xc7a	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>
    2acc:	0f 5f       	subi	r16, 0xFF	; 255
    2ace:	1f 4f       	sbci	r17, 0xFF	; 255
    2ad0:	f0 cf       	rjmp	.-32     	; 0x2ab2 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xce>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    2ad2:	28 e0       	ldi	r18, 0x08	; 8
    2ad4:	30 e0       	ldi	r19, 0x00	; 0
ssd1306_commandList():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    2ad6:	40 e8       	ldi	r20, 0x80	; 128
    2ad8:	e0 91 92 65 	lds	r30, 0x6592	; 0x806592 <display+0x29>
    2adc:	f0 91 93 65 	lds	r31, 0x6593	; 0x806593 <display+0x2a>
    2ae0:	90 91 9a 65 	lds	r25, 0x659A	; 0x80659a <display+0x31>
_ZN16Adafruit_SSD13068SPIwriteEh():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:365
#ifdef HAVE_PORTREG
      if (d & bit)
    2ae4:	58 2f       	mov	r21, r24
    2ae6:	54 23       	and	r21, r20
    2ae8:	d9 f0       	breq	.+54     	; 0x2b20 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x13c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:366
        *mosiPort |= mosiPinMask;
    2aea:	50 81       	ld	r21, Z
    2aec:	95 2b       	or	r25, r21
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
      else
        *mosiPort &= ~mosiPinMask;
    2aee:	90 83       	st	Z, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:369
      *clkPort |= clkPinMask;  // Clock high
    2af0:	e0 91 94 65 	lds	r30, 0x6594	; 0x806594 <display+0x2b>
    2af4:	f0 91 95 65 	lds	r31, 0x6595	; 0x806595 <display+0x2c>
    2af8:	90 81       	ld	r25, Z
    2afa:	50 91 9b 65 	lds	r21, 0x659B	; 0x80659b <display+0x32>
    2afe:	95 2b       	or	r25, r21
    2b00:	90 83       	st	Z, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:370
      *clkPort &= ~clkPinMask; // Clock low
    2b02:	e0 91 94 65 	lds	r30, 0x6594	; 0x806594 <display+0x2b>
    2b06:	f0 91 95 65 	lds	r31, 0x6595	; 0x806595 <display+0x2c>
    2b0a:	50 81       	ld	r21, Z
    2b0c:	90 91 9b 65 	lds	r25, 0x659B	; 0x80659b <display+0x32>
    2b10:	90 95       	com	r25
    2b12:	95 23       	and	r25, r21
    2b14:	90 83       	st	Z, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    2b16:	46 95       	lsr	r20
    2b18:	21 50       	subi	r18, 0x01	; 1
    2b1a:	31 09       	sbc	r19, r1
    2b1c:	e9 f6       	brne	.-70     	; 0x2ad8 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xf4>
    2b1e:	d6 cf       	rjmp	.-84     	; 0x2acc <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0xe8>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
    2b20:	50 81       	ld	r21, Z
    2b22:	90 95       	com	r25
    2b24:	95 23       	and	r25, r21
    2b26:	e3 cf       	rjmp	.-58     	; 0x2aee <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]+0x10a>
ssd1306_commandList():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:437
  } else { // SPI -- transaction started in calling function
    SSD1306_MODE_COMMAND
    while (n--)
      SPIwrite(pgm_read_byte(c++));
  }
}
    2b28:	cf 91       	pop	r28
    2b2a:	1f 91       	pop	r17
    2b2c:	0f 91       	pop	r16
    2b2e:	ff 90       	pop	r15
    2b30:	ef 90       	pop	r14
    2b32:	08 95       	ret

00002b34 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]>:
write8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:181
uint8_t Adafruit_MCP23008::read8(uint8_t addr) {
  Adafruit_BusIO_Register reg = Adafruit_BusIO_Register(i2c_dev, addr, 1);
  return reg.read();
}

bool Adafruit_MCP23008::write8(uint8_t addr, uint8_t data) {
    2b34:	cf 92       	push	r12
    2b36:	df 92       	push	r13
    2b38:	ef 92       	push	r14
    2b3a:	ff 92       	push	r15
    2b3c:	0f 93       	push	r16
    2b3e:	1f 93       	push	r17
    2b40:	cf 93       	push	r28
    2b42:	df 93       	push	r29
    2b44:	cd b7       	in	r28, 0x3d	; 61
    2b46:	de b7       	in	r29, 0x3e	; 62
    2b48:	67 97       	sbiw	r28, 0x17	; 23
    2b4a:	cd bf       	out	0x3d, r28	; 61
    2b4c:	de bf       	out	0x3e, r29	; 62
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:182
  Adafruit_BusIO_Register reg = Adafruit_BusIO_Register(i2c_dev, addr, 1);
    2b4e:	00 91 37 64 	lds	r16, 0x6437	; 0x806437 <mcp_leds>
    2b52:	10 91 38 64 	lds	r17, 0x6438	; 0x806438 <mcp_leds+0x1>
__base_ctor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:23
Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice *i2cdevice,
                                                 uint16_t reg_addr,
                                                 uint8_t width,
                                                 uint8_t byteorder,
                                                 uint8_t address_width) {
  _i2cdevice = i2cdevice;
    2b56:	09 83       	std	Y+1, r16	; 0x01
    2b58:	1a 83       	std	Y+2, r17	; 0x02
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:24
  _spidevice = nullptr;
    2b5a:	1b 82       	std	Y+3, r1	; 0x03
    2b5c:	1c 82       	std	Y+4, r1	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:25
  _addrwidth = address_width;
    2b5e:	91 e0       	ldi	r25, 0x01	; 1
    2b60:	9c 87       	std	Y+12, r25	; 0x0c
write8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:182
    2b62:	28 2f       	mov	r18, r24
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	29 87       	std	Y+9, r18	; 0x09
    2b68:	3a 87       	std	Y+10, r19	; 0x0a
__base_ctor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:27
  _address = reg_addr;
  _byteorder = byteorder;
    2b6a:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:28
  _width = width;
    2b6c:	9b 87       	std	Y+11, r25	; 0x0b
write8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:184

  return reg.write(data);
    2b6e:	c6 2e       	mov	r12, r22
    2b70:	d1 2c       	mov	r13, r1
    2b72:	f1 2c       	mov	r15, r1
    2b74:	e1 2c       	mov	r14, r1
    2b76:	ca 8a       	std	Y+18, r12	; 0x12
    2b78:	db 8a       	std	Y+19, r13	; 0x13
    2b7a:	ec 8a       	std	Y+20, r14	; 0x14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:174
  // store a copy
  _cached = value;

  for (int i = 0; i < numbytes; i++) {
    if (_byteorder == LSBFIRST) {
      _buffer[i] = value & 0xFF;
    2b7c:	fd 8a       	std	Y+21, r15	; 0x15
write():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:120
 *    @return True on successful write (only really useful for I2C as SPI is
 * uncheckable)
 */
bool Adafruit_BusIO_Register::write(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2b7e:	6e 87       	std	Y+14, r22	; 0x0e
    2b80:	8e 8b       	std	Y+22, r24	; 0x16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:121
  if (_i2cdevice) {
    2b82:	1f 8a       	std	Y+23, r1	; 0x17
    2b84:	01 15       	cp	r16, r1
    2b86:	11 05       	cpc	r17, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:105
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
    2b88:	a1 f1       	breq	.+104    	; 0x2bf2 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0xbe>
    2b8a:	d8 01       	movw	r26, r16
    2b8c:	14 96       	adiw	r26, 0x04	; 4
    2b8e:	8d 91       	ld	r24, X+
    2b90:	9c 91       	ld	r25, X
    2b92:	02 97       	sbiw	r24, 0x02	; 2
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:112
    // we will need to find out if some platforms have larger
    // I2C buffer sizes :/
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
    2b94:	68 f4       	brcc	.+26     	; 0x2bb0 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x7c>
write8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:185
}
    2b96:	80 e0       	ldi	r24, 0x00	; 0
    2b98:	67 96       	adiw	r28, 0x17	; 23
    2b9a:	cd bf       	out	0x3d, r28	; 61
    2b9c:	de bf       	out	0x3e, r29	; 62
    2b9e:	df 91       	pop	r29
    2ba0:	cf 91       	pop	r28
    2ba2:	1f 91       	pop	r17
    2ba4:	0f 91       	pop	r16
    2ba6:	ff 90       	pop	r15
    2ba8:	ef 90       	pop	r14
    2baa:	df 90       	pop	r13
    2bac:	cf 90       	pop	r12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:115
  }

  _wire->beginTransmission(_addr);
    2bae:	08 95       	ret
write():
    2bb0:	f8 01       	movw	r30, r16
    2bb2:	60 81       	ld	r22, Z
    2bb4:	81 81       	ldd	r24, Z+1	; 0x01
    2bb6:	92 81       	ldd	r25, Z+2	; 0x02
    2bb8:	10 df       	rcall	.-480    	; 0x29da <TwoWire::beginTransmission(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:119

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
    2bba:	d8 01       	movw	r26, r16
    2bbc:	11 96       	adiw	r26, 0x01	; 1
    2bbe:	8d 91       	ld	r24, X+
    2bc0:	9c 91       	ld	r25, X
    2bc2:	dc 01       	movw	r26, r24
    2bc4:	ed 91       	ld	r30, X+
    2bc6:	fc 91       	ld	r31, X
    2bc8:	02 80       	ldd	r0, Z+2	; 0x02
    2bca:	f3 81       	ldd	r31, Z+3	; 0x03
    2bcc:	e0 2d       	mov	r30, r0
    2bce:	41 e0       	ldi	r20, 0x01	; 1
    2bd0:	50 e0       	ldi	r21, 0x00	; 0
    2bd2:	be 01       	movw	r22, r28
    2bd4:	6a 5e       	subi	r22, 0xEA	; 234
    2bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd8:	09 95       	icall
    2bda:	01 97       	sbiw	r24, 0x01	; 1
    2bdc:	e1 f6       	brne	.-72     	; 0x2b96 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x62>
    2bde:	21 e0       	ldi	r18, 0x01	; 1
    2be0:	41 e0       	ldi	r20, 0x01	; 1
    2be2:	50 e0       	ldi	r21, 0x00	; 0
    2be4:	be 01       	movw	r22, r28
    2be6:	62 5f       	subi	r22, 0xF2	; 242
    2be8:	7f 4f       	sbci	r23, 0xFF	; 255
    2bea:	c8 01       	movw	r24, r16
    2bec:	0e 94 66 0a 	call	0x14cc	; 0x14cc <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.1]>
    2bf0:	d3 cf       	rjmp	.-90     	; 0x2b98 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x64>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:148
      addrbuffer[0] &= ~0x80;
      addrbuffer[0] |= 0x40;
    }
    return _spidevice->write(buffer, len, addrbuffer, _addrwidth);
  }
  if (_genericdevice) {
    2bf2:	ad 81       	ldd	r26, Y+5	; 0x05
    2bf4:	be 81       	ldd	r27, Y+6	; 0x06
    2bf6:	10 97       	sbiw	r26, 0x00	; 0
    2bf8:	71 f2       	breq	.-100    	; 0x2b96 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x62>
writeRegister():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_GenericDevice.cpp:79
   @param bufsiz Size of data to write in bytes
   @return true if write was successful, otherwise false */
bool Adafruit_GenericDevice::writeRegister(uint8_t *addr_buf, uint8_t addrsiz,
                                           const uint8_t *buf,
                                           uint16_t bufsiz) {
  if (!_begun || !_writereg_func)
    2bfa:	18 96       	adiw	r26, 0x08	; 8
    2bfc:	8c 91       	ld	r24, X
    2bfe:	18 97       	sbiw	r26, 0x08	; 8
    2c00:	88 23       	and	r24, r24
    2c02:	49 f2       	breq	.-110    	; 0x2b96 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x62>
    2c04:	16 96       	adiw	r26, 0x06	; 6
    2c06:	ed 91       	ld	r30, X+
    2c08:	fc 91       	ld	r31, X
    2c0a:	17 97       	sbiw	r26, 0x07	; 7
    2c0c:	30 97       	sbiw	r30, 0x00	; 0
    2c0e:	19 f2       	breq	.-122    	; 0x2b96 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x62>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_GenericDevice.cpp:81
    return false;
  return _writereg_func(_obj, addr_buf, addrsiz, buf, bufsiz);
    2c10:	01 e0       	ldi	r16, 0x01	; 1
    2c12:	10 e0       	ldi	r17, 0x00	; 0
    2c14:	9e 01       	movw	r18, r28
    2c16:	22 5f       	subi	r18, 0xF2	; 242
    2c18:	3f 4f       	sbci	r19, 0xFF	; 255
    2c1a:	41 e0       	ldi	r20, 0x01	; 1
    2c1c:	be 01       	movw	r22, r28
    2c1e:	6a 5e       	subi	r22, 0xEA	; 234
    2c20:	7f 4f       	sbci	r23, 0xFF	; 255
    2c22:	19 96       	adiw	r26, 0x09	; 9
    2c24:	8d 91       	ld	r24, X+
    2c26:	9c 91       	ld	r25, X
    2c28:	09 95       	icall
    2c2a:	b6 cf       	rjmp	.-148    	; 0x2b98 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]+0x64>

00002c2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]>:
read8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:176

  // read the current GPIO
  return (readGPIO() >> p) & 0x1;
}

uint8_t Adafruit_MCP23008::read8(uint8_t addr) {
    2c2c:	af 92       	push	r10
    2c2e:	bf 92       	push	r11
    2c30:	df 92       	push	r13
    2c32:	ef 92       	push	r14
    2c34:	ff 92       	push	r15
    2c36:	0f 93       	push	r16
    2c38:	1f 93       	push	r17
    2c3a:	cf 93       	push	r28
    2c3c:	df 93       	push	r29
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	67 97       	sbiw	r28, 0x17	; 23
    2c44:	cd bf       	out	0x3d, r28	; 61
    2c46:	de bf       	out	0x3e, r29	; 62
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:177
  Adafruit_BusIO_Register reg = Adafruit_BusIO_Register(i2c_dev, addr, 1);
    2c48:	e0 90 37 64 	lds	r14, 0x6437	; 0x806437 <mcp_leds>
    2c4c:	f0 90 38 64 	lds	r15, 0x6438	; 0x806438 <mcp_leds+0x1>
__base_ctor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:22
 */
Adafruit_BusIO_Register::Adafruit_BusIO_Register(Adafruit_I2CDevice *i2cdevice,
                                                 uint16_t reg_addr,
                                                 uint8_t width,
                                                 uint8_t byteorder,
                                                 uint8_t address_width) {
    2c50:	1a 8a       	std	Y+18, r1	; 0x12
    2c52:	1b 8a       	std	Y+19, r1	; 0x13
    2c54:	1c 8a       	std	Y+20, r1	; 0x14
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:23
  _i2cdevice = i2cdevice;
    2c56:	1d 8a       	std	Y+21, r1	; 0x15
    2c58:	e9 82       	std	Y+1, r14	; 0x01
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:24
  _spidevice = nullptr;
    2c5a:	fa 82       	std	Y+2, r15	; 0x02
    2c5c:	1b 82       	std	Y+3, r1	; 0x03
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:25
  _addrwidth = address_width;
    2c5e:	1c 82       	std	Y+4, r1	; 0x04
    2c60:	91 e0       	ldi	r25, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:177
    2c62:	9c 87       	std	Y+12, r25	; 0x0c
read8():
    2c64:	28 2f       	mov	r18, r24
    2c66:	30 e0       	ldi	r19, 0x00	; 0
    2c68:	29 87       	std	Y+9, r18	; 0x09
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:27
  _address = reg_addr;
  _byteorder = byteorder;
    2c6a:	3a 87       	std	Y+10, r19	; 0x0a
__base_ctor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:28
  _width = width;
    2c6c:	1d 86       	std	Y+13, r1	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:221
   @param len Number of bytes to read into the buffer
   @return true on successful read, otherwise false
*/
bool Adafruit_BusIO_Register::read(uint8_t *buffer, uint8_t len) {
  uint8_t addrbuffer[2] = {(uint8_t)(_address & 0xFF),
                           (uint8_t)(_address >> 8)};
    2c6e:	9b 87       	std	Y+11, r25	; 0x0b
read():
    2c70:	8e 8b       	std	Y+22, r24	; 0x16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:222
  if (_i2cdevice) {
    2c72:	1f 8a       	std	Y+23, r1	; 0x17
    2c74:	e1 14       	cp	r14, r1
    2c76:	f1 04       	cpc	r15, r1
    2c78:	09 f4       	brne	.+2      	; 0x2c7c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x50>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:105
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
    2c7a:	aa c0       	rjmp	.+340    	; 0x2dd0 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1a4>
write():
    2c7c:	d7 01       	movw	r26, r14
    2c7e:	14 96       	adiw	r26, 0x04	; 4
    2c80:	8d 91       	ld	r24, X+
    2c82:	9c 91       	ld	r25, X
    2c84:	15 97       	sbiw	r26, 0x05	; 5
    2c86:	89 2b       	or	r24, r25
    2c88:	09 f4       	brne	.+2      	; 0x2c8c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x60>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:115
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    2c8a:	c0 c0       	rjmp	.+384    	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
    2c8c:	6c 91       	ld	r22, X
    2c8e:	11 96       	adiw	r26, 0x01	; 1
    2c90:	8d 91       	ld	r24, X+
    2c92:	9c 91       	ld	r25, X
    2c94:	a2 de       	rcall	.-700    	; 0x29da <TwoWire::beginTransmission(unsigned char)>
    2c96:	20 e0       	ldi	r18, 0x00	; 0
    2c98:	41 e0       	ldi	r20, 0x01	; 1
    2c9a:	50 e0       	ldi	r21, 0x00	; 0
    2c9c:	be 01       	movw	r22, r28
    2c9e:	6a 5e       	subi	r22, 0xEA	; 234
    2ca0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ca2:	c7 01       	movw	r24, r14
    2ca4:	0e 94 66 0a 	call	0x14cc	; 0x14cc <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.1]>
write_then_read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:250
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    2ca8:	88 23       	and	r24, r24
    2caa:	09 f4       	brne	.+2      	; 0x2cae <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x82>
    2cac:	af c0       	rjmp	.+350    	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:447
          break;
        }
      #endif

      if (currentStatus & TWI_ARBLOST_bm) {   // Check for Bus error
        module->MSTATUS = TWI_ARBLOST_bm;     // reset error flags
    2cae:	f8 e0       	ldi	r31, 0x08	; 8
    2cb0:	df 2e       	mov	r13, r31
    2cb2:	f7 01       	movw	r30, r14
    2cb4:	44 81       	ldd	r20, Z+4	; 0x04
    2cb6:	55 81       	ldd	r21, Z+5	; 0x05
read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:187
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    2cb8:	21 e0       	ldi	r18, 0x01	; 1
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	41 15       	cp	r20, r1
    2cbe:	51 05       	cpc	r21, r1
    2cc0:	11 f4       	brne	.+4      	; 0x2cc6 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x9a>
    2cc2:	30 e0       	ldi	r19, 0x00	; 0
    2cc4:	20 e0       	ldi	r18, 0x00	; 0
_read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:200

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#elif defined(ARDUINO_ARCH_MEGAAVR)
  size_t recv = _wire->requestFrom(_addr, len, stop);
    2cc6:	d7 01       	movw	r26, r14
    2cc8:	11 96       	adiw	r26, 0x01	; 1
    2cca:	ad 90       	ld	r10, X+
    2ccc:	bc 90       	ld	r11, X
    2cce:	12 97       	sbiw	r26, 0x02	; 2
requestFrom():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:455
 */
twi_buffer_index_t TwoWire::requestFrom(uint8_t  address,  twi_buffer_index_t quantity,  uint8_t sendStop) {
  if (quantity >= BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    2cd0:	8c 91       	ld	r24, X
    2cd2:	88 0f       	add	r24, r24
    2cd4:	f5 01       	movw	r30, r10
    2cd6:	84 87       	std	Z+12, r24	; 0x0c
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:411
    rxHead   = &(_data->_bytesToRead);
    rxTail   = &(_data->_bytesRead);
    rxBuffer =   _data->_rxBuffer;
  #endif

  (*rxTail) = 0;                      // Reset counter
    2cd8:	17 86       	std	Z+15, r1	; 0x0f
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:413

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
    2cda:	00 84       	ldd	r0, Z+8	; 0x08
    2cdc:	f1 85       	ldd	r31, Z+9	; 0x09
    2cde:	e0 2d       	mov	r30, r0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:419
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;

  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    2ce0:	95 81       	ldd	r25, Z+5	; 0x05
    2ce2:	93 70       	andi	r25, 0x03	; 3
read8():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:417

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;
    2ce4:	00 e0       	ldi	r16, 0x00	; 0
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:419

  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    2ce6:	a1 f0       	breq	.+40     	; 0x2d10 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xe4>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:427
    uint8_t command  = 0;
    #if defined (TWI_TIMEOUT_ENABLE)
      uint16_t timeout = 0;
    #endif

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit
    2ce8:	81 60       	ori	r24, 0x01	; 1
    2cea:	87 83       	std	Z+7, r24	; 0x07
read8():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:424
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    #if defined (TWI_TIMEOUT_ENABLE)
      uint16_t timeout = 0;
    2cec:	70 e0       	ldi	r23, 0x00	; 0
    2cee:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:422
  twi_buffer_index_t dataRead = 0;

  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    2cf0:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:417

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;
    2cf2:	00 e0       	ldi	r16, 0x00	; 0
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:430
    #endif

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit

    while (true) {
      currentStatus = module->MSTATUS;
    2cf4:	95 81       	ldd	r25, Z+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:431
      currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
    2cf6:	a9 2f       	mov	r26, r25
    2cf8:	a3 70       	andi	r26, 0x03	; 3
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:434

      #if defined(TWI_TIMEOUT_ENABLE)
        if (++timeout > (F_CPU/1000)) {
    2cfa:	6f 5f       	subi	r22, 0xFF	; 255
    2cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cfe:	61 3c       	cpi	r22, 0xC1	; 193
    2d00:	1d e5       	ldi	r17, 0x5D	; 93
    2d02:	71 07       	cpc	r23, r17
    2d04:	18 f4       	brcc	.+6      	; 0x2d0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xe0>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:446
          }
          break;
        }
      #endif

      if (currentStatus & TWI_ARBLOST_bm) {   // Check for Bus error
    2d06:	93 ff       	sbrs	r25, 3
    2d08:	1c c0       	rjmp	.+56     	; 0x2d42 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x116>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:447
        module->MSTATUS = TWI_ARBLOST_bm;     // reset error flags
    2d0a:	d5 82       	std	Z+5, r13	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:489
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
        }
      }
    }
    (*rxHead) = dataRead;
    2d0c:	f5 01       	movw	r30, r10
    2d0e:	06 87       	std	Z+14, r16	; 0x0e
_read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:200
    2d10:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:205
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
#endif

  if (recv != len) {
    2d12:	02 17       	cp	r16, r18
    2d14:	13 07       	cpc	r17, r19
    2d16:	09 f0       	breq	.+2      	; 0x2d1a <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xee>
    2d18:	79 c0       	rjmp	.+242    	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
read8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:214
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2d1a:	90 e0       	ldi	r25, 0x00	; 0
    2d1c:	80 e0       	ldi	r24, 0x00	; 0
_read():
    2d1e:	80 17       	cp	r24, r16
    2d20:	91 07       	cpc	r25, r17
    2d22:	80 f5       	brcc	.+96     	; 0x2d84 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x158>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:215
    buffer[i] = _wire->read();
    2d24:	d7 01       	movw	r26, r14
    2d26:	11 96       	adiw	r26, 0x01	; 1
    2d28:	8d 91       	ld	r24, X+
    2d2a:	9c 91       	ld	r25, X
    2d2c:	dc 01       	movw	r26, r24
    2d2e:	ed 91       	ld	r30, X+
    2d30:	fc 91       	ld	r31, X
    2d32:	02 84       	ldd	r0, Z+10	; 0x0a
    2d34:	f3 85       	ldd	r31, Z+11	; 0x0b
    2d36:	e0 2d       	mov	r30, r0
    2d38:	09 95       	icall
    2d3a:	8e 87       	std	Y+14, r24	; 0x0e
read8():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:214
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
    2d3c:	81 e0       	ldi	r24, 0x01	; 1
    2d3e:	90 e0       	ldi	r25, 0x00	; 0
    2d40:	ee cf       	rjmp	.-36     	; 0x2d1e <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xf2>
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:452
        module->MSTATUS = TWI_ARBLOST_bm;     // reset error flags
        TWIR_SET_ERROR(TWI_ERR_BUS_ARB);      // set error flag
        break;                                // leave TX loop
      }

      if (command != 0) {
    2d42:	88 23       	and	r24, r24
    2d44:	b9 f0       	breq	.+46     	; 0x2d74 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x148>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:453
        if (currentSM == TWI_BUSSTATE_OWNER_gc) {
    2d46:	a2 30       	cpi	r26, 0x02	; 2
    2d48:	09 f7       	brne	.-62     	; 0x2d0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xe0>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:454
          module->MCTRLB = command;
    2d4a:	84 83       	std	Z+4, r24	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:461
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
    2d4c:	97 ff       	sbrs	r25, 7
    2d4e:	16 c0       	rjmp	.+44     	; 0x2d7c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x150>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:462
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
    2d50:	02 38       	cpi	r16, 0x82	; 130
    2d52:	70 f4       	brcc	.+28     	; 0x2d70 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x144>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:463
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
    2d54:	60 85       	ldd	r22, Z+8	; 0x08
    2d56:	c5 01       	movw	r24, r10
    2d58:	80 0f       	add	r24, r16
    2d5a:	91 1d       	adc	r25, r1
    2d5c:	89 56       	subi	r24, 0x69	; 105
    2d5e:	9f 4f       	sbci	r25, 0xFF	; 255
    2d60:	dc 01       	movw	r26, r24
    2d62:	6c 93       	st	X, r22
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:464
            dataRead++;                              // increment read counter
    2d64:	0f 5f       	subi	r16, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:472
            #endif

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
    2d66:	41 15       	cp	r20, r1
    2d68:	51 05       	cpc	r21, r1
    2d6a:	81 f2       	breq	.-96     	; 0x2d0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xe0>
read8():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:466
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                           // reset timeout
    2d6c:	70 e0       	ldi	r23, 0x00	; 0
    2d6e:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:473

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
                command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
    2d70:	87 e0       	ldi	r24, 0x07	; 7
    2d72:	c0 cf       	rjmp	.-128    	; 0x2cf4 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xc8>
TWI_MasterRead():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:460
        } else {
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
    2d74:	a2 30       	cpi	r26, 0x02	; 2
    2d76:	09 f0       	breq	.+2      	; 0x2d7a <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x14e>
    2d78:	bd cf       	rjmp	.-134    	; 0x2cf4 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xc8>
    2d7a:	e8 cf       	rjmp	.-48     	; 0x2d4c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x120>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:483

          } else {                                        // Buffer overflow with the incoming byte
            TWIR_SET_ERROR(TWI_ERR_BUF_OVERFLOW);         // Set Error and
            command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
          }
        } else if (currentStatus & TWI_WIF_bm) {  // Address NACKed
    2d7c:	96 ff       	sbrs	r25, 6
    2d7e:	ba cf       	rjmp	.-140    	; 0x2cf4 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xc8>
read8():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:485
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
    2d80:	83 e0       	ldi	r24, 0x03	; 3
    2d82:	b8 cf       	rjmp	.-144    	; 0x2cf4 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0xc8>
read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:185
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    2d84:	01 2b       	or	r16, r17
    2d86:	09 f4       	brne	.+2      	; 0x2d8a <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x15e>
    2d88:	94 cf       	rjmp	.-216    	; 0x2cb2 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x86>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:195
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2d8a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d8c:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:197
    value <<= 8;
    if (_byteorder == LSBFIRST) {
    2d8e:	fd 84       	ldd	r15, Y+13	; 0x0d
    2d90:	fe 01       	movw	r30, r28
    2d92:	31 96       	adiw	r30, 0x01	; 1
    2d94:	5f 01       	movw	r10, r30
    2d96:	30 e0       	ldi	r19, 0x00	; 0
    2d98:	20 e0       	ldi	r18, 0x00	; 0
    2d9a:	80 e0       	ldi	r24, 0x00	; 0
    2d9c:	90 e0       	ldi	r25, 0x00	; 0
    2d9e:	dc 01       	movw	r26, r24
    2da0:	bf 01       	movw	r22, r30
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:195
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2da2:	24 17       	cp	r18, r20
    2da4:	35 07       	cpc	r19, r21
    2da6:	ac f5       	brge	.+106    	; 0x2e12 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e6>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:196
    value <<= 8;
    2da8:	ba 2f       	mov	r27, r26
    2daa:	a9 2f       	mov	r26, r25
    2dac:	98 2f       	mov	r25, r24
    2dae:	88 27       	eor	r24, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:197
    if (_byteorder == LSBFIRST) {
    2db0:	f1 10       	cpse	r15, r1
    2db2:	3c c0       	rjmp	.+120    	; 0x2e2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x200>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:198
      value |= _buffer[_width - i - 1];
    2db4:	8a 01       	movw	r16, r20
    2db6:	02 1b       	sub	r16, r18
    2db8:	13 0b       	sbc	r17, r19
    2dba:	06 0f       	add	r16, r22
    2dbc:	17 1f       	adc	r17, r23
    2dbe:	f8 01       	movw	r30, r16
    2dc0:	14 85       	ldd	r17, Z+12	; 0x0c
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:200
    } else {
      value |= _buffer[i];
    2dc2:	81 2b       	or	r24, r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:195
    return -1;
  }

  uint32_t value = 0;

  for (int i = 0; i < _width; i++) {
    2dc4:	2f 5f       	subi	r18, 0xFF	; 255
    2dc6:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc8:	ff ef       	ldi	r31, 0xFF	; 255
    2dca:	af 1a       	sub	r10, r31
    2dcc:	bf 0a       	sbc	r11, r31
    2dce:	e9 cf       	rjmp	.-46     	; 0x2da2 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x176>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:249
    if (_spiregtype == AD8_HIGH_TOREAD_AD7_HIGH_TOINC) {
      addrbuffer[0] |= 0x80 | 0x40;
    }
    return _spidevice->write_then_read(addrbuffer, _addrwidth, buffer, len);
  }
  if (_genericdevice) {
    2dd0:	ad 81       	ldd	r26, Y+5	; 0x05
    2dd2:	be 81       	ldd	r27, Y+6	; 0x06
    2dd4:	10 97       	sbiw	r26, 0x00	; 0
    2dd6:	d1 f0       	breq	.+52     	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
readRegister():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_GenericDevice.cpp:65
   @param buf Buffer to store read data
   @param bufsiz Size of data to read in bytes
   @return true if read was successful, otherwise false */
bool Adafruit_GenericDevice::readRegister(uint8_t *addr_buf, uint8_t addrsiz,
                                          uint8_t *buf, uint16_t bufsiz) {
  if (!_begun || !_readreg_func)
    2dd8:	18 96       	adiw	r26, 0x08	; 8
    2dda:	8c 91       	ld	r24, X
    2ddc:	18 97       	sbiw	r26, 0x08	; 8
    2dde:	88 23       	and	r24, r24
    2de0:	a9 f0       	breq	.+42     	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
    2de2:	14 96       	adiw	r26, 0x04	; 4
    2de4:	ed 91       	ld	r30, X+
    2de6:	fc 91       	ld	r31, X
    2de8:	15 97       	sbiw	r26, 0x05	; 5
    2dea:	30 97       	sbiw	r30, 0x00	; 0
    2dec:	79 f0       	breq	.+30     	; 0x2e0c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x1e0>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_GenericDevice.cpp:67
    return false;
  return _readreg_func(_obj, addr_buf, addrsiz, buf, bufsiz);
    2dee:	01 e0       	ldi	r16, 0x01	; 1
    2df0:	10 e0       	ldi	r17, 0x00	; 0
    2df2:	9e 01       	movw	r18, r28
    2df4:	22 5f       	subi	r18, 0xF2	; 242
    2df6:	3f 4f       	sbci	r19, 0xFF	; 255
    2df8:	41 e0       	ldi	r20, 0x01	; 1
    2dfa:	be 01       	movw	r22, r28
    2dfc:	6a 5e       	subi	r22, 0xEA	; 234
    2dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2e00:	19 96       	adiw	r26, 0x09	; 9
    2e02:	8d 91       	ld	r24, X+
    2e04:	9c 91       	ld	r25, X
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:189
 *    @brief  Read data from the register location. This does not do any error
 * checking!
 *    @return Returns 0xFFFFFFFF on failure, value otherwise
 */
uint32_t Adafruit_BusIO_Register::read(void) {
  if (!read(_buffer, _width)) {
    2e06:	09 95       	icall
read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:190
    return -1;
    2e08:	81 11       	cpse	r24, r1
    2e0a:	bf cf       	rjmp	.-130    	; 0x2d8a <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x15e>
read8():
    2e0c:	8f ef       	ldi	r24, 0xFF	; 255
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:179
  return reg.read();
}
    2e0e:	9f ef       	ldi	r25, 0xFF	; 255
    2e10:	dc 01       	movw	r26, r24
    2e12:	67 96       	adiw	r28, 0x17	; 23
    2e14:	cd bf       	out	0x3d, r28	; 61
    2e16:	de bf       	out	0x3e, r29	; 62
    2e18:	df 91       	pop	r29
    2e1a:	cf 91       	pop	r28
    2e1c:	1f 91       	pop	r17
    2e1e:	0f 91       	pop	r16
    2e20:	ff 90       	pop	r15
    2e22:	ef 90       	pop	r14
    2e24:	df 90       	pop	r13
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_BusIO_Register.cpp:200
  for (int i = 0; i < _width; i++) {
    value <<= 8;
    if (_byteorder == LSBFIRST) {
      value |= _buffer[_width - i - 1];
    } else {
      value |= _buffer[i];
    2e26:	bf 90       	pop	r11
    2e28:	af 90       	pop	r10
    2e2a:	08 95       	ret
read():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:62
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
    2e2c:	f5 01       	movw	r30, r10
    2e2e:	15 85       	ldd	r17, Z+13	; 0x0d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:64
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2e30:	c8 cf       	rjmp	.-112    	; 0x2dc2 <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]+0x196>

00002e32 <Adafruit_I2CDevice::detected()>:
detected():
    2e32:	cf 93       	push	r28
    2e34:	df 93       	push	r29
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:69
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
    2e36:	ec 01       	movw	r28, r24
    2e38:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3a:	88 23       	and	r24, r24
    2e3c:	71 f0       	breq	.+28     	; 0x2e5a <Adafruit_I2CDevice::detected()+0x28>
    2e3e:	68 81       	ld	r22, Y
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:77
  DEBUG_SERIAL.print(_addr, HEX);
#endif
#ifdef ARDUINO_ARCH_MBED
  _wire->write(0); // forces a write request instead of a read
#endif
  if (_wire->endTransmission() == 0) {
    2e40:	89 81       	ldd	r24, Y+1	; 0x01
    2e42:	9a 81       	ldd	r25, Y+2	; 0x02
    2e44:	ca dd       	rcall	.-1132   	; 0x29da <TwoWire::beginTransmission(unsigned char)>
    2e46:	89 81       	ldd	r24, Y+1	; 0x01
    2e48:	9a 81       	ldd	r25, Y+2	; 0x02
    2e4a:	ac db       	rcall	.-2216   	; 0x25a4 <TwoWire::endTransmission()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:87
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F(" Not detected"));
#endif
  return false;
}
    2e4c:	91 e0       	ldi	r25, 0x01	; 1
    2e4e:	81 11       	cpse	r24, r1
    2e50:	90 e0       	ldi	r25, 0x00	; 0
    2e52:	89 2f       	mov	r24, r25
    2e54:	df 91       	pop	r29
    2e56:	cf 91       	pop	r28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:51
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_data->_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if ((_data->_bools._hostEnabled | _data->_bools._clientEnabled) == 1) {  //If either are enabled
    2e58:	08 95       	ret
    2e5a:	89 81       	ldd	r24, Y+1	; 0x01
    2e5c:	9a 81       	ldd	r25, Y+2	; 0x02
TWI_MasterInit():
    2e5e:	fc 01       	movw	r30, r24
    2e60:	22 85       	ldd	r18, Z+10	; 0x0a
    2e62:	21 fd       	sbrc	r18, 1
    2e64:	04 c0       	rjmp	.+8      	; 0x2e6e <Adafruit_I2CDevice::detected()+0x3c>
    2e66:	22 fd       	sbrc	r18, 2
    2e68:	02 c0       	rjmp	.+4      	; 0x2e6e <Adafruit_I2CDevice::detected()+0x3c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:32
 * don't respond well to a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;
    2e6a:	08 96       	adiw	r24, 0x08	; 8
    2e6c:	9d dd       	rcall	.-1222   	; 0x29a8 <TWI_MasterInit.part.4>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:35

  if (addr_detect) {
    return detected();
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	8b 83       	std	Y+3, r24	; 0x03
    2e72:	ce 01       	movw	r24, r28
    2e74:	de df       	rcall	.-68     	; 0x2e32 <Adafruit_I2CDevice::detected()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:64
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
    2e76:	98 2f       	mov	r25, r24
detected():
    2e78:	81 11       	cpse	r24, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:392
                   the command character to send to the display.
                   Refer to ssd1306 data sheet for commands
    @return None (void).
    @note
*/
void Adafruit_SSD1306::ssd1306_command1(uint8_t c) {
    2e7a:	e1 cf       	rjmp	.-62     	; 0x2e3e <Adafruit_I2CDevice::detected()+0xc>
    2e7c:	ea cf       	rjmp	.-44     	; 0x2e52 <Adafruit_I2CDevice::detected()+0x20>

00002e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>:
ssd1306_command1():
    2e7e:	1f 93       	push	r17
    2e80:	cf 93       	push	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:393
  if (wire) { // I2C
    2e82:	df 93       	push	r29
    2e84:	ec 01       	movw	r28, r24
    2e86:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e88:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e8a:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.h:91
    2e8c:	e9 f0       	breq	.+58     	; 0x2ec8 <Adafruit_SSD1306::ssd1306_command1(unsigned char)+0x4a>
    2e8e:	16 2f       	mov	r17, r22
_ZN7TwoWire17beginTransmissionEi():
    2e90:	69 a1       	ldd	r22, Y+33	; 0x21
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:395
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    2e92:	a3 dd       	rcall	.-1210   	; 0x29da <TwoWire::beginTransmission(unsigned char)>
ssd1306_command1():
    2e94:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2e96:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2e98:	dc 01       	movw	r26, r24
    2e9a:	ed 91       	ld	r30, X+
    2e9c:	fc 91       	ld	r31, X
    2e9e:	01 90       	ld	r0, Z+
    2ea0:	f0 81       	ld	r31, Z
    2ea2:	e0 2d       	mov	r30, r0
    2ea4:	60 e0       	ldi	r22, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:396
    WIRE_WRITE(c);
    2ea6:	09 95       	icall
    2ea8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2eaa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2eac:	dc 01       	movw	r26, r24
    2eae:	ed 91       	ld	r30, X+
    2eb0:	fc 91       	ld	r31, X
    2eb2:	01 90       	ld	r0, Z+
    2eb4:	f0 81       	ld	r31, Z
    2eb6:	e0 2d       	mov	r30, r0
    2eb8:	61 2f       	mov	r22, r17
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:397
    wire->endTransmission();
    2eba:	09 95       	icall
    2ebc:	8d 8d       	ldd	r24, Y+29	; 0x1d
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:402
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
    2ebe:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2ec0:	df 91       	pop	r29
    2ec2:	cf 91       	pop	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:397
void Adafruit_SSD1306::ssd1306_command1(uint8_t c) {
  if (wire) { // I2C
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x00); // Co = 0, D/C = 0
    WIRE_WRITE(c);
    wire->endTransmission();
    2ec4:	1f 91       	pop	r17
    2ec6:	6e cb       	rjmp	.-2340   	; 0x25a4 <TwoWire::endTransmission()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:399
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    2ec8:	ad a5       	ldd	r26, Y+45	; 0x2d
    2eca:	be a5       	ldd	r27, Y+46	; 0x2e
    2ecc:	9c 91       	ld	r25, X
    2ece:	8b a9       	ldd	r24, Y+51	; 0x33
    2ed0:	80 95       	com	r24
    2ed2:	89 23       	and	r24, r25
    2ed4:	8c 93       	st	X, r24
_ZN16Adafruit_SSD13068SPIwriteEh():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    2ed6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ed8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2eda:	89 2b       	or	r24, r25
    2edc:	31 f0       	breq	.+12     	; 0x2eea <Adafruit_SSD1306::ssd1306_command1(unsigned char)+0x6c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:361
    (void)spi->transfer(d);
    2ede:	86 2f       	mov	r24, r22
ssd1306_command1():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:402
    wire->endTransmission();
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
    2ee0:	df 91       	pop	r29
    2ee2:	cf 91       	pop	r28
    2ee4:	1f 91       	pop	r17
_ZN16Adafruit_SSD13068SPIwriteEh():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:361
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
    2ee6:	0c 94 3d 06 	jmp	0xc7a	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    2eea:	28 e0       	ldi	r18, 0x08	; 8
    2eec:	30 e0       	ldi	r19, 0x00	; 0
ssd1306_command1():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    2eee:	80 e8       	ldi	r24, 0x80	; 128
    2ef0:	a9 a5       	ldd	r26, Y+41	; 0x29
    2ef2:	ba a5       	ldd	r27, Y+42	; 0x2a
    2ef4:	99 a9       	ldd	r25, Y+49	; 0x31
_ZN16Adafruit_SSD13068SPIwriteEh():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:365
#ifdef HAVE_PORTREG
      if (d & bit)
    2ef6:	46 2f       	mov	r20, r22
    2ef8:	48 23       	and	r20, r24
    2efa:	c1 f0       	breq	.+48     	; 0x2f2c <Adafruit_SSD1306::ssd1306_command1(unsigned char)+0xae>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:366
        *mosiPort |= mosiPinMask;
    2efc:	4c 91       	ld	r20, X
    2efe:	94 2b       	or	r25, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
      else
        *mosiPort &= ~mosiPinMask;
    2f00:	9c 93       	st	X, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:369
      *clkPort |= clkPinMask;  // Clock high
    2f02:	ab a5       	ldd	r26, Y+43	; 0x2b
    2f04:	bc a5       	ldd	r27, Y+44	; 0x2c
    2f06:	9c 91       	ld	r25, X
    2f08:	4a a9       	ldd	r20, Y+50	; 0x32
    2f0a:	94 2b       	or	r25, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:370
      *clkPort &= ~clkPinMask; // Clock low
    2f0c:	9c 93       	st	X, r25
    2f0e:	ab a5       	ldd	r26, Y+43	; 0x2b
    2f10:	bc a5       	ldd	r27, Y+44	; 0x2c
    2f12:	4c 91       	ld	r20, X
    2f14:	9a a9       	ldd	r25, Y+50	; 0x32
    2f16:	90 95       	com	r25
    2f18:	94 23       	and	r25, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    2f1a:	9c 93       	st	X, r25
    2f1c:	86 95       	lsr	r24
    2f1e:	21 50       	subi	r18, 0x01	; 1
    2f20:	31 09       	sbc	r19, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:402
    wire->endTransmission();
  } else { // SPI (hw or soft) -- transaction started in calling function
    SSD1306_MODE_COMMAND
    SPIwrite(c);
  }
}
    2f22:	31 f7       	brne	.-52     	; 0x2ef0 <Adafruit_SSD1306::ssd1306_command1(unsigned char)+0x72>
ssd1306_command1():
    2f24:	df 91       	pop	r29
    2f26:	cf 91       	pop	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
    2f28:	1f 91       	pop	r17
    2f2a:	08 95       	ret
_ZN16Adafruit_SSD13068SPIwriteEh():
    2f2c:	4c 91       	ld	r20, X
    2f2e:	90 95       	com	r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1164
            display() function -- buffer contents are not changed, rather a
            different pixel mode of the display hardware is used. When
            enabled, drawing SSD1306_BLACK (value 0) pixels will actually draw
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
    2f30:	94 23       	and	r25, r20
    2f32:	e6 cf       	rjmp	.-52     	; 0x2f00 <Adafruit_SSD1306::ssd1306_command1(unsigned char)+0x82>

00002f34 <Adafruit_SSD1306::invertDisplay(bool)>:
invertDisplay():
    2f34:	1f 93       	push	r17
    2f36:	cf 93       	push	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1165
  TRANSACTION_START
    2f38:	df 93       	push	r29
    2f3a:	ec 01       	movw	r28, r24
    2f3c:	16 2f       	mov	r17, r22
    2f3e:	8d 8d       	ldd	r24, Y+29	; 0x1d
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
 *@return     uint8_t
 *@retval       0 if no error occurred
 *@retval       1 if a problem occurred
 */
uint8_t TwoWire::setClock(uint32_t clock) {
  return TWI_MasterSetBaud(&vars, clock);
    2f40:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2f42:	00 97       	sbiw	r24, 0x00	; 0
    2f44:	c1 f0       	breq	.+48     	; 0x2f76 <Adafruit_SSD1306::invertDisplay(bool)+0x42>
setClock():
    2f46:	4d a9       	ldd	r20, Y+53	; 0x35
    2f48:	5e a9       	ldd	r21, Y+54	; 0x36
    2f4a:	6f a9       	ldd	r22, Y+55	; 0x37
    2f4c:	78 ad       	ldd	r23, Y+56	; 0x38
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1166
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
    2f4e:	08 96       	adiw	r24, 0x08	; 8
    2f50:	1e dd       	rcall	.-1476   	; 0x298e <TWI_MasterSetBaud>
invertDisplay():
    2f52:	66 ea       	ldi	r22, 0xA6	; 166
    2f54:	11 11       	cpse	r17, r1
    2f56:	67 ea       	ldi	r22, 0xA7	; 167
    2f58:	ce 01       	movw	r24, r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1167
  TRANSACTION_END
    2f5a:	91 df       	rcall	.-222    	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    2f5c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2f5e:	9e 8d       	ldd	r25, Y+30	; 0x1e
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
    2f60:	00 97       	sbiw	r24, 0x00	; 0
    2f62:	c1 f0       	breq	.+48     	; 0x2f94 <Adafruit_SSD1306::invertDisplay(bool)+0x60>
setClock():
    2f64:	49 ad       	ldd	r20, Y+57	; 0x39
    2f66:	5a ad       	ldd	r21, Y+58	; 0x3a
    2f68:	6b ad       	ldd	r22, Y+59	; 0x3b
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1168
}
    2f6a:	7c ad       	ldd	r23, Y+60	; 0x3c
    2f6c:	08 96       	adiw	r24, 0x08	; 8
invertDisplay():
    2f6e:	df 91       	pop	r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
    2f70:	cf 91       	pop	r28
    2f72:	1f 91       	pop	r17
setClock():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1165
            different pixel mode of the display hardware is used. When
            enabled, drawing SSD1306_BLACK (value 0) pixels will actually draw
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
  TRANSACTION_START
    2f74:	0c cd       	rjmp	.-1512   	; 0x298e <TWI_MasterSetBaud>
invertDisplay():
    2f76:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2f78:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2f7a:	00 97       	sbiw	r24, 0x00	; 0
    2f7c:	19 f0       	breq	.+6      	; 0x2f84 <Adafruit_SSD1306::invertDisplay(bool)+0x50>
    2f7e:	6e ad       	ldd	r22, Y+62	; 0x3e
    2f80:	7f ad       	ldd	r23, Y+63	; 0x3f
    2f82:	23 db       	rcall	.-2490   	; 0x25ca <SPIClass::beginTransaction(SPISettings)>
    2f84:	ef a5       	ldd	r30, Y+47	; 0x2f
    2f86:	f8 a9       	ldd	r31, Y+48	; 0x30
    2f88:	90 81       	ld	r25, Z
    2f8a:	8c a9       	ldd	r24, Y+52	; 0x34
    2f8c:	80 95       	com	r24
    2f8e:	89 23       	and	r24, r25
    2f90:	80 83       	st	Z, r24
    2f92:	df cf       	rjmp	.-66     	; 0x2f52 <Adafruit_SSD1306::invertDisplay(bool)+0x1e>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1167
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
  TRANSACTION_END
    2f94:	ef a5       	ldd	r30, Y+47	; 0x2f
    2f96:	f8 a9       	ldd	r31, Y+48	; 0x30
    2f98:	80 81       	ld	r24, Z
    2f9a:	9c a9       	ldd	r25, Y+52	; 0x34
    2f9c:	89 2b       	or	r24, r25
    2f9e:	80 83       	st	Z, r24
    2fa0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2fa2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2fa4:	00 97       	sbiw	r24, 0x00	; 0
    2fa6:	21 f0       	breq	.+8      	; 0x2fb0 <Adafruit_SSD1306::invertDisplay(bool)+0x7c>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1168
}
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1167
   white, SSD1306_WHITE (value 1) will draw black.
*/
void Adafruit_SSD1306::invertDisplay(bool i) {
  TRANSACTION_START
  ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
  TRANSACTION_END
    2fac:	1f 91       	pop	r17
    2fae:	02 cb       	rjmp	.-2556   	; 0x25b4 <SPIClass::endTransaction()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1168
}
    2fb0:	df 91       	pop	r29
    2fb2:	cf 91       	pop	r28
    2fb4:	1f 91       	pop	r17
    2fb6:	08 95       	ret

00002fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.h:56
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) {
        return 0;
      }
      return write((const uint8_t *)str, strlen(str));
    2fb8:	fc 01       	movw	r30, r24
    2fba:	01 90       	ld	r0, Z+
    2fbc:	00 20       	and	r0, r0
    2fbe:	e9 f7       	brne	.-6      	; 0x2fba <Print::write(char const*) [clone .part.2] [clone .constprop.57]+0x2>
    2fc0:	31 97       	sbiw	r30, 0x01	; 1
    2fc2:	af 01       	movw	r20, r30
    2fc4:	48 1b       	sub	r20, r24
    2fc6:	59 0b       	sbc	r21, r25
    2fc8:	bc 01       	movw	r22, r24
    2fca:	87 e9       	ldi	r24, 0x97	; 151
    2fcc:	93 e6       	ldi	r25, 0x63	; 99
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:113

size_t Print::print(double n, int digits) {
  return printFloat(n, digits);
}

size_t Print::println(const __FlashStringHelper *ifsh) {
    2fce:	0c 94 79 07 	jmp	0xef2	; 0xef2 <Print::write(unsigned char const*, unsigned int)>

00002fd2 <Print::println(__FlashStringHelper const*) [clone .constprop.54]>:
println():
    2fd2:	0f 93       	push	r16
    2fd4:	1f 93       	push	r17
    2fd6:	cf 93       	push	r28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:44
}

size_t Print::print(const __FlashStringHelper *ifsh) {
  #if defined(__AVR__)
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
    2fd8:	df 93       	push	r29
    2fda:	8c 01       	movw	r16, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:46
  while (1) {
    unsigned char c = pgm_read_byte(p++);
    2fdc:	d0 e0       	ldi	r29, 0x00	; 0
    2fde:	c0 e0       	ldi	r28, 0x00	; 0
print():
    2fe0:	f8 01       	movw	r30, r16
    2fe2:	ec 0f       	add	r30, r28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:47
    if (c == 0) {
    2fe4:	fd 1f       	adc	r31, r29
    2fe6:	64 91       	lpm	r22, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:50
      break;
    }
    if (write(c)) {
    2fe8:	66 23       	and	r22, r22
    2fea:	41 f0       	breq	.+16     	; 0x2ffc <Print::println(__FlashStringHelper const*) [clone .constprop.54]+0x2a>
    2fec:	87 e9       	ldi	r24, 0x97	; 151
    2fee:	93 e6       	ldi	r25, 0x63	; 99
    2ff0:	0e 94 2e 08 	call	0x105c	; 0x105c <HardwareSerial::write(unsigned char)>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:51
      n++;
    2ff4:	89 2b       	or	r24, r25
    2ff6:	11 f0       	breq	.+4      	; 0x2ffc <Print::println(__FlashStringHelper const*) [clone .constprop.54]+0x2a>
    2ff8:	21 96       	adiw	r28, 0x01	; 1
    2ffa:	f2 cf       	rjmp	.-28     	; 0x2fe0 <Print::println(__FlashStringHelper const*) [clone .constprop.54]+0xe>
write():
    2ffc:	8c ee       	ldi	r24, 0xEC	; 236
    2ffe:	92 e6       	ldi	r25, 0x62	; 98
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:117

size_t Print::println(const __FlashStringHelper *ifsh) {
  size_t n = print(ifsh);
  n += println();
  return n;
}
    3000:	db df       	rcall	.-74     	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
println():
    3002:	8c 0f       	add	r24, r28
    3004:	9d 1f       	adc	r25, r29
    3006:	df 91       	pop	r29
    3008:	cf 91       	pop	r28
    300a:	1f 91       	pop	r17
    300c:	0f 91       	pop	r16
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:133
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[]) {
    300e:	08 95       	ret

00003010 <Print::println(char const*) [clone .constprop.25]>:
    3010:	cf 93       	push	r28
    3012:	df 93       	push	r29
write():
    3014:	d1 df       	rcall	.-94     	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
    3016:	ec 01       	movw	r28, r24
    3018:	8c ee       	ldi	r24, 0xEC	; 236
    301a:	92 e6       	ldi	r25, 0x62	; 98
    301c:	cd df       	rcall	.-102    	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
println():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:137
  size_t n = print(c);
  n += println();
  return n;
}
    301e:	8c 0f       	add	r24, r28
    3020:	9d 1f       	adc	r25, r29
    3022:	df 91       	pop	r29
    3024:	cf 91       	pop	r28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/abi.cpp:27
extern "C" void __cxa_deleted_virtual(void) __attribute__((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  // std::terminate();
  abort();
    3026:	08 95       	ret

00003028 <__cxa_pure_virtual>:
__cxa_pure_virtual():
    3028:	0e 94 c9 27 	call	0x4f92	; 0x4f92 <abort>

0000302c <__vector_30>:
__vector_30():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:135
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #elif !defined(MILLIS_USE_TIMERNONE)
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
    302c:	ef 93       	push	r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:140
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
    302e:	ff 93       	push	r31
    3030:	e3 e9       	ldi	r30, 0x93	; 147
    3032:	f3 e6       	ldi	r31, 0x63	; 99
    3034:	8f 93       	push	r24
    3036:	8f b7       	in	r24, 0x3f	; 63
    3038:	8f 93       	push	r24
    303a:	80 81       	ld	r24, Z
    303c:	8f 5f       	subi	r24, 0xFF	; 255
    303e:	80 83       	st	Z, r24
    3040:	81 81       	ldd	r24, Z+1	; 0x01
    3042:	8f 4f       	sbci	r24, 0xFF	; 255
    3044:	81 83       	std	Z+1, r24	; 0x01
    3046:	82 81       	ldd	r24, Z+2	; 0x02
    3048:	8f 4f       	sbci	r24, 0xFF	; 255
    304a:	82 83       	std	Z+2, r24	; 0x02
    304c:	83 81       	ldd	r24, Z+3	; 0x03
    304e:	8f 4f       	sbci	r24, 0xFF	; 255
    3050:	83 83       	std	Z+3, r24	; 0x03
    3052:	81 e0       	ldi	r24, 0x01	; 1
    3054:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
    3058:	8f 91       	pop	r24
    305a:	8f bf       	out	0x3f, r24	; 63
    305c:	8f 91       	pop	r24
    305e:	ff 91       	pop	r31
    3060:	ef 91       	pop	r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:119
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
    3062:	18 95       	reti

00003064 <__vector_22>:
__vector_22():
    3064:	ef 93       	push	r30
    3066:	ff 93       	push	r31
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:126
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial0));
    3068:	f8 98       	cbi	0x1f, 0	; 31
    306a:	e7 e9       	ldi	r30, 0x97	; 151
    306c:	f3 e6       	ldi	r31, 0x63	; 99
    306e:	0b c0       	rjmp	.+22     	; 0x3086 <_do_dre()>

00003070 <__vector_21>:
__vector_21():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:96
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
    3070:	ef 93       	push	r30
    3072:	ff 93       	push	r31
    3074:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:103
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
    3076:	e7 e9       	ldi	r30, 0x97	; 151
    3078:	f3 e6       	ldi	r31, 0x63	; 99
    307a:	34 c0       	rjmp	.+104    	; 0x30e4 <_do_rxc()>

0000307c <__vector_23>:
__vector_23():
    307c:	ef 93       	push	r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:59
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART0_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
    307e:	ff 93       	push	r31
    3080:	e7 e9       	ldi	r30, 0x97	; 151
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART0.cpp:66
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial0));
    3082:	f3 e6       	ldi	r31, 0x63	; 99
    3084:	5f c0       	rjmp	.+190    	; 0x3144 <_do_txc()>

00003086 <_do_dre()>:
_Z7_do_drev():
    3086:	2f 93       	push	r18
    3088:	2f b7       	in	r18, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:388
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
    308a:	2f 93       	push	r18
    308c:	8f 93       	push	r24
    308e:	9f 93       	push	r25
    3090:	af 93       	push	r26
    3092:	bf 93       	push	r27
    3094:	68 94       	set

00003096 <_poll_dre>:
    3096:	cf 93       	push	r28
    3098:	df 93       	push	r29
    309a:	20 e0       	ldi	r18, 0x00	; 0
    309c:	c0 85       	ldd	r28, Z+8	; 0x08
    309e:	d8 e0       	ldi	r29, 0x08	; 8
    30a0:	92 89       	ldd	r25, Z+18	; 0x12
    30a2:	df 01       	movw	r26, r30
    30a4:	a9 0f       	add	r26, r25
    30a6:	b2 1f       	adc	r27, r18
    30a8:	ad 5a       	subi	r26, 0xAD	; 173
    30aa:	bf 4f       	sbci	r27, 0xFF	; 255
    30ac:	8c 91       	ld	r24, X
    30ae:	20 e4       	ldi	r18, 0x40	; 64
    30b0:	2c 83       	std	Y+4, r18	; 0x04
    30b2:	8a 83       	std	Y+2, r24	; 0x02
    30b4:	9f 5f       	subi	r25, 0xFF	; 255
    30b6:	9f 73       	andi	r25, 0x3F	; 63
    30b8:	8d 81       	ldd	r24, Y+5	; 0x05
    30ba:	21 89       	ldd	r18, Z+17	; 0x11
    30bc:	29 13       	cpse	r18, r25
    30be:	02 c0       	rjmp	.+4      	; 0x30c4 <_done_dre_irq>
    30c0:	8f 7d       	andi	r24, 0xDF	; 223
    30c2:	8d 83       	std	Y+5, r24	; 0x05

000030c4 <_done_dre_irq>:
    30c4:	92 8b       	std	Z+18, r25	; 0x12
    30c6:	df 91       	pop	r29
    30c8:	cf 91       	pop	r28
    30ca:	16 f0       	brts	.+4      	; 0x30d0 <_done_dre_irq+0xc>
    30cc:	0c 94 2d 08 	jmp	0x105a	; 0x105a <_poll_dre_done>
    30d0:	bf 91       	pop	r27
    30d2:	af 91       	pop	r26
    30d4:	9f 91       	pop	r25
    30d6:	8f 91       	pop	r24
    30d8:	2f 91       	pop	r18
    30da:	2f bf       	out	0x3f, r18	; 63
    30dc:	2f 91       	pop	r18
    30de:	ff 91       	pop	r31
    30e0:	ef 91       	pop	r30
    30e2:	18 95       	reti

000030e4 <_do_rxc()>:
_Z7_do_rxcv():
    30e4:	2f 93       	push	r18
    30e6:	2f b7       	in	r18, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
    30e8:	2f 93       	push	r18
    30ea:	3f 93       	push	r19
    30ec:	8f 93       	push	r24
    30ee:	9f 93       	push	r25
    30f0:	cf 93       	push	r28
    30f2:	df 93       	push	r29
    30f4:	c0 85       	ldd	r28, Z+8	; 0x08
    30f6:	d8 e0       	ldi	r29, 0x08	; 8
    30f8:	2e 81       	ldd	r18, Y+6	; 0x06
    30fa:	2f 7e       	andi	r18, 0xEF	; 239
    30fc:	2e 83       	std	Y+6, r18	; 0x06
    30fe:	89 81       	ldd	r24, Y+1	; 0x01
    3100:	98 81       	ld	r25, Y
    3102:	86 74       	andi	r24, 0x46	; 70
    3104:	88 0f       	add	r24, r24
    3106:	36 85       	ldd	r19, Z+14	; 0x0e
    3108:	38 2b       	or	r19, r24
    310a:	82 fd       	sbrc	r24, 2
    310c:	0d c0       	rjmp	.+26     	; 0x3128 <_end_rxc>
    310e:	c7 85       	ldd	r28, Z+15	; 0x0f
    3110:	81 e0       	ldi	r24, 0x01	; 1
    3112:	8c 0f       	add	r24, r28
    3114:	8f 73       	andi	r24, 0x3F	; 63
    3116:	20 89       	ldd	r18, Z+16	; 0x10
    3118:	28 17       	cp	r18, r24
    311a:	91 f0       	breq	.+36     	; 0x3140 <_buff_full_rxc>
    311c:	ce 0f       	add	r28, r30
    311e:	df 2f       	mov	r29, r31
    3120:	20 e0       	ldi	r18, 0x00	; 0
    3122:	d2 1f       	adc	r29, r18
    3124:	9b 8b       	std	Y+19, r25	; 0x13
    3126:	87 87       	std	Z+15, r24	; 0x0f

00003128 <_end_rxc>:
    3128:	36 87       	std	Z+14, r19	; 0x0e
    312a:	df 91       	pop	r29
    312c:	cf 91       	pop	r28
    312e:	9f 91       	pop	r25
    3130:	8f 91       	pop	r24
    3132:	3f 91       	pop	r19
    3134:	2f 91       	pop	r18
    3136:	2f bf       	out	0x3f, r18	; 63
    3138:	2f 91       	pop	r18
    313a:	ff 91       	pop	r31
    313c:	ef 91       	pop	r30
    313e:	18 95       	reti

00003140 <_buff_full_rxc>:
    3140:	30 64       	ori	r19, 0x40	; 64
    3142:	f2 cf       	rjmp	.-28     	; 0x3128 <_end_rxc>

00003144 <_do_txc()>:
_Z7_do_txcv():
    3144:	8f 93       	push	r24
    3146:	8f b7       	in	r24, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
    3148:	8f 93       	push	r24
    314a:	9f 93       	push	r25
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	c0 85       	ldd	r28, Z+8	; 0x08
    3152:	d8 e0       	ldi	r29, 0x08	; 8
    3154:	9d 81       	ldd	r25, Y+5	; 0x05

00003156 <_txc_flush_rx>:
    3156:	88 81       	ld	r24, Y
    3158:	8c 81       	ldd	r24, Y+4	; 0x04
    315a:	87 fd       	sbrc	r24, 7
    315c:	fc cf       	rjmp	.-8      	; 0x3156 <_txc_flush_rx>
    315e:	9f 7b       	andi	r25, 0xBF	; 191
    3160:	90 68       	ori	r25, 0x80	; 128
    3162:	9d 83       	std	Y+5, r25	; 0x05
    3164:	df 91       	pop	r29
    3166:	cf 91       	pop	r28
    3168:	9f 91       	pop	r25
    316a:	8f 91       	pop	r24
    316c:	8f bf       	out	0x3f, r24	; 63
    316e:	8f 91       	pop	r24
    3170:	ff 91       	pop	r31
    3172:	ef 91       	pop	r30
    3174:	18 95       	reti

00003176 <__vector_18>:
__vector_18():
    3176:	1f 92       	push	r1
    3178:	0f 92       	push	r0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:977


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
    317a:	0f b6       	in	r0, 0x3f	; 63
    317c:	0f 92       	push	r0
    317e:	11 24       	eor	r1, r1
    3180:	1f 93       	push	r17
    3182:	2f 93       	push	r18
    3184:	3f 93       	push	r19
    3186:	4f 93       	push	r20
    3188:	5f 93       	push	r21
    318a:	6f 93       	push	r22
    318c:	7f 93       	push	r23
    318e:	8f 93       	push	r24
    3190:	9f 93       	push	r25
    3192:	af 93       	push	r26
    3194:	bf 93       	push	r27
    3196:	cf 93       	push	r28
    3198:	df 93       	push	r29
    319a:	ef 93       	push	r30
    319c:	ff 93       	push	r31
TWI_HandleSlaveIRQ():
    319e:	c8 e5       	ldi	r28, 0x58	; 88
    31a0:	d4 e6       	ldi	r29, 0x64	; 100
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:521
  // used as a frame pointer and the compiler avoids using it. So, using it comes with a price of pushing/popping
  // r28/r29, as well as ldi the address of the struct into those, so it only makes sense in a few cases like this.
  // Since the Y register is not call-clobbered, it can be considered persistent in this function and has not to
  // be restored after the icall to the user callbacks, unlike Z (which is used for _module and icall).

  _fastPtr_y(_data,_data);  // force _data into Y and instruct to not change Y
    31a2:	e8 81       	ld	r30, Y
    31a4:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:563
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = _data->_module->SSTATUS;
    31a6:	83 85       	ldd	r24, Z+11	; 0x0b
    31a8:	86 ff       	sbrs	r24, 6
    31aa:	56 c0       	rjmp	.+172    	; 0x3258 <__vector_18+0xe2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:565

  if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
    31ac:	80 ff       	sbrs	r24, 0
    31ae:	41 c0       	rjmp	.+130    	; 0x3232 <__vector_18+0xbc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:566
    if (clientStatus & TWI_AP_bm) {    // Address bit set
    31b0:	15 85       	ldd	r17, Z+13	; 0x0d
    31b2:	81 ff       	sbrs	r24, 1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:567
      uint8_t payload = _data->_module->SDATA;  // read address from data register
    31b4:	38 c0       	rjmp	.+112    	; 0x3226 <__vector_18+0xb0>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:568
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
    31b6:	8e 81       	ldd	r24, Y+6	; 0x06
    31b8:	88 23       	and	r24, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:569
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
    31ba:	59 f0       	breq	.+22     	; 0x31d2 <__vector_18+0x5c>
popSleep():
    31bc:	80 91 0a 63 	lds	r24, 0x630A	; 0x80630a <__data_end>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:689
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
    31c0:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
TWI_HandleSlaveIRQ():
    31c4:	eb 85       	ldd	r30, Y+11	; 0x0b
    31c6:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:571
    if (clientStatus & TWI_AP_bm) {    // Address bit set
      uint8_t payload = _data->_module->SDATA;  // read address from data register
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
          popSleep();                           // (have to treat REPSTART as another pop for sleep)
          if (_data->user_onReceive != NULL) {  // so when a Master Read occurs after a Master write
    31c8:	30 97       	sbiw	r30, 0x00	; 0
    31ca:	19 f0       	breq	.+6      	; 0x31d2 <__vector_18+0x5c>
    31cc:	8e 81       	ldd	r24, Y+6	; 0x06
    31ce:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:572
            _data->user_onReceive((*rxHead));   // issue a call to the user callback first
    31d0:	09 95       	icall
    31d2:	1c 83       	std	Y+4, r17	; 0x04
    31d4:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:575
          }
        }
        (*address) = payload;                   // saving address to expose to the user sketch
    31d6:	18 86       	std	Y+8, r1	; 0x08
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:576
        (*txHead) = 0;                          // reset buffer positions so the Master can start writing at zero.
    31d8:	e9 85       	ldd	r30, Y+9	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:577
        (*txTail) = 0;
    31da:	fa 85       	ldd	r31, Y+10	; 0x0a
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:579

        if (_data->user_onRequest != NULL) {
    31dc:	30 97       	sbiw	r30, 0x00	; 0
    31de:	09 f0       	breq	.+2      	; 0x31e2 <__vector_18+0x6c>
    31e0:	09 95       	icall
    31e2:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:580
          _data->user_onRequest();
    31e4:	88 23       	and	r24, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:582
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
    31e6:	19 f1       	breq	.+70     	; 0x322e <__vector_18+0xb8>
__vector_18():
    31e8:	83 e0       	ldi	r24, 0x03	; 3
pushSleep():
    31ea:	90 91 50 00 	lds	r25, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:671
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
    }
    sleepStack = sleepStackLoc;
  #else
    sleepStack = SLPCTRL.CTRLA;           // save old sleep State
    31ee:	90 93 0a 63 	sts	0x630A, r25	; 0x80630a <__data_end>
    31f2:	91 70       	andi	r25, 0x01	; 1
    31f4:	90 93 50 00 	sts	0x0050, r25	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
TWI_HandleSlaveIRQ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:672
    SLPCTRL.CTRLA = sleepStack & 0x01;    // only leave the SEN bit, if it was set
    31f8:	e8 81       	ld	r30, Y
    31fa:	f9 81       	ldd	r31, Y+1	; 0x01
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:638
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
        }
      }
    }
  }
  _data->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
    31fc:	82 87       	std	Z+10, r24	; 0x0a
__vector_18():
    31fe:	ff 91       	pop	r31
    3200:	ef 91       	pop	r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:979
  TwoWire::onSlaveIRQ(&TWI0);
}
    3202:	df 91       	pop	r29
    3204:	cf 91       	pop	r28
    3206:	bf 91       	pop	r27
    3208:	af 91       	pop	r26
    320a:	9f 91       	pop	r25
    320c:	8f 91       	pop	r24
    320e:	7f 91       	pop	r23
    3210:	6f 91       	pop	r22
    3212:	5f 91       	pop	r21
    3214:	4f 91       	pop	r20
    3216:	3f 91       	pop	r19
    3218:	2f 91       	pop	r18
    321a:	1f 91       	pop	r17
    321c:	0f 90       	pop	r0
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	0f 90       	pop	r0
    3222:	1f 90       	pop	r1
    3224:	18 95       	reti
TWI_HandleSlaveIRQ():
    3226:	1c 83       	std	Y+4, r17	; 0x04
    3228:	1e 82       	std	Y+6, r1	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:589
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
        (*address) = payload;           // saving address to expose to the user sketch
    322a:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:590
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
    322c:	dd cf       	rjmp	.-70     	; 0x31e8 <__vector_18+0x72>
__vector_18():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:591
        (*rxTail) = 0;
    322e:	86 e0       	ldi	r24, 0x06	; 6
    3230:	dc cf       	rjmp	.-72     	; 0x31ea <__vector_18+0x74>
popSleep():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:583

        if (_data->user_onRequest != NULL) {
          _data->user_onRequest();
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
    3232:	80 91 0a 63 	lds	r24, 0x630A	; 0x80630a <__data_end>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:689
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
    3236:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7f0050>
TWI_HandleSlaveIRQ():
    323a:	eb 85       	ldd	r30, Y+11	; 0x0b
    323c:	fc 85       	ldd	r31, Y+12	; 0x0c
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:596
        (*rxTail) = 0;
      }
      pushSleep();
    } else {                            // Stop bit set
      popSleep();
      if (_data->user_onReceive != NULL) {
    323e:	30 97       	sbiw	r30, 0x00	; 0
    3240:	29 f0       	breq	.+10     	; 0x324c <__vector_18+0xd6>
    3242:	8e 81       	ldd	r24, Y+6	; 0x06
    3244:	88 23       	and	r24, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:597
        if ((*rxHead) > 0) {
    3246:	11 f0       	breq	.+4      	; 0x324c <__vector_18+0xd6>
    3248:	90 e0       	ldi	r25, 0x00	; 0
    324a:	09 95       	icall
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:598
          _data->user_onReceive((*rxHead));
    324c:	1e 82       	std	Y+6, r1	; 0x06
    324e:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:602
        }
      }
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
      (*rxHead) = 0;
    3250:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:603
      (*txHead) = 0;
    3252:	18 86       	std	Y+8, r1	; 0x08
__vector_18():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:604
      (*rxTail) = 0;
    3254:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:605
      (*txTail) = 0;
    3256:	d0 cf       	rjmp	.-96     	; 0x31f8 <__vector_18+0x82>
TWI_HandleSlaveIRQ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:622
        if ((*txTail) < (*txHead)) {            // Data is available
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
          (*txTail)++;                            // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute a byte read operation followed by Acknowledge Action"
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
    3258:	87 ff       	sbrs	r24, 7
    325a:	31 c0       	rjmp	.+98     	; 0x32be <__vector_18+0x148>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:607
      (*rxHead) = 0;
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    325c:	81 ff       	sbrs	r24, 1
    325e:	1e c0       	rjmp	.+60     	; 0x329c <__vector_18+0x126>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:608
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
    3260:	88 71       	andi	r24, 0x18	; 24
    3262:	39 f0       	breq	.+14     	; 0x3272 <__vector_18+0xfc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:609
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
    3264:	8a 81       	ldd	r24, Y+2	; 0x02
    3266:	83 ff       	sbrs	r24, 3
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:610
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
    3268:	04 c0       	rjmp	.+8      	; 0x3272 <__vector_18+0xfc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:609
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
    326a:	1d 82       	std	Y+5, r1	; 0x05
    326c:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:611
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
        (*txHead) = 0;                          // Abort further data writes
    326e:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:612
        _data->_bools._ackMatters = false;      // stop checking for NACK
    3270:	f1 cf       	rjmp	.-30     	; 0x3254 <__vector_18+0xde>
    3272:	8b 81       	ldd	r24, Y+3	; 0x03
    3274:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:615
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        _data->_bytesTransmittedS++;            // increment bytes transmitted counter (for register model)
    3276:	8b 83       	std	Y+3, r24	; 0x03
    3278:	8a 81       	ldd	r24, Y+2	; 0x02
    327a:	88 60       	ori	r24, 0x08	; 8
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:616
        _data->_bools._ackMatters = true;       // start checking for NACK
    327c:	8a 83       	std	Y+2, r24	; 0x02
    327e:	a8 85       	ldd	r26, Y+8	; 0x08
    3280:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:617
        if ((*txTail) < (*txHead)) {            // Data is available
    3282:	a8 17       	cp	r26, r24
    3284:	38 f7       	brcc	.-50     	; 0x3254 <__vector_18+0xde>
    3286:	ac 0f       	add	r26, r28
    3288:	bd 2f       	mov	r27, r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:618
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
    328a:	b1 1d       	adc	r27, r1
    328c:	1d 96       	adiw	r26, 0x0d	; 13
    328e:	8c 91       	ld	r24, X
    3290:	85 87       	std	Z+13, r24	; 0x0d
    3292:	88 85       	ldd	r24, Y+8	; 0x08
    3294:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:619
          (*txTail)++;                            // Increment counter for sent bytes
    3296:	88 87       	std	Y+8, r24	; 0x08
__vector_18():
    3298:	83 e0       	ldi	r24, 0x03	; 3
    329a:	ae cf       	rjmp	.-164    	; 0x31f8 <__vector_18+0x82>
TWI_HandleSlaveIRQ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:631
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
        rxBuffer[(*rxHead)] = payload;              // save data
        (*rxHead)++;                                  // Advance Head
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
    329c:	85 85       	ldd	r24, Z+13	; 0x0d
    329e:	ee 81       	ldd	r30, Y+6	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:626
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
    32a0:	e2 38       	cpi	r30, 0x82	; 130
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:627
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
    32a2:	68 f4       	brcc	.+26     	; 0x32be <__vector_18+0x148>
    32a4:	ec 0f       	add	r30, r28
    32a6:	fd 2f       	mov	r31, r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:628
        rxBuffer[(*rxHead)] = payload;              // save data
    32a8:	f1 1d       	adc	r31, r1
    32aa:	e1 57       	subi	r30, 0x71	; 113
    32ac:	ff 4f       	sbci	r31, 0xFF	; 255
    32ae:	80 83       	st	Z, r24
    32b0:	8e 81       	ldd	r24, Y+6	; 0x06
    32b2:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:629
        (*rxHead)++;                                  // Advance Head
    32b4:	8e 83       	std	Y+6, r24	; 0x06
    32b6:	82 38       	cpi	r24, 0x82	; 130
    32b8:	78 f3       	brcs	.-34     	; 0x3298 <__vector_18+0x122>
__vector_18():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:630
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
    32ba:	86 e0       	ldi	r24, 0x06	; 6
    32bc:	9d cf       	rjmp	.-198    	; 0x31f8 <__vector_18+0x82>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:633
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                      // else buffer would overflow with next byte
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
    32be:	80 e0       	ldi	r24, 0x00	; 0
    32c0:	9b cf       	rjmp	.-202    	; 0x31f8 <__vector_18+0x82>

000032c2 <SPISettings::SPISettings()>:
__base_ctor ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:562

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
    32c2:	fc 01       	movw	r30, r24
    32c4:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:230
      /*  This is no longer the case since, F_CPU_CORRECTED is variable */
      /*  set at run time.                                             */

      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
    32c6:	5b e1       	ldi	r21, 0x1B	; 27
    32c8:	67 eb       	ldi	r22, 0xB7	; 183
    32ca:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:231
      clockDiv = 0;
    32cc:	90 e0       	ldi	r25, 0x00	; 0
_ZN11SPISettings17init_AlwaysInlineEmhh():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:234
      while ((clockDiv < 6) && (clock < clockSetting)) {
        clockSetting >>= 1;
        clockDiv++;
    32ce:	9f 5f       	subi	r25, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:232

      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
      clockDiv = 0;
      while ((clockDiv < 6) && (clock < clockSetting)) {
    32d0:	96 30       	cpi	r25, 0x06	; 6
    32d2:	11 f4       	brne	.+4      	; 0x32d8 <SPISettings::SPISettings()+0x16>
__base_ctor ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:240
      }

      // Compensate for the duplicate fosc/64,
      // should be fosc/128 if clockdiv 6.
      if (clockDiv == 6) {
        clockDiv++;
    32d4:	97 e0       	ldi	r25, 0x07	; 7
    32d6:	0b c0       	rjmp	.+22     	; 0x32ee <SPISettings::SPISettings()+0x2c>
_ZN11SPISettings17init_AlwaysInlineEmhh():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:233
      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
      clockDiv = 0;
      while ((clockDiv < 6) && (clock < clockSetting)) {
        clockSetting >>= 1;
    32d8:	76 95       	lsr	r23
    32da:	67 95       	ror	r22
    32dc:	57 95       	ror	r21
    32de:	47 95       	ror	r20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:232

      uint32_t clockSetting = 0;

      clockSetting = F_CPU >> 1;
      clockDiv = 0;
      while ((clockDiv < 6) && (clock < clockSetting)) {
    32e0:	41 30       	cpi	r20, 0x01	; 1
    32e2:	89 e0       	ldi	r24, 0x09	; 9
    32e4:	58 07       	cpc	r21, r24
    32e6:	8d e3       	ldi	r24, 0x3D	; 61
    32e8:	68 07       	cpc	r22, r24
    32ea:	71 05       	cpc	r23, r1
    32ec:	80 f7       	brcc	.-32     	; 0x32ce <SPISettings::SPISettings()+0xc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:244
      if (clockDiv == 6) {
        clockDiv++;
      }

      // Invert the SPI2X bit
      clockDiv ^= 0x1;
    32ee:	81 e0       	ldi	r24, 0x01	; 1
    32f0:	98 27       	eor	r25, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:252
      /* Set mode, disable master slave select, and disable buffering.   */
      /* dataMode is register correct, when using SPI_MODE defines only! */
      /* they have had SSD added to the modebits. That permits the SPI   */
      /* library to coeexist with code that uses the SPI as a slave,     */
      /* if and only if the SPI_MODEn named constants are used           */
      ctrlb = (dataMode) | (SPI_SSD_bm);
    32f2:	84 e0       	ldi	r24, 0x04	; 4
    32f4:	81 83       	std	Z+1, r24	; 0x01
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:263
      //uint8_t clockDiv_pres = (clockDiv >> 1);

      /* Pack into the SPISettings::ctrlb class     */
      /* Set Prescaler, x2, SPI to Master, and Bit Order. */

      ctrla = (clockDiv & 1 ? SPI_CLK2X_bm : 0)       |
    32f6:	80 e1       	ldi	r24, 0x10	; 16
    32f8:	98 9f       	mul	r25, r24
    32fa:	90 01       	movw	r18, r0
    32fc:	11 24       	eor	r1, r1
    32fe:	20 71       	andi	r18, 0x10	; 16
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:264
              (clockDiv & 6)                          |
    3300:	96 70       	andi	r25, 0x06	; 6
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:265
              (SPI_ENABLE_bm)                         |
    3302:	91 62       	ori	r25, 0x21	; 33
    3304:	92 2b       	or	r25, r18
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:263
      //uint8_t clockDiv_pres = (clockDiv >> 1);

      /* Pack into the SPISettings::ctrlb class     */
      /* Set Prescaler, x2, SPI to Master, and Bit Order. */

      ctrla = (clockDiv & 1 ? SPI_CLK2X_bm : 0)       |
    3306:	90 83       	st	Z, r25
__base_ctor ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\SPI\src/SPI.h:193
    }

    // Default speed set to 4MHz, SPI mode set to MODE 0 and Bit order set to MSB first.
    SPISettings() {
      init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
    }
    3308:	08 95       	ret

0000330a <global constructors keyed to 65535_0_avr_dd_testsuite.ino.cpp.o.5500>:
_GLOBAL__I_65535_0_avr_dd_testsuite.ino.cpp.o.5500():
    330a:	cf 93       	push	r28
    330c:	10 92 99 63 	sts	0x6399, r1	; 0x806399 <Serial0+0x2>
    3310:	10 92 9a 63 	sts	0x639A, r1	; 0x80639a <Serial0+0x3>
    3314:	88 ee       	ldi	r24, 0xE8	; 232
    3316:	93 e0       	ldi	r25, 0x03	; 3
    3318:	a0 e0       	ldi	r26, 0x00	; 0
    331a:	b0 e0       	ldi	r27, 0x00	; 0
    331c:	80 93 9b 63 	sts	0x639B, r24	; 0x80639b <Serial0+0x4>
    3320:	90 93 9c 63 	sts	0x639C, r25	; 0x80639c <Serial0+0x5>
    3324:	a0 93 9d 63 	sts	0x639D, r26	; 0x80639d <Serial0+0x6>
    3328:	b0 93 9e 63 	sts	0x639E, r27	; 0x80639e <Serial0+0x7>
    332c:	26 ed       	ldi	r18, 0xD6	; 214
    332e:	31 e6       	ldi	r19, 0x61	; 97
    3330:	20 93 97 63 	sts	0x6397, r18	; 0x806397 <Serial0>
    3334:	30 93 98 63 	sts	0x6398, r19	; 0x806398 <Serial0+0x1>
    3338:	20 e0       	ldi	r18, 0x00	; 0
    333a:	38 e0       	ldi	r19, 0x08	; 8
    333c:	20 93 9f 63 	sts	0x639F, r18	; 0x80639f <Serial0+0x8>
    3340:	30 93 a0 63 	sts	0x63A0, r19	; 0x8063a0 <Serial0+0x9>
    3344:	29 ef       	ldi	r18, 0xF9	; 249
    3346:	3b e0       	ldi	r19, 0x0B	; 11
    3348:	20 93 a1 63 	sts	0x63A1, r18	; 0x8063a1 <Serial0+0xa>
    334c:	30 93 a2 63 	sts	0x63A2, r19	; 0x8063a2 <Serial0+0xb>
    3350:	25 e0       	ldi	r18, 0x05	; 5
    3352:	20 93 a3 63 	sts	0x63A3, r18	; 0x8063a3 <Serial0+0xc>
    3356:	10 92 a4 63 	sts	0x63A4, r1	; 0x8063a4 <Serial0+0xd>
    335a:	10 92 a5 63 	sts	0x63A5, r1	; 0x8063a5 <Serial0+0xe>
    335e:	10 92 52 64 	sts	0x6452, r1	; 0x806452 <Wire+0x2>
    3362:	10 92 53 64 	sts	0x6453, r1	; 0x806453 <Wire+0x3>
    3366:	80 93 54 64 	sts	0x6454, r24	; 0x806454 <Wire+0x4>
    336a:	90 93 55 64 	sts	0x6455, r25	; 0x806455 <Wire+0x5>
    336e:	a0 93 56 64 	sts	0x6456, r26	; 0x806456 <Wire+0x6>
    3372:	b0 93 57 64 	sts	0x6457, r27	; 0x806457 <Wire+0x7>
    3376:	88 ee       	ldi	r24, 0xE8	; 232
    3378:	91 e6       	ldi	r25, 0x61	; 97
    337a:	80 93 50 64 	sts	0x6450, r24	; 0x806450 <Wire>
    337e:	90 93 51 64 	sts	0x6451, r25	; 0x806451 <Wire+0x1>
    3382:	80 e0       	ldi	r24, 0x00	; 0
    3384:	99 e0       	ldi	r25, 0x09	; 9
    3386:	80 93 58 64 	sts	0x6458, r24	; 0x806458 <Wire+0x8>
    338a:	90 93 59 64 	sts	0x6459, r25	; 0x806459 <Wire+0x9>
    338e:	85 e3       	ldi	r24, 0x35	; 53
    3390:	94 e6       	ldi	r25, 0x64	; 100
    3392:	97 df       	rcall	.-210    	; 0x32c2 <SPISettings::SPISettings()>
    3394:	80 e4       	ldi	r24, 0x40	; 64
    3396:	99 e0       	ldi	r25, 0x09	; 9
    3398:	80 93 2a 64 	sts	0x642A, r24	; 0x80642a <SPI>
    339c:	90 93 2b 64 	sts	0x642B, r25	; 0x80642b <SPI+0x1>
    33a0:	84 e0       	ldi	r24, 0x04	; 4
    33a2:	80 93 2d 64 	sts	0x642D, r24	; 0x80642d <SPI+0x3>
    33a6:	86 e0       	ldi	r24, 0x06	; 6
    33a8:	80 93 2e 64 	sts	0x642E, r24	; 0x80642e <SPI+0x4>
    33ac:	10 92 30 64 	sts	0x6430, r1	; 0x806430 <SPI+0x6>
    33b0:	10 92 31 64 	sts	0x6431, r1	; 0x806431 <SPI+0x7>
    33b4:	10 92 6b 65 	sts	0x656B, r1	; 0x80656b <display+0x2>
    33b8:	10 92 6c 65 	sts	0x656C, r1	; 0x80656c <display+0x3>
    33bc:	20 e8       	ldi	r18, 0x80	; 128
    33be:	30 e0       	ldi	r19, 0x00	; 0
    33c0:	20 93 6d 65 	sts	0x656D, r18	; 0x80656d <display+0x4>
    33c4:	30 93 6e 65 	sts	0x656E, r19	; 0x80656e <display+0x5>
    33c8:	80 e4       	ldi	r24, 0x40	; 64
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	80 93 6f 65 	sts	0x656F, r24	; 0x80656f <display+0x6>
    33d0:	90 93 70 65 	sts	0x6570, r25	; 0x806570 <display+0x7>
    33d4:	20 93 71 65 	sts	0x6571, r18	; 0x806571 <display+0x8>
    33d8:	30 93 72 65 	sts	0x6572, r19	; 0x806572 <display+0x9>
    33dc:	80 93 73 65 	sts	0x6573, r24	; 0x806573 <display+0xa>
    33e0:	90 93 74 65 	sts	0x6574, r25	; 0x806574 <display+0xb>
    33e4:	10 92 7f 65 	sts	0x657F, r1	; 0x80657f <display+0x16>
    33e8:	10 92 75 65 	sts	0x6575, r1	; 0x806575 <display+0xc>
    33ec:	10 92 76 65 	sts	0x6576, r1	; 0x806576 <display+0xd>
    33f0:	10 92 77 65 	sts	0x6577, r1	; 0x806577 <display+0xe>
    33f4:	10 92 78 65 	sts	0x6578, r1	; 0x806578 <display+0xf>
    33f8:	c1 e0       	ldi	r28, 0x01	; 1
    33fa:	c0 93 7e 65 	sts	0x657E, r28	; 0x80657e <display+0x15>
    33fe:	c0 93 7d 65 	sts	0x657D, r28	; 0x80657d <display+0x14>
    3402:	8f ef       	ldi	r24, 0xFF	; 255
    3404:	9f ef       	ldi	r25, 0xFF	; 255
    3406:	80 93 7b 65 	sts	0x657B, r24	; 0x80657b <display+0x12>
    340a:	90 93 7c 65 	sts	0x657C, r25	; 0x80657c <display+0x13>
    340e:	80 93 79 65 	sts	0x6579, r24	; 0x806579 <display+0x10>
    3412:	90 93 7a 65 	sts	0x657A, r25	; 0x80657a <display+0x11>
    3416:	c0 93 80 65 	sts	0x6580, r28	; 0x806580 <display+0x17>
    341a:	10 92 81 65 	sts	0x6581, r1	; 0x806581 <display+0x18>
    341e:	10 92 82 65 	sts	0x6582, r1	; 0x806582 <display+0x19>
    3422:	10 92 83 65 	sts	0x6583, r1	; 0x806583 <display+0x1a>
    3426:	8e e4       	ldi	r24, 0x4E	; 78
    3428:	92 e6       	ldi	r25, 0x62	; 98
    342a:	80 93 69 65 	sts	0x6569, r24	; 0x806569 <display>
    342e:	90 93 6a 65 	sts	0x656A, r25	; 0x80656a <display+0x1>
    3432:	10 92 84 65 	sts	0x6584, r1	; 0x806584 <display+0x1b>
    3436:	10 92 85 65 	sts	0x6585, r1	; 0x806585 <display+0x1c>
    343a:	80 e5       	ldi	r24, 0x50	; 80
    343c:	94 e6       	ldi	r25, 0x64	; 100
    343e:	80 93 86 65 	sts	0x6586, r24	; 0x806586 <display+0x1d>
    3442:	90 93 87 65 	sts	0x6587, r25	; 0x806587 <display+0x1e>
    3446:	10 92 88 65 	sts	0x6588, r1	; 0x806588 <display+0x1f>
    344a:	10 92 89 65 	sts	0x6589, r1	; 0x806589 <display+0x20>
    344e:	8f ef       	ldi	r24, 0xFF	; 255
    3450:	80 93 8d 65 	sts	0x658D, r24	; 0x80658d <display+0x24>
    3454:	80 93 8e 65 	sts	0x658E, r24	; 0x80658e <display+0x25>
    3458:	80 93 8f 65 	sts	0x658F, r24	; 0x80658f <display+0x26>
    345c:	80 93 90 65 	sts	0x6590, r24	; 0x806590 <display+0x27>
    3460:	80 93 91 65 	sts	0x6591, r24	; 0x806591 <display+0x28>
    3464:	80 e8       	ldi	r24, 0x80	; 128
    3466:	9a e1       	ldi	r25, 0x1A	; 26
    3468:	a6 e0       	ldi	r26, 0x06	; 6
    346a:	b0 e0       	ldi	r27, 0x00	; 0
    346c:	80 93 9e 65 	sts	0x659E, r24	; 0x80659e <display+0x35>
    3470:	90 93 9f 65 	sts	0x659F, r25	; 0x80659f <display+0x36>
    3474:	a0 93 a0 65 	sts	0x65A0, r26	; 0x8065a0 <display+0x37>
    3478:	b0 93 a1 65 	sts	0x65A1, r27	; 0x8065a1 <display+0x38>
    347c:	80 ea       	ldi	r24, 0xA0	; 160
    347e:	96 e8       	ldi	r25, 0x86	; 134
    3480:	a1 e0       	ldi	r26, 0x01	; 1
    3482:	b0 e0       	ldi	r27, 0x00	; 0
    3484:	80 93 a2 65 	sts	0x65A2, r24	; 0x8065a2 <display+0x39>
    3488:	90 93 a3 65 	sts	0x65A3, r25	; 0x8065a3 <display+0x3a>
    348c:	a0 93 a4 65 	sts	0x65A4, r26	; 0x8065a4 <display+0x3b>
    3490:	b0 93 a5 65 	sts	0x65A5, r27	; 0x8065a5 <display+0x3c>
    3494:	87 ea       	ldi	r24, 0xA7	; 167
    3496:	95 e6       	ldi	r25, 0x65	; 101
    3498:	14 df       	rcall	.-472    	; 0x32c2 <SPISettings::SPISettings()>
    349a:	10 92 3a 64 	sts	0x643A, r1	; 0x80643a <pixel_ring>
    349e:	82 e3       	ldi	r24, 0x32	; 50
    34a0:	90 e0       	ldi	r25, 0x00	; 0
    34a2:	80 93 3f 64 	sts	0x643F, r24	; 0x80643f <pixel_ring+0x5>
    34a6:	90 93 40 64 	sts	0x6440, r25	; 0x806440 <pixel_ring+0x6>
    34aa:	10 92 42 64 	sts	0x6442, r1	; 0x806442 <pixel_ring+0x8>
    34ae:	10 92 49 64 	sts	0x6449, r1	; 0x806449 <pixel_ring+0xf>
    34b2:	10 92 4a 64 	sts	0x644A, r1	; 0x80644a <pixel_ring+0x10>
    34b6:	10 92 4b 64 	sts	0x644B, r1	; 0x80644b <pixel_ring+0x11>
    34ba:	10 92 4c 64 	sts	0x644C, r1	; 0x80644c <pixel_ring+0x12>
    34be:	c0 93 48 64 	sts	0x6448, r28	; 0x806448 <pixel_ring+0xe>
    34c2:	c0 93 45 64 	sts	0x6445, r28	; 0x806445 <pixel_ring+0xb>
    34c6:	10 92 46 64 	sts	0x6446, r1	; 0x806446 <pixel_ring+0xc>
    34ca:	82 e0       	ldi	r24, 0x02	; 2
    34cc:	80 93 47 64 	sts	0x6447, r24	; 0x806447 <pixel_ring+0xd>
    34d0:	88 e1       	ldi	r24, 0x18	; 24
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	80 93 3d 64 	sts	0x643D, r24	; 0x80643d <pixel_ring+0x3>
    34d8:	90 93 3e 64 	sts	0x643E, r25	; 0x80643e <pixel_ring+0x4>
    34dc:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <malloc>
    34e0:	80 93 43 64 	sts	0x6443, r24	; 0x806443 <pixel_ring+0x9>
    34e4:	90 93 44 64 	sts	0x6444, r25	; 0x806444 <pixel_ring+0xa>
    34e8:	00 97       	sbiw	r24, 0x00	; 0
    34ea:	39 f1       	breq	.+78     	; 0x353a <global constructors keyed to 65535_0_avr_dd_testsuite.ino.cpp.o.5500+0x230>
    34ec:	28 e1       	ldi	r18, 0x18	; 24
    34ee:	fc 01       	movw	r30, r24
    34f0:	11 92       	st	Z+, r1
    34f2:	2a 95       	dec	r18
    34f4:	e9 f7       	brne	.-6      	; 0x34f0 <global constructors keyed to 65535_0_avr_dd_testsuite.ino.cpp.o.5500+0x1e6>
    34f6:	88 e0       	ldi	r24, 0x08	; 8
    34f8:	90 e0       	ldi	r25, 0x00	; 0
    34fa:	80 93 3b 64 	sts	0x643B, r24	; 0x80643b <pixel_ring+0x1>
    34fe:	90 93 3c 64 	sts	0x643C, r25	; 0x80643c <pixel_ring+0x2>
    3502:	8b e0       	ldi	r24, 0x0B	; 11
    3504:	80 93 41 64 	sts	0x6441, r24	; 0x806441 <pixel_ring+0x7>
    3508:	80 91 3a 64 	lds	r24, 0x643A	; 0x80643a <pixel_ring>
    350c:	88 23       	and	r24, r24
    350e:	31 f0       	breq	.+12     	; 0x351c <global constructors keyed to 65535_0_avr_dd_testsuite.ino.cpp.o.5500+0x212>
    3510:	88 e0       	ldi	r24, 0x08	; 8
    3512:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <__TEXT_REGION_LENGTH__+0x7f0441>
    3516:	60 e0       	ldi	r22, 0x00	; 0
    3518:	8b e0       	ldi	r24, 0x0B	; 11
    351a:	cc d8       	rcall	.-3688   	; 0x26b4 <digitalWrite>
    351c:	84 e4       	ldi	r24, 0x44	; 68
    351e:	94 e0       	ldi	r25, 0x04	; 4
    3520:	80 93 4d 64 	sts	0x644D, r24	; 0x80644d <pixel_ring+0x13>
    3524:	90 93 4e 64 	sts	0x644E, r25	; 0x80644e <pixel_ring+0x14>
    3528:	88 e0       	ldi	r24, 0x08	; 8
    352a:	80 93 4f 64 	sts	0x644F, r24	; 0x80644f <pixel_ring+0x15>
    352e:	10 92 37 64 	sts	0x6437, r1	; 0x806437 <mcp_leds>
    3532:	10 92 38 64 	sts	0x6438, r1	; 0x806438 <mcp_leds+0x1>
    3536:	cf 91       	pop	r28
    3538:	08 95       	ret
    353a:	10 92 3d 64 	sts	0x643D, r1	; 0x80643d <pixel_ring+0x3>
    353e:	10 92 3e 64 	sts	0x643E, r1	; 0x80643e <pixel_ring+0x4>
    3542:	10 92 3b 64 	sts	0x643B, r1	; 0x80643b <pixel_ring+0x1>
    3546:	10 92 3c 64 	sts	0x643C, r1	; 0x80643c <pixel_ring+0x2>
    354a:	db cf       	rjmp	.-74     	; 0x3502 <global constructors keyed to 65535_0_avr_dd_testsuite.ino.cpp.o.5500+0x1f8>

0000354c <main>:
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:84
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    354c:	cf 93       	push	r28
    354e:	df 93       	push	r29
    3550:	cd b7       	in	r28, 0x3d	; 61
    3552:	de b7       	in	r29, 0x3e	; 62
    3554:	2c 97       	sbiw	r28, 0x0c	; 12
    3556:	cd bf       	out	0x3d, r28	; 61
    3558:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1885
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
      #elif (F_CPU == 28000000)
        /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
      #elif (F_CPU == 24000000)
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    355a:	88 ed       	ldi	r24, 0xD8	; 216
    355c:	94 e2       	ldi	r25, 0x24	; 36
    355e:	84 bf       	out	0x34, r24	; 52
    3560:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7f0068>
init_TCA0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2241
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    3564:	21 e0       	ldi	r18, 0x01	; 1
    3566:	20 93 03 0a 	sts	0x0A03, r18	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7f0a03>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2246

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    356a:	9e ef       	ldi	r25, 0xFE	; 254
    356c:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7f0a26>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2247
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    3570:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7f0a27>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2274
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    3574:	8b e0       	ldi	r24, 0x0B	; 11
    3576:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7f0a00>
init_timers():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2222
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
    357a:	85 e0       	ldi	r24, 0x05	; 5
    357c:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
init_TCBs():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2352
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    3580:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7f05e8>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2424
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    3584:	37 e0       	ldi	r19, 0x07	; 7
    3586:	30 93 01 0b 	sts	0x0B01, r19	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7f0b01>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2427

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    358a:	90 93 0c 0b 	sts	0x0B0C, r25	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7f0b0c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2430
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    358e:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7f0b0d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2433

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    3592:	80 93 00 0b 	sts	0x0B00, r24	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7f0b00>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2424
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    3596:	30 93 11 0b 	sts	0x0B11, r19	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7f0b11>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2427

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    359a:	90 93 1c 0b 	sts	0x0B1C, r25	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7f0b1c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2430
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    359e:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7f0b1d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2433

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    35a2:	80 93 10 0b 	sts	0x0B10, r24	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7f0b10>
init_TCD0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2477
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    35a6:	4f ef       	ldi	r20, 0xFF	; 255
    35a8:	5f e0       	ldi	r21, 0x0F	; 15
    35aa:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7f0baa>
    35ae:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7f0bab>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2481
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    35b2:	90 e8       	ldi	r25, 0x80	; 128
    35b4:	90 93 82 0b 	sts	0x0B82, r25	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7f0b82>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2483
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    35b8:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7f0b81>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2486
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    35bc:	4b ef       	ldi	r20, 0xFB	; 251
    35be:	53 e0       	ldi	r21, 0x03	; 3
    35c0:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7f0bae>
    35c4:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7f0baf>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2495
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    35c8:	91 e7       	ldi	r25, 0x71	; 113
    35ca:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
init_timers():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:2228
  #endif
  init_TCBs();
  #if (defined(TCD0) && defined(USE_TIMERD0_PWM) && !defined(MILLIS_USE_TIMERD0))
    init_TCD0();
    #if defined(ERRATA_TCD_PORTMUX) && ERRATA_TCD_PORTMUX == 0 && defined(TCD0_PINS)
      PORTMUX.TCDROUTEA = TCD0_PINS;
    35ce:	10 92 e9 05 	sts	0x05E9, r1	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
init_ADC0_type1():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:178
   ADC_t* pADC;

   pADC = &ADC0;
    
   adc_config.init_delay = 2;
   adc_config.left_adjust = false;
    35d2:	10 92 15 63 	sts	0x6315, r1	; 0x806315 <adc_config+0x1>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:179
   adc_config.dif_mode = false;                                // single ended mode
    35d6:	10 92 17 63 	sts	0x6317, r1	; 0x806317 <adc_config+0x3>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:180
   adc_config.resolution = 10;
    35da:	9a e0       	ldi	r25, 0x0A	; 10
    35dc:	90 93 1d 63 	sts	0x631D, r25	; 0x80631d <adc_config+0x9>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:181
   adc_config.mux_pos = 0x40;                                    // init MUXPOS to GND
    35e0:	90 e4       	ldi	r25, 0x40	; 64
    35e2:	90 93 18 63 	sts	0x6318, r25	; 0x806318 <adc_config+0x4>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:182
   adc_config.mux_neg = 0x40;
    35e6:	90 93 19 63 	sts	0x6319, r25	; 0x806319 <adc_config+0x5>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:183
   adc_config.samp_delay = 0x02;                               // arbitrary samp delay of 2 clock cycles
    35ea:	92 e0       	ldi	r25, 0x02	; 2
    35ec:	90 93 1b 63 	sts	0x631B, r25	; 0x80631b <adc_config+0x7>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:184
   adc_config.init_delay = ADC_INITDLY_DLY64_gc;               // arbitrary init delay of 64 clocks
    35f0:	30 e6       	ldi	r19, 0x60	; 96
    35f2:	30 93 1a 63 	sts	0x631A, r19	; 0x80631a <adc_config+0x6>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:185
   adc_config.reference = VDD;                  
    35f6:	80 93 1c 63 	sts	0x631C, r24	; 0x80631c <adc_config+0x8>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:186
   adc_config.sample_number = 1;                               // single sample mode
    35fa:	20 93 16 63 	sts	0x6316, r18	; 0x806316 <adc_config+0x2>
analogReference():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:79

#ifdef ADC_TYPE1 // reference set external to ADC peripheral
void analogReference(uint8_t mode) 
 {
      if (mode < 7 && mode != 4)
        VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    35fe:	90 91 b0 00 	lds	r25, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
    3602:	98 7f       	andi	r25, 0xF8	; 248
    3604:	95 60       	ori	r25, 0x05	; 5
    3606:	90 93 b0 00 	sts	0x00B0, r25	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7f00b0>
init_ADC0_type1():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:193
   analogReference(VDD);                                       // analog ref set to VDD by default
   
  // scale the ADC speed to be around 1 MHz regardless of CPU frequency
  
   #if F_CPU >= 24000000
       pADC->CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    360a:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f0602>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:207
   #else                              
      pADC->CTRLC = ADC_PRESC_DIV2_gc;   // 1 MHz / 2 = 500 kHz
   #endif
       
   // 16 ADC clock sampling time 
   pADC->SAMPCTRL = 14; 
    360e:	9e e0       	ldi	r25, 0x0E	; 14
    3610:	90 93 05 06 	sts	0x0605, r25	; 0x800605 <__TEXT_REGION_LENGTH__+0x7f0605>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:210
      
   // VREF init delay
   pADC->CTRLD = ADC_INITDLY_DLY64_gc; 
    3614:	30 93 03 06 	sts	0x0603, r19	; 0x800603 <__TEXT_REGION_LENGTH__+0x7f0603>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:213
     
   /* Enable ADC in 10 bit mode */
   pADC->CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    3618:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7f0600>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:216

   // set correct function pointers
   adc_read = analogRead_type1;
    361c:	82 e5       	ldi	r24, 0x52	; 82
    361e:	97 e0       	ldi	r25, 0x07	; 7
    3620:	80 93 0b 63 	sts	0x630B, r24	; 0x80630b <adc_read>
    3624:	90 93 0c 63 	sts	0x630C, r25	; 0x80630c <adc_read+0x1>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:217
   adc_resolution = analogReadResolution1;
    3628:	86 ea       	ldi	r24, 0xA6	; 166
    362a:	97 e0       	ldi	r25, 0x07	; 7
    362c:	80 93 12 63 	sts	0x6312, r24	; 0x806312 <adc_resolution>
    3630:	90 93 13 63 	sts	0x6313, r25	; 0x806313 <adc_resolution+0x1>
init_millis():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1722
        #endif
        RTC.INTCTRL         = 0x01; // enable overflow interrupt
        RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
      */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    3634:	8f ed       	ldi	r24, 0xDF	; 223
    3636:	9e e2       	ldi	r25, 0x2E	; 46
    3638:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7f0b2c>
    363c:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7f0b2d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1724
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    3640:	20 93 25 0b 	sts	0x0B25, r18	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7f0b25>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1726
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    3644:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7f0b21>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring.c:1728
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    3648:	13 e0       	ldi	r17, 0x03	; 3
    364a:	10 93 20 0b 	sts	0x0B20, r17	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7f0b20>
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/main.cpp:88
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    364e:	78 94       	sei
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3650:	80 e2       	ldi	r24, 0x20	; 32
    3652:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
setup():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:72
void setup() 
{
  

  pinMode(PIN_PF5, OUTPUT);       // C Nano board LED
  digitalWrite(PIN_PF5,HIGH);     // LED is active low
    3656:	61 e0       	ldi	r22, 0x01	; 1
    3658:	89 e1       	ldi	r24, 0x19	; 25
    365a:	2c d8       	rcall	.-4008   	; 0x26b4 <digitalWrite>
swap():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:526
      return base; // RX = TX + 1. XDIR = XCK + 1 for all Dx and Ex parts!
    }


    bool HardwareSerial::swap(uint8_t newmux) {
      if (newmux < _mux_count) {
    365c:	80 91 a3 63 	lds	r24, 0x63A3	; 0x8063a3 <Serial0+0xc>
    3660:	84 30       	cpi	r24, 0x04	; 4
    3662:	08 f4       	brcc	.+2      	; 0x3666 <main+0x11a>
    3664:	6b c1       	rjmp	.+726    	; 0x393c <main+0x3f0>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:527
        _pin_set = newmux;
    3666:	10 93 a4 63 	sts	0x63A4, r17	; 0x8063a4 <Serial0+0xd>
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:541
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      if (_state & 1) {
    366a:	80 91 a5 63 	lds	r24, 0x63A5	; 0x8063a5 <Serial0+0xe>
    366e:	80 ff       	sbrs	r24, 0
    3670:	14 c0       	rjmp	.+40     	; 0x369a <main+0x14e>
end():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:685
        return NOT_A_MUX; // At this point, we have checked all group codes for this peripheral. It ain't there. Return NOT_A_MUX.
      }
    }
    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
    3672:	87 e9       	ldi	r24, 0x97	; 151
    3674:	93 e6       	ldi	r25, 0x63	; 99
    3676:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <HardwareSerial::flush()>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:688
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
    367a:	e0 91 9f 63 	lds	r30, 0x639F	; 0x80639f <Serial0+0x8>
    367e:	f0 91 a0 63 	lds	r31, 0x63A0	; 0x8063a0 <Serial0+0x9>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:689
      temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
    3682:	86 81       	ldd	r24, Z+6	; 0x06
    3684:	16 82       	std	Z+6, r1	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:690
      temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
    3686:	85 81       	ldd	r24, Z+5	; 0x05
    3688:	15 82       	std	Z+5, r1	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:691
      temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error. TXCIE only used in half duplex
    368a:	80 e4       	ldi	r24, 0x40	; 64
    368c:	84 83       	std	Z+4, r24	; 0x04
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:693
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
    368e:	80 91 a7 63 	lds	r24, 0x63A7	; 0x8063a7 <Serial0+0x10>
    3692:	80 93 a6 63 	sts	0x63A6, r24	; 0x8063a6 <Serial0+0xf>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:697

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    3696:	10 92 a5 63 	sts	0x63A5, r1	; 0x8063a5 <Serial0+0xe>
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:580
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
    369a:	6f b7       	in	r22, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:581
      cli();
    369c:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:582
      volatile USART_t* MyUSART = _hwserial_module;
    369e:	e0 91 9f 63 	lds	r30, 0x639F	; 0x80639f <Serial0+0x8>
    36a2:	f0 91 a0 63 	lds	r31, 0x63A0	; 0x8063a0 <Serial0+0x9>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:583
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
    36a6:	16 82       	std	Z+6, r1	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:584
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
    36a8:	33 e0       	ldi	r19, 0x03	; 3
    36aa:	37 83       	std	Z+7, r19	; 0x07
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:585
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
    36ac:	81 e4       	ldi	r24, 0x41	; 65
    36ae:	93 e0       	ldi	r25, 0x03	; 3
    36b0:	80 87       	std	Z+8, r24	; 0x08
    36b2:	91 87       	std	Z+9, r25	; 0x09
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:591
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
    36b4:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:593
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
    36b6:	80 e8       	ldi	r24, 0x80	; 128
    36b8:	85 83       	std	Z+5, r24	; 0x05
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:594
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
    36ba:	80 ec       	ldi	r24, 0xC0	; 192
    36bc:	86 83       	std	Z+6, r24	; 0x06
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:595
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
    36be:	20 91 a4 63 	lds	r18, 0x63A4	; 0x8063a4 <Serial0+0xd>
    36c2:	70 91 a3 63 	lds	r23, 0x63A3	; 0x8063a3 <Serial0+0xc>
    36c6:	80 91 a1 63 	lds	r24, 0x63A1	; 0x8063a1 <Serial0+0xa>
    36ca:	90 91 a2 63 	lds	r25, 0x63A2	; 0x8063a2 <Serial0+0xb>
_set_pins():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:642
    //  1  1  1  0      TX set output, RX not changed. Loopback mode: you can only see what you send since TX is OUTPUT and that's what's connected to RX.
    //  1  1  1  1      TX set input pullup. Half-duplex mode.
    // * indicates that RS485 mode if requested will be enabled, even though it is inappropriate. These configurations are documented unsupported.
    // Static
    void HardwareSerial::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) {
      uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
    36ce:	fc 01       	movw	r30, r24
    36d0:	23 9f       	mul	r18, r19
    36d2:	e0 0d       	add	r30, r0
    36d4:	f1 1d       	adc	r31, r1
    36d6:	11 24       	eor	r1, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:643
      uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
    36d8:	45 91       	lpm	r20, Z+
    36da:	54 91       	lpm	r21, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:645
      uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx);       // this is the mux
      if (mux_setting < mux_count) {              // if false, pinmux none was selected, and we skip the pin configuration.
    36dc:	27 17       	cp	r18, r23
    36de:	08 f0       	brcs	.+2      	; 0x36e2 <main+0x196>
    36e0:	3f c0       	rjmp	.+126    	; 0x3760 <main+0x214>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    36e2:	25 2f       	mov	r18, r21
    36e4:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    36e6:	5c 31       	cpi	r21, 0x1C	; 28
    36e8:	80 f4       	brcc	.+32     	; 0x370a <main+0x1be>
    36ea:	f9 01       	movw	r30, r18
    36ec:	ee 5e       	subi	r30, 0xEE	; 238
    36ee:	fd 49       	sbci	r31, 0x9D	; 157
    36f0:	a0 81       	ld	r26, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    36f2:	af 3f       	cpi	r26, 0xFF	; 255
    36f4:	51 f0       	breq	.+20     	; 0x370a <main+0x1be>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    36f6:	22 5d       	subi	r18, 0xD2	; 210
    36f8:	3d 49       	sbci	r19, 0x9D	; 157
    36fa:	f9 01       	movw	r30, r18
    36fc:	30 81       	ld	r19, Z
    36fe:	20 e2       	ldi	r18, 0x20	; 32
    3700:	32 9f       	mul	r19, r18
    3702:	f0 01       	movw	r30, r0
    3704:	11 24       	eor	r1, r1
    3706:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3708:	a1 83       	std	Z+1, r26	; 0x01
_set_pins():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:654
          pinMode(mux_pin_tx, OUTPUT);            // If and only if TX is enabled and open drain isn't should the TX pin be output.
        } else if (enmask & 0x50) {               // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
          pinMode(mux_pin_tx, INPUT_PULLUP);      // TX should be INPUT_PULLUP.
        }
        if (enmask & 0x80 && !(enmask & 0x10)) {  // Likewise if RX is enabled, unless loopback mode is too
          pinMode(mux_pin_tx + 1, INPUT_PULLUP);  // (in which case we caught it above), it should be pulled up
    370a:	e1 e0       	ldi	r30, 0x01	; 1
    370c:	e5 0f       	add	r30, r21
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    370e:	2e 2f       	mov	r18, r30
    3710:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3712:	ec 31       	cpi	r30, 0x1C	; 28
    3714:	28 f5       	brcc	.+74     	; 0x3760 <main+0x214>
    3716:	f9 01       	movw	r30, r18
    3718:	ee 5e       	subi	r30, 0xEE	; 238
    371a:	fd 49       	sbci	r31, 0x9D	; 157
    371c:	10 81       	ld	r17, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    371e:	1f 3f       	cpi	r17, 0xFF	; 255
    3720:	f9 f0       	breq	.+62     	; 0x3760 <main+0x214>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3722:	f9 01       	movw	r30, r18
    3724:	e2 5d       	subi	r30, 0xD2	; 210
    3726:	fd 49       	sbci	r31, 0x9D	; 157
    3728:	a0 81       	ld	r26, Z
    372a:	e0 e2       	ldi	r30, 0x20	; 32
    372c:	ae 9f       	mul	r26, r30
    372e:	d0 01       	movw	r26, r0
    3730:	11 24       	eor	r1, r1
    3732:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    3734:	2a 50       	subi	r18, 0x0A	; 10
    3736:	3e 49       	sbci	r19, 0x9E	; 158
    3738:	f9 01       	movw	r30, r18
    373a:	00 81       	ld	r16, Z
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    373c:	f0 e0       	ldi	r31, 0x00	; 0
    373e:	e0 e0       	ldi	r30, 0x00	; 0
_pinMode():
    3740:	08 30       	cpi	r16, 0x08	; 8
    3742:	30 f4       	brcc	.+12     	; 0x3750 <main+0x204>
    3744:	9d 01       	movw	r18, r26
    3746:	20 5f       	subi	r18, 0xF0	; 240
    3748:	3f 4f       	sbci	r19, 0xFF	; 255
    374a:	f9 01       	movw	r30, r18
    374c:	e0 0f       	add	r30, r16
    374e:	f1 1d       	adc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
    3750:	3f b7       	in	r19, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    3752:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    3754:	12 96       	adiw	r26, 0x02	; 2
    3756:	1c 93       	st	X, r17
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:95
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    3758:	20 81       	ld	r18, Z
    375a:	28 60       	ori	r18, 0x08	; 8
    375c:	20 83       	st	Z, r18
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:99
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    }
    SREG = status;                      /* Restore state */
    375e:	3f bf       	out	0x3f, r19	; 63
_mux_set():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:612
      uint8_t temp   = *portmux;
      temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); // Group Mask
      temp          |= mux_code;
      *portmux       = temp;
    #else
      uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 2;
    3760:	fc 01       	movw	r30, r24
    3762:	23 e0       	ldi	r18, 0x03	; 3
    3764:	72 9f       	mul	r23, r18
    3766:	e0 0d       	add	r30, r0
    3768:	f1 1d       	adc	r31, r1
    376a:	11 24       	eor	r1, r1
    376c:	32 96       	adiw	r30, 0x02	; 2
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:614
      /* Only one register, so no offset, so only read a byte */
      uint8_t mux_mask = pgm_read_byte_near(mux_info_ptr);     // only read the group mask
    376e:	e4 91       	lpm	r30, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:616
      volatile uint8_t* portmux = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE);
      uint8_t temp   = *portmux;
    3770:	80 91 e2 05 	lds	r24, 0x05E2	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7f05e2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:617
      temp          &= ~(mux_mask);
    3774:	e0 95       	com	r30
    3776:	e8 23       	and	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:618
      temp          |= mux_code;
    3778:	e4 2b       	or	r30, r20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:619
      *portmux       = temp;
    377a:	e0 93 e2 05 	sts	0x05E2, r30	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7f05e2>
begin():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:76

  Serial.swap(3);
  Serial.begin(115200);      // default CDC channel
  Serial.println(F("\r\n AVRCore test validation suite\r\n"));
    377e:	6f bf       	out	0x3f, r22	; 63
setup():
    3780:	8c e6       	ldi	r24, 0x6C	; 108
    3782:	9a e0       	ldi	r25, 0x0A	; 10
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:77
  Serial.println("AVR128DD48 Curisoity Nano + Nano Explorer");
    3784:	26 dc       	rcall	.-1972   	; 0x2fd2 <Print::println(__FlashStringHelper const*) [clone .constprop.54]>
    3786:	86 e7       	ldi	r24, 0x76	; 118
    3788:	92 e6       	ldi	r25, 0x62	; 98
    378a:	42 dc       	rcall	.-1916   	; 0x3010 <Print::println(char const*) [clone .constprop.25]>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:37
 * @param wire TwoWire interface, defaults to &Wire
 * @returns False if failed to find device at address
 */
bool Adafruit_MCP23008::begin(uint8_t addr, TwoWire *wire) {
  if ((addr >= 0x20) && (addr <= 0x27)) {
    _i2caddr = addr;
    378c:	85 e2       	ldi	r24, 0x25	; 37
    378e:	80 93 39 64 	sts	0x6439, r24	; 0x806439 <mcp_leds+0x2>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:44
    _i2caddr = 0x20 + addr;
  } else {
    _i2caddr = 0x27;
  }

  if (i2c_dev) {
    3792:	80 91 37 64 	lds	r24, 0x6437	; 0x806437 <mcp_leds>
    3796:	90 91 38 64 	lds	r25, 0x6438	; 0x806438 <mcp_leds+0x1>
    379a:	00 97       	sbiw	r24, 0x00	; 0
    379c:	11 f0       	breq	.+4      	; 0x37a2 <main+0x256>
operator delete():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/new.cpp:63
// Since C++14, also need two more delete variants...
// Note thnat this CAN break code that compiled amd worked in C++11.
#if (__cpp_sized_deallocation >= 201309L)
  void  operator delete  (void* ptr, size_t size) noexcept {
    (void) size;
    free(ptr);
    379e:	0e 94 40 27 	call	0x4e80	; 0x4e80 <free>
operator new():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/new.cpp:33

#include <stdlib.h>

// For C++11, only need the following:
void *operator new  (size_t size) {
  return malloc(size);
    37a2:	86 e0       	ldi	r24, 0x06	; 6
    37a4:	90 e0       	ldi	r25, 0x00	; 0
    37a6:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <malloc>
    37aa:	8c 01       	movw	r16, r24
__base_ctor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:11
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
    37ac:	80 91 39 64 	lds	r24, 0x6439	; 0x806439 <mcp_leds+0x2>
    37b0:	d8 01       	movw	r26, r16
    37b2:	8c 93       	st	X, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:12
  _wire = theWire;
    37b4:	80 e5       	ldi	r24, 0x50	; 80
    37b6:	94 e6       	ldi	r25, 0x64	; 100
    37b8:	11 96       	adiw	r26, 0x01	; 1
    37ba:	8d 93       	st	X+, r24
    37bc:	9c 93       	st	X, r25
    37be:	12 97       	sbiw	r26, 0x02	; 2
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:13
  _begun = false;
    37c0:	13 96       	adiw	r26, 0x03	; 3
    37c2:	1c 92       	st	X, r1
    37c4:	13 97       	sbiw	r26, 0x03	; 3
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:19
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#elif defined(ESP32)
  _maxBufferSize = I2C_BUFFER_LENGTH;
#else
  _maxBufferSize = 32;
    37c6:	80 e2       	ldi	r24, 0x20	; 32
    37c8:	90 e0       	ldi	r25, 0x00	; 0
    37ca:	14 96       	adiw	r26, 0x04	; 4
    37cc:	8d 93       	st	X+, r24
    37ce:	9c 93       	st	X, r25
    37d0:	15 97       	sbiw	r26, 0x05	; 5
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:48
    delete i2c_dev; // remove old interface
  }

  i2c_dev = new Adafruit_I2CDevice(_i2caddr, wire);
    37d2:	00 93 37 64 	sts	0x6437, r16	; 0x806437 <mcp_leds>
    37d6:	10 93 38 64 	sts	0x6438, r17	; 0x806438 <mcp_leds+0x1>
TWI_MasterInit():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:51
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_data->_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if ((_data->_bools._hostEnabled | _data->_bools._clientEnabled) == 1) {  //If either are enabled
    37da:	80 91 5a 64 	lds	r24, 0x645A	; 0x80645a <Wire+0xa>
    37de:	81 fd       	sbrc	r24, 1
    37e0:	05 c0       	rjmp	.+10     	; 0x37ec <main+0x2a0>
    37e2:	82 fd       	sbrc	r24, 2
    37e4:	03 c0       	rjmp	.+6      	; 0x37ec <main+0x2a0>
    37e6:	88 e5       	ldi	r24, 0x58	; 88
    37e8:	94 e6       	ldi	r25, 0x64	; 100
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:32
 * don't respond well to a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;
    37ea:	de d8       	rcall	.-3652   	; 0x29a8 <TWI_MasterInit.part.4>
begin():
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	f8 01       	movw	r30, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:35

  if (addr_detect) {
    return detected();
    37f0:	83 83       	std	Z+3, r24	; 0x03
    37f2:	c8 01       	movw	r24, r16
    37f4:	1e db       	rcall	.-2500   	; 0x2e32 <Adafruit_I2CDevice::detected()>
    37f6:	18 2f       	mov	r17, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:50

  if (!i2c_dev->begin()) {
    37f8:	88 23       	and	r24, r24
    37fa:	09 f1       	breq	.+66     	; 0x383e <main+0x2f2>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:55
    return false;
  }

  // set defaults!
  uint8_t buf[] = {MCP23008_IODIR,
    37fc:	9e 01       	movw	r18, r28
    37fe:	2f 5f       	subi	r18, 0xFF	; 255
    3800:	3f 4f       	sbci	r19, 0xFF	; 255
    3802:	79 01       	movw	r14, r18
    3804:	8b e0       	ldi	r24, 0x0B	; 11
    3806:	d9 01       	movw	r26, r18
    3808:	1d 92       	st	X+, r1
    380a:	8a 95       	dec	r24
    380c:	e9 f7       	brne	.-6      	; 0x3808 <main+0x2bc>
    380e:	8f ef       	ldi	r24, 0xFF	; 255
    3810:	8a 83       	std	Y+2, r24	; 0x02
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:59
                   0xFF, // all inputs
                   0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00};
  if (!i2c_dev->write(buf, 10)) // used to be 10
    3812:	00 91 37 64 	lds	r16, 0x6437	; 0x806437 <mcp_leds>
    3816:	10 91 38 64 	lds	r17, 0x6438	; 0x806438 <mcp_leds+0x1>
write():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:105
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
    381a:	f8 01       	movw	r30, r16
    381c:	84 81       	ldd	r24, Z+4	; 0x04
    381e:	95 81       	ldd	r25, Z+5	; 0x05
    3820:	0a 97       	sbiw	r24, 0x0a	; 10
    3822:	08 f4       	brcc	.+2      	; 0x3826 <main+0x2da>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:115
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
    3824:	8e c0       	rjmp	.+284    	; 0x3942 <main+0x3f6>
    3826:	60 81       	ld	r22, Z
    3828:	81 81       	ldd	r24, Z+1	; 0x01
    382a:	92 81       	ldd	r25, Z+2	; 0x02
    382c:	d6 d8       	rcall	.-3668   	; 0x29da <TwoWire::beginTransmission(unsigned char)>
    382e:	21 e0       	ldi	r18, 0x01	; 1
    3830:	4a e0       	ldi	r20, 0x0A	; 10
    3832:	50 e0       	ldi	r21, 0x00	; 0
    3834:	b7 01       	movw	r22, r14
    3836:	c8 01       	movw	r24, r16
    3838:	0e 94 66 0a 	call	0x14cc	; 0x14cc <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .part.1]>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:143
void mcp_led_init(void)
{

  char status = mcp_leds.begin(0x25);
  
  Serial.println("Set up MCP23008 LED IO Expander");
    383c:	18 2f       	mov	r17, r24
mcp_led_init():
    383e:	80 ea       	ldi	r24, 0xA0	; 160
    3840:	92 e6       	ldi	r25, 0x62	; 98
    3842:	e6 db       	rcall	.-2100   	; 0x3010 <Print::println(char const*) [clone .constprop.25]>
write():
    3844:	80 ec       	ldi	r24, 0xC0	; 192
    3846:	92 e6       	ldi	r25, 0x62	; 98
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore\api/Print.cpp:71
size_t Print::print(const char str[]) {
  return write(str);
}

size_t Print::print(char c) {
  return write(c);
    3848:	b7 db       	rcall	.-2194   	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
print():
    384a:	61 2f       	mov	r22, r17
    384c:	87 e9       	ldi	r24, 0x97	; 151
    384e:	93 e6       	ldi	r25, 0x63	; 99
    3850:	0e 94 2e 08 	call	0x105c	; 0x105c <HardwareSerial::write(unsigned char)>
write():
    3854:	8c ee       	ldi	r24, 0xEC	; 236
    3856:	92 e6       	ldi	r25, 0x62	; 98
    3858:	af db       	rcall	.-2210   	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
    385a:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:86

  // set the pin and direction
  if (d == INPUT) {
    iodir |= 1 << p;
  } else {
    iodir &= ~(1 << p);
    385c:	00 e0       	ldi	r16, 0x00	; 0
pinMode():
    385e:	cc 24       	eor	r12, r12
    3860:	c3 94       	inc	r12
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:80

  // only 8 bits!
  if (p > 7)
    return false;

  iodir = read8(MCP23008_IODIR);
    3862:	d1 2c       	mov	r13, r1
    3864:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:86

  // set the pin and direction
  if (d == INPUT) {
    iodir |= 1 << p;
  } else {
    iodir &= ~(1 << p);
    3866:	e2 d9       	rcall	.-3132   	; 0x2c2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]>
    3868:	76 01       	movw	r14, r12
    386a:	00 2e       	mov	r0, r16
    386c:	01 c0       	rjmp	.+2      	; 0x3870 <main+0x324>
    386e:	ee 0c       	add	r14, r14
    3870:	0a 94       	dec	r0
    3872:	ea f7       	brpl	.-6      	; 0x386e <main+0x322>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:90
  }

  // write the new IODIR
  return write8(MCP23008_IODIR, iodir);
    3874:	6e 2d       	mov	r22, r14
    3876:	60 95       	com	r22
    3878:	68 23       	and	r22, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:99
 * @brief Reads the current GPIO input
 * @return Returns the current GPIO input
 */
uint8_t Adafruit_MCP23008::readGPIO(void) {
  // read the current GPIO input
  return read8(MCP23008_GPIO);
    387a:	80 e0       	ldi	r24, 0x00	; 0
    387c:	5b d9       	rcall	.-3402   	; 0x2b34 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]>
readGPIO():
    387e:	89 e0       	ldi	r24, 0x09	; 9
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:129
  // read the current GPIO output latches
  gpio = readGPIO();

  // set the pin and direction
  if (d == HIGH) {
    gpio |= 1 << p;
    3880:	d5 d9       	rcall	.-3158   	; 0x2c2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]>
digitalWrite():
    3882:	68 2f       	mov	r22, r24
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:108
 * @brief Writes to the GPIO
 * @param gpio what to write
 * @returns True on success, False on bad input or I2C failure
 */
bool Adafruit_MCP23008::writeGPIO(uint8_t gpio) {
  return write8(MCP23008_GPIO, gpio);
    3884:	6e 29       	or	r22, r14
writeGPIO():
    3886:	89 e0       	ldi	r24, 0x09	; 9
    3888:	55 d9       	rcall	.-3414   	; 0x2b34 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]>
    388a:	0f 5f       	subi	r16, 0xFF	; 255
    388c:	1f 4f       	sbci	r17, 0xFF	; 255
mcp_led_init():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:148
  
  Serial.print("LED status : ");
  Serial.println(status);

  for(char pin_id = 0;pin_id < 8;pin_id++)
    388e:	08 30       	cpi	r16, 0x08	; 8
    3890:	11 05       	cpc	r17, r1
    3892:	41 f7       	brne	.-48     	; 0x3864 <main+0x318>
dac_init():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:244
#define DAC_CS    PIN_PC2      // AVR IO 26 on C Nano Explorer board

void dac_init(void)
{

  SPI.begin();
    3894:	8a e2       	ldi	r24, 0x2A	; 42
    3896:	94 e6       	ldi	r25, 0x64	; 100
    3898:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <SPIClass::begin()>
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    389c:	84 e0       	ldi	r24, 0x04	; 4
    389e:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <__TEXT_REGION_LENGTH__+0x7f0441>
dac_init():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:246
  pinMode(DAC_CS,OUTPUT);       // set up DAC Chip Select
  digitalWrite(DAC_CS,HIGH);    
    38a2:	61 e0       	ldi	r22, 0x01	; 1
    38a4:	8a e0       	ldi	r24, 0x0A	; 10
    38a6:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:77
  }
  pinMode(pin, INPUT);
}

void tinyNeoPixel::begin(void) {
  pinMode(pin, OUTPUT);
    38aa:	80 91 41 64 	lds	r24, 0x6441	; 0x806441 <pixel_ring+0x7>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    38ae:	28 2f       	mov	r18, r24
    38b0:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    38b2:	8c 31       	cpi	r24, 0x1C	; 28
    38b4:	80 f4       	brcc	.+32     	; 0x38d6 <main+0x38a>
    38b6:	f9 01       	movw	r30, r18
    38b8:	ee 5e       	subi	r30, 0xEE	; 238
    38ba:	fd 49       	sbci	r31, 0x9D	; 157
    38bc:	90 81       	ld	r25, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    38be:	9f 3f       	cpi	r25, 0xFF	; 255
    38c0:	51 f0       	breq	.+20     	; 0x38d6 <main+0x38a>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    38c2:	22 5d       	subi	r18, 0xD2	; 210
    38c4:	3d 49       	sbci	r19, 0x9D	; 157
    38c6:	d9 01       	movw	r26, r18
    38c8:	ec 91       	ld	r30, X
    38ca:	b0 e2       	ldi	r27, 0x20	; 32
    38cc:	eb 9f       	mul	r30, r27
    38ce:	f0 01       	movw	r30, r0
    38d0:	11 24       	eor	r1, r1
    38d2:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    38d4:	91 83       	std	Z+1, r25	; 0x01
begin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:78
  digitalWrite(pin, LOW);
    38d6:	60 e0       	ldi	r22, 0x00	; 0
    38d8:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:79
  begun = true;
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	80 93 3a 64 	sts	0x643A, r24	; 0x80643a <pixel_ring>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:495
    @note   MUST call this function before any drawing or updates!
*/
bool Adafruit_SSD1306::begin(uint8_t vcs, uint8_t addr, bool reset,
                             bool periphBegin) {

  if ((!buffer) && !(buffer = (uint8_t *)malloc(WIDTH * ((HEIGHT + 7) / 8))))
    38e2:	80 91 88 65 	lds	r24, 0x6588	; 0x806588 <display+0x1f>
    38e6:	90 91 89 65 	lds	r25, 0x6589	; 0x806589 <display+0x20>
    38ea:	89 2b       	or	r24, r25
    38ec:	61 f1       	breq	.+88     	; 0x3946 <main+0x3fa>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:498
    return false;

  clearDisplay();
    38ee:	0e 94 3a 13 	call	0x2674	; 0x2674 <Adafruit_SSD1306::clearDisplay() [clone .constprop.47]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:501

#ifndef SSD1306_NO_SPLASH
  if (HEIGHT > 32) {
    38f2:	80 91 6f 65 	lds	r24, 0x656F	; 0x80656f <display+0x6>
    38f6:	90 91 70 65 	lds	r25, 0x6570	; 0x806570 <display+0x7>
    38fa:	60 91 6d 65 	lds	r22, 0x656D	; 0x80656d <display+0x4>
    38fe:	70 91 6e 65 	lds	r23, 0x656E	; 0x80656e <display+0x5>
    3902:	81 32       	cpi	r24, 0x21	; 33
    3904:	91 05       	cpc	r25, r1
    3906:	0c f0       	brlt	.+2      	; 0x390a <main+0x3be>
    3908:	44 c0       	rjmp	.+136    	; 0x3992 <main+0x446>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:505
    drawBitmap((WIDTH - splash1_width) / 2, (HEIGHT - splash1_height) / 2,
               splash1_data, splash1_width, splash1_height, 1);
  } else {
    drawBitmap((WIDTH - splash2_width) / 2, (HEIGHT - splash2_height) / 2,
    390a:	ac 01       	movw	r20, r24
    390c:	40 52       	subi	r20, 0x20	; 32
    390e:	51 09       	sbc	r21, r1
    3910:	57 ff       	sbrs	r21, 7
    3912:	02 c0       	rjmp	.+4      	; 0x3918 <main+0x3cc>
    3914:	4f 5f       	subi	r20, 0xFF	; 255
    3916:	5f 4f       	sbci	r21, 0xFF	; 255
    3918:	55 95       	asr	r21
    391a:	47 95       	ror	r20
    391c:	63 57       	subi	r22, 0x73	; 115
    391e:	71 09       	sbc	r23, r1
    3920:	77 ff       	sbrs	r23, 7
    3922:	02 c0       	rjmp	.+4      	; 0x3928 <main+0x3dc>
    3924:	6f 5f       	subi	r22, 0xFF	; 255
    3926:	7f 4f       	sbci	r23, 0xFF	; 255
    3928:	75 95       	asr	r23
    392a:	67 95       	ror	r22
    392c:	00 e2       	ldi	r16, 0x20	; 32
    392e:	e0 2e       	mov	r14, r16
    3930:	f1 2c       	mov	r15, r1
    3932:	03 e7       	ldi	r16, 0x73	; 115
    3934:	10 e0       	ldi	r17, 0x00	; 0
    3936:	22 eb       	ldi	r18, 0xB2	; 178
    3938:	35 e0       	ldi	r19, 0x05	; 5
    393a:	43 c0       	rjmp	.+134    	; 0x39c2 <main+0x476>
swap():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/UART.cpp:533
        return true;
      } else if (newmux == MUX_NONE) {  // 128 codes for MUX_NONE
        _pin_set = _mux_count;
        return true;
      } else {
        _pin_set = 0;
    393c:	10 92 a4 63 	sts	0x63A4, r1	; 0x8063a4 <Serial0+0xd>
    3940:	94 ce       	rjmp	.-728    	; 0x366a <main+0x11e>
main():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:61
                   0xFF, // all inputs
                   0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00};
  if (!i2c_dev->write(buf, 10)) // used to be 10
  {
    return false;
    3942:	10 e0       	ldi	r17, 0x00	; 0
    3944:	7c cf       	rjmp	.-264    	; 0x383e <main+0x2f2>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:495
    @note   MUST call this function before any drawing or updates!
*/
bool Adafruit_SSD1306::begin(uint8_t vcs, uint8_t addr, bool reset,
                             bool periphBegin) {

  if ((!buffer) && !(buffer = (uint8_t *)malloc(WIDTH * ((HEIGHT + 7) / 8))))
    3946:	20 91 6f 65 	lds	r18, 0x656F	; 0x80656f <display+0x6>
    394a:	30 91 70 65 	lds	r19, 0x6570	; 0x806570 <display+0x7>
    394e:	c9 01       	movw	r24, r18
    3950:	07 96       	adiw	r24, 0x07	; 7
    3952:	97 fd       	sbrc	r25, 7
    3954:	07 96       	adiw	r24, 0x07	; 7
    3956:	43 e0       	ldi	r20, 0x03	; 3
    3958:	95 95       	asr	r25
    395a:	87 95       	ror	r24
    395c:	4a 95       	dec	r20
    395e:	e1 f7       	brne	.-8      	; 0x3958 <main+0x40c>
    3960:	20 91 6d 65 	lds	r18, 0x656D	; 0x80656d <display+0x4>
    3964:	30 91 6e 65 	lds	r19, 0x656E	; 0x80656e <display+0x5>
    3968:	fc 01       	movw	r30, r24
    396a:	e2 9f       	mul	r30, r18
    396c:	c0 01       	movw	r24, r0
    396e:	e3 9f       	mul	r30, r19
    3970:	90 0d       	add	r25, r0
    3972:	f2 9f       	mul	r31, r18
    3974:	90 0d       	add	r25, r0
    3976:	11 24       	eor	r1, r1
    3978:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <malloc>
    397c:	80 93 88 65 	sts	0x6588, r24	; 0x806588 <display+0x1f>
    3980:	90 93 89 65 	sts	0x6589, r25	; 0x806589 <display+0x20>
    3984:	89 2b       	or	r24, r25
    3986:	09 f0       	breq	.+2      	; 0x398a <main+0x43e>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:132
void oled_init(void)
{

 if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
   {
    Serial.println(F("SSD1306 allocation failed"));
    3988:	b2 cf       	rjmp	.-156    	; 0x38ee <main+0x3a2>
oled_init():
    398a:	82 e5       	ldi	r24, 0x52	; 82
    398c:	9a e0       	ldi	r25, 0x0A	; 10
    398e:	21 db       	rcall	.-2494   	; 0x2fd2 <Print::println(__FlashStringHelper const*) [clone .constprop.54]>
    3990:	ff cf       	rjmp	.-2      	; 0x3990 <main+0x444>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:502

  clearDisplay();

#ifndef SSD1306_NO_SPLASH
  if (HEIGHT > 32) {
    drawBitmap((WIDTH - splash1_width) / 2, (HEIGHT - splash1_height) / 2,
    3992:	ac 01       	movw	r20, r24
    3994:	40 54       	subi	r20, 0x40	; 64
    3996:	51 09       	sbc	r21, r1
    3998:	57 ff       	sbrs	r21, 7
    399a:	02 c0       	rjmp	.+4      	; 0x39a0 <main+0x454>
    399c:	4f 5f       	subi	r20, 0xFF	; 255
    399e:	5f 4f       	sbci	r21, 0xFF	; 255
    39a0:	55 95       	asr	r21
    39a2:	47 95       	ror	r20
    39a4:	62 55       	subi	r22, 0x52	; 82
    39a6:	71 09       	sbc	r23, r1
    39a8:	77 ff       	sbrs	r23, 7
    39aa:	02 c0       	rjmp	.+4      	; 0x39b0 <main+0x464>
    39ac:	6f 5f       	subi	r22, 0xFF	; 255
    39ae:	7f 4f       	sbci	r23, 0xFF	; 255
    39b0:	75 95       	asr	r23
    39b2:	67 95       	ror	r22
    39b4:	20 e4       	ldi	r18, 0x40	; 64
    39b6:	e2 2e       	mov	r14, r18
    39b8:	f1 2c       	mov	r15, r1
    39ba:	02 e5       	ldi	r16, 0x52	; 82
    39bc:	10 e0       	ldi	r17, 0x00	; 0
    39be:	22 e9       	ldi	r18, 0x92	; 146
    39c0:	37 e0       	ldi	r19, 0x07	; 7
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:505
               splash1_data, splash1_width, splash1_height, 1);
  } else {
    drawBitmap((WIDTH - splash2_width) / 2, (HEIGHT - splash2_height) / 2,
    39c2:	89 e6       	ldi	r24, 0x69	; 105
    39c4:	95 e6       	ldi	r25, 0x65	; 101
    39c6:	0e 94 65 0f 	call	0x1eca	; 0x1eca <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:510
               splash2_data, splash2_width, splash2_height, 1);
  }
#endif

  vccstate = vcs;
    39ca:	82 e0       	ldi	r24, 0x02	; 2
    39cc:	80 93 8b 65 	sts	0x658B, r24	; 0x80658b <display+0x22>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:513

  // Setup pin directions
  if (wire) { // Using I2C
    39d0:	e0 91 86 65 	lds	r30, 0x6586	; 0x806586 <display+0x1d>
    39d4:	f0 91 87 65 	lds	r31, 0x6587	; 0x806587 <display+0x1e>
    39d8:	30 97       	sbiw	r30, 0x00	; 0
    39da:	09 f4       	brne	.+2      	; 0x39de <main+0x492>
    39dc:	cb c1       	rjmp	.+918    	; 0x3d74 <main+0x828>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:516
    // If I2C address is unspecified, use default
    // (0x3C for 32-pixel-tall displays, 0x3D for all others).
    i2caddr = addr ? addr : ((HEIGHT == 32) ? 0x3C : 0x3D);
    39de:	8d e3       	ldi	r24, 0x3D	; 61
    39e0:	80 93 8a 65 	sts	0x658A, r24	; 0x80658a <display+0x21>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:252
 *@param      void
 *
 *@return     void
 */
void TwoWire::begin(void) {
  TWI_MasterInit(&vars);
    39e4:	9f 01       	movw	r18, r30
    39e6:	28 5f       	subi	r18, 0xF8	; 248
    39e8:	3f 4f       	sbci	r19, 0xFF	; 255
TWI_MasterInit():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/twi.c:51
    39ea:	92 85       	ldd	r25, Z+10	; 0x0a
    39ec:	91 fd       	sbrc	r25, 1
    39ee:	05 c0       	rjmp	.+10     	; 0x39fa <main+0x4ae>
    39f0:	92 fd       	sbrc	r25, 2
    39f2:	03 c0       	rjmp	.+6      	; 0x39fa <main+0x4ae>
    39f4:	c9 01       	movw	r24, r18
    39f6:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <TWI_MasterInit.part.4>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:553
#endif
    }
  }

  // Reset SSD1306 if requested and reset pin specified in constructor
  if (reset && (rstPin >= 0)) {
    39fa:	80 91 91 65 	lds	r24, 0x6591	; 0x806591 <display+0x28>
    39fe:	87 fd       	sbrc	r24, 7
    3a00:	2f c0       	rjmp	.+94     	; 0x3a60 <main+0x514>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    3a02:	28 2f       	mov	r18, r24
    3a04:	08 2e       	mov	r0, r24
    3a06:	00 0c       	add	r0, r0
    3a08:	33 0b       	sbc	r19, r19
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3a0a:	8c 31       	cpi	r24, 0x1C	; 28
    3a0c:	84 f4       	brge	.+32     	; 0x3a2e <main+0x4e2>
    3a0e:	f9 01       	movw	r30, r18
    3a10:	ee 5e       	subi	r30, 0xEE	; 238
    3a12:	fd 49       	sbci	r31, 0x9D	; 157
    3a14:	90 81       	ld	r25, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    3a16:	9f 3f       	cpi	r25, 0xFF	; 255
    3a18:	51 f0       	breq	.+20     	; 0x3a2e <main+0x4e2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3a1a:	22 5d       	subi	r18, 0xD2	; 210
    3a1c:	3d 49       	sbci	r19, 0x9D	; 157
    3a1e:	d9 01       	movw	r26, r18
    3a20:	ec 91       	ld	r30, X
    3a22:	b0 e2       	ldi	r27, 0x20	; 32
    3a24:	eb 9f       	mul	r30, r27
    3a26:	f0 01       	movw	r30, r0
    3a28:	11 24       	eor	r1, r1
    3a2a:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3a2c:	91 83       	std	Z+1, r25	; 0x01
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:555
    pinMode(rstPin, OUTPUT);
    digitalWrite(rstPin, HIGH);
    3a2e:	61 e0       	ldi	r22, 0x01	; 1
    3a30:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:556
    delay(1);                   // VDD goes high at start, pause for 1 ms
    3a34:	61 e0       	ldi	r22, 0x01	; 1
    3a36:	70 e0       	ldi	r23, 0x00	; 0
    3a38:	80 e0       	ldi	r24, 0x00	; 0
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	0e 94 23 07 	call	0xe46	; 0xe46 <delay>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:557
    digitalWrite(rstPin, LOW);  // Bring reset low
    3a40:	60 e0       	ldi	r22, 0x00	; 0
    3a42:	80 91 91 65 	lds	r24, 0x6591	; 0x806591 <display+0x28>
    3a46:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:558
    delay(10);                  // Wait 10 ms
    3a4a:	6a e0       	ldi	r22, 0x0A	; 10
    3a4c:	70 e0       	ldi	r23, 0x00	; 0
    3a4e:	80 e0       	ldi	r24, 0x00	; 0
    3a50:	90 e0       	ldi	r25, 0x00	; 0
    3a52:	0e 94 23 07 	call	0xe46	; 0xe46 <delay>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:559
    digitalWrite(rstPin, HIGH); // Bring out of reset
    3a56:	61 e0       	ldi	r22, 0x01	; 1
    3a58:	80 91 91 65 	lds	r24, 0x6591	; 0x806591 <display+0x28>
    3a5c:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:562
  }

  TRANSACTION_START
    3a60:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    3a64:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    3a68:	00 97       	sbiw	r24, 0x00	; 0
    3a6a:	09 f4       	brne	.+2      	; 0x3a6e <main+0x522>
    3a6c:	85 c2       	rjmp	.+1290   	; 0x3f78 <main+0xa2c>
setClock():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
 *@return     uint8_t
 *@retval       0 if no error occurred
 *@retval       1 if a problem occurred
 */
uint8_t TwoWire::setClock(uint32_t clock) {
  return TWI_MasterSetBaud(&vars, clock);
    3a6e:	40 91 9e 65 	lds	r20, 0x659E	; 0x80659e <display+0x35>
    3a72:	50 91 9f 65 	lds	r21, 0x659F	; 0x80659f <display+0x36>
    3a76:	60 91 a0 65 	lds	r22, 0x65A0	; 0x8065a0 <display+0x37>
    3a7a:	70 91 a1 65 	lds	r23, 0x65A1	; 0x8065a1 <display+0x38>
    3a7e:	08 96       	adiw	r24, 0x08	; 8
    3a80:	0e 94 c7 14 	call	0x298e	; 0x298e <TWI_MasterSetBaud>
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:569
  // Init sequence
  static const uint8_t PROGMEM init1[] = {SSD1306_DISPLAYOFF,         // 0xAE
                                          SSD1306_SETDISPLAYCLOCKDIV, // 0xD5
                                          0x80, // the suggested ratio 0x80
                                          SSD1306_SETMULTIPLEX}; // 0xA8
  ssd1306_commandList(init1, sizeof(init1));
    3a84:	64 e0       	ldi	r22, 0x04	; 4
    3a86:	8e ea       	ldi	r24, 0xAE	; 174
    3a88:	95 e0       	ldi	r25, 0x05	; 5
    3a8a:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:570
  ssd1306_command1(HEIGHT - 1);
    3a8e:	60 91 6f 65 	lds	r22, 0x656F	; 0x80656f <display+0x6>
    3a92:	61 50       	subi	r22, 0x01	; 1
    3a94:	89 e6       	ldi	r24, 0x69	; 105
    3a96:	95 e6       	ldi	r25, 0x65	; 101
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:576

  static const uint8_t PROGMEM init2[] = {SSD1306_SETDISPLAYOFFSET, // 0xD3
                                          0x0,                      // no offset
                                          SSD1306_SETSTARTLINE | 0x0, // line #0
                                          SSD1306_CHARGEPUMP};        // 0x8D
  ssd1306_commandList(init2, sizeof(init2));
    3a98:	f2 d9       	rcall	.-3100   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3a9a:	64 e0       	ldi	r22, 0x04	; 4
    3a9c:	8a ea       	ldi	r24, 0xAA	; 170
    3a9e:	95 e0       	ldi	r25, 0x05	; 5
    3aa0:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:578

  ssd1306_command1((vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0x14);
    3aa4:	80 91 8b 65 	lds	r24, 0x658B	; 0x80658b <display+0x22>
main():
    3aa8:	60 e1       	ldi	r22, 0x10	; 16
begin():
    3aaa:	81 30       	cpi	r24, 0x01	; 1
    3aac:	09 f0       	breq	.+2      	; 0x3ab0 <main+0x564>
main():
    3aae:	64 e1       	ldi	r22, 0x14	; 20
begin():
    3ab0:	89 e6       	ldi	r24, 0x69	; 105
    3ab2:	95 e6       	ldi	r25, 0x65	; 101
    3ab4:	e4 d9       	rcall	.-3128   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:584

  static const uint8_t PROGMEM init3[] = {SSD1306_MEMORYMODE, // 0x20
                                          0x00, // 0x0 act like ks0108
                                          SSD1306_SEGREMAP | 0x1,
                                          SSD1306_COMSCANDEC};
  ssd1306_commandList(init3, sizeof(init3));
    3ab6:	64 e0       	ldi	r22, 0x04	; 4
    3ab8:	86 ea       	ldi	r24, 0xA6	; 166
    3aba:	95 e0       	ldi	r25, 0x05	; 5
    3abc:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:587

  uint8_t comPins = 0x02;
  contrast = 0x8F;
    3ac0:	8f e8       	ldi	r24, 0x8F	; 143
    3ac2:	80 93 a6 65 	sts	0x65A6, r24	; 0x8065a6 <display+0x3d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:589

  if ((WIDTH == 128) && (HEIGHT == 32)) {
    3ac6:	80 91 6d 65 	lds	r24, 0x656D	; 0x80656d <display+0x4>
    3aca:	90 91 6e 65 	lds	r25, 0x656E	; 0x80656e <display+0x5>
    3ace:	80 38       	cpi	r24, 0x80	; 128
    3ad0:	91 05       	cpc	r25, r1
    3ad2:	09 f0       	breq	.+2      	; 0x3ad6 <main+0x58a>
    3ad4:	6a c2       	rjmp	.+1236   	; 0x3faa <main+0xa5e>
    3ad6:	80 91 6f 65 	lds	r24, 0x656F	; 0x80656f <display+0x6>
    3ada:	90 91 70 65 	lds	r25, 0x6570	; 0x806570 <display+0x7>
    3ade:	80 34       	cpi	r24, 0x40	; 64
    3ae0:	91 05       	cpc	r25, r1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:594
    comPins = 0x02;
    contrast = 0x8F;
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
    comPins = 0x12;
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF;
    3ae2:	09 f0       	breq	.+2      	; 0x3ae6 <main+0x59a>
    3ae4:	72 c2       	rjmp	.+1252   	; 0x3fca <main+0xa7e>
    3ae6:	80 91 8b 65 	lds	r24, 0x658B	; 0x80658b <display+0x22>
    3aea:	81 30       	cpi	r24, 0x01	; 1
    3aec:	09 f0       	breq	.+2      	; 0x3af0 <main+0x5a4>
    3aee:	5b c2       	rjmp	.+1206   	; 0x3fa6 <main+0xa5a>
main():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:593

  if ((WIDTH == 128) && (HEIGHT == 32)) {
    comPins = 0x02;
    contrast = 0x8F;
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
    comPins = 0x12;
    3af0:	8f e9       	ldi	r24, 0x9F	; 159
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:602
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0xAF;
  } else {
    // Other screen varieties -- TBD
  }

  ssd1306_command1(SSD1306_SETCOMPINS);
    3af2:	80 93 a6 65 	sts	0x65A6, r24	; 0x8065a6 <display+0x3d>
main():
    3af6:	12 e1       	ldi	r17, 0x12	; 18
begin():
    3af8:	6a ed       	ldi	r22, 0xDA	; 218
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:603
  ssd1306_command1(comPins);
    3afa:	89 e6       	ldi	r24, 0x69	; 105
    3afc:	95 e6       	ldi	r25, 0x65	; 101
    3afe:	bf d9       	rcall	.-3202   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3b00:	61 2f       	mov	r22, r17
    3b02:	89 e6       	ldi	r24, 0x69	; 105
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:604
  ssd1306_command1(SSD1306_SETCONTRAST);
    3b04:	95 e6       	ldi	r25, 0x65	; 101
    3b06:	bb d9       	rcall	.-3210   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3b08:	61 e8       	ldi	r22, 0x81	; 129
    3b0a:	89 e6       	ldi	r24, 0x69	; 105
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:605
  ssd1306_command1(contrast);
    3b0c:	95 e6       	ldi	r25, 0x65	; 101
    3b0e:	b7 d9       	rcall	.-3218   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3b10:	60 91 a6 65 	lds	r22, 0x65A6	; 0x8065a6 <display+0x3d>
    3b14:	89 e6       	ldi	r24, 0x69	; 105
    3b16:	95 e6       	ldi	r25, 0x65	; 101
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:607

  ssd1306_command1(SSD1306_SETPRECHARGE); // 0xd9
    3b18:	b2 d9       	rcall	.-3228   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3b1a:	69 ed       	ldi	r22, 0xD9	; 217
    3b1c:	89 e6       	ldi	r24, 0x69	; 105
    3b1e:	95 e6       	ldi	r25, 0x65	; 101
    3b20:	ae d9       	rcall	.-3236   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:608
  ssd1306_command1((vccstate == SSD1306_EXTERNALVCC) ? 0x22 : 0xF1);
    3b22:	80 91 8b 65 	lds	r24, 0x658B	; 0x80658b <display+0x22>
main():
    3b26:	62 e2       	ldi	r22, 0x22	; 34
begin():
    3b28:	81 30       	cpi	r24, 0x01	; 1
    3b2a:	09 f0       	breq	.+2      	; 0x3b2e <main+0x5e2>
main():
    3b2c:	61 ef       	ldi	r22, 0xF1	; 241
begin():
    3b2e:	89 e6       	ldi	r24, 0x69	; 105
    3b30:	95 e6       	ldi	r25, 0x65	; 101
    3b32:	a5 d9       	rcall	.-3254   	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    3b34:	66 e0       	ldi	r22, 0x06	; 6
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:616
      0x40,
      SSD1306_DISPLAYALLON_RESUME, // 0xA4
      SSD1306_NORMALDISPLAY,       // 0xA6
      SSD1306_DEACTIVATE_SCROLL,
      SSD1306_DISPLAYON}; // Main screen turn on
  ssd1306_commandList(init5, sizeof(init5));
    3b36:	80 ea       	ldi	r24, 0xA0	; 160
    3b38:	95 e0       	ldi	r25, 0x05	; 5
    3b3a:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>
    3b3e:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:618

  TRANSACTION_END
    3b42:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    3b46:	00 97       	sbiw	r24, 0x00	; 0
    3b48:	09 f4       	brne	.+2      	; 0x3b4c <main+0x600>
    3b4a:	43 c2       	rjmp	.+1158   	; 0x3fd2 <main+0xa86>
setClock():
    3b4c:	40 91 a2 65 	lds	r20, 0x65A2	; 0x8065a2 <display+0x39>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
    3b50:	50 91 a3 65 	lds	r21, 0x65A3	; 0x8065a3 <display+0x3a>
    3b54:	60 91 a4 65 	lds	r22, 0x65A4	; 0x8065a4 <display+0x3b>
    3b58:	70 91 a5 65 	lds	r23, 0x65A5	; 0x8065a5 <display+0x3c>
    3b5c:	08 96       	adiw	r24, 0x08	; 8
    3b5e:	0e 94 c7 14 	call	0x298e	; 0x298e <TWI_MasterSetBaud>
scan_adc_channels():
    3b62:	ae e1       	ldi	r26, 0x1E	; 30
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:221
      last_scan_time = current_scan_time;
      scan_count++;
      analogRead_Resolution(10);       // 10 bit resolution
      analogRead_setsample(1);        // single sample mode

      sprintf(uart_str,"adc scan %lu\r\n",scan_count);
    3b64:	2a 2e       	mov	r2, r26
    3b66:	a3 e6       	ldi	r26, 0x63	; 99
    3b68:	3a 2e       	mov	r3, r26
random():
    3b6a:	b9 e0       	ldi	r27, 0x09	; 9
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/WMath.cpp:38

long random(long howbig) {
  if (howbig == 0) {
    return 0;
  }
  return random() % howbig;
    3b6c:	4b 2e       	mov	r4, r27
    3b6e:	51 2c       	mov	r5, r1
    3b70:	61 2c       	mov	r6, r1
    3b72:	71 2c       	mov	r7, r1
sys_blink():
    3b74:	dd 24       	eor	r13, r13
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:120
  else
    {
        if((led_time_now - led_time_last) > 900UL)
          {
              led_time_last = led_time_now;
              led_state = true;
    3b76:	d3 94       	inc	r13
setPixelColor():
    3b78:	f3 e0       	ldi	r31, 0x03	; 3
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1196
      r = (r * brightness) >> 8;
      g = (g * brightness) >> 8;
      b = (b * brightness) >> 8;
    }
    if (wOffset == rOffset) {
      p = &pixels[n * 3];
    3b7a:	cf 2e       	mov	r12, r31
sys_blink():
    3b7c:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:104
{

  static uint32_t led_time_last = 0UL,led_time_now;
  static uint8_t led_state = false;

  led_time_now = millis();
    3b80:	00 91 0d 63 	lds	r16, 0x630D	; 0x80630d <sys_blink()::led_time_last>
    3b84:	10 91 0e 63 	lds	r17, 0x630E	; 0x80630e <sys_blink()::led_time_last+0x1>
    3b88:	20 91 0f 63 	lds	r18, 0x630F	; 0x80630f <sys_blink()::led_time_last+0x2>
    3b8c:	30 91 10 63 	lds	r19, 0x6310	; 0x806310 <sys_blink()::led_time_last+0x3>
    3b90:	40 91 11 63 	lds	r20, 0x6311	; 0x806311 <sys_blink()::led_state>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:105
  if(led_state)   // board led on
    3b94:	4b 01       	movw	r8, r22
    3b96:	5c 01       	movw	r10, r24
    3b98:	80 1a       	sub	r8, r16
    3b9a:	91 0a       	sbc	r9, r17
    3b9c:	a2 0a       	sbc	r10, r18
    3b9e:	b3 0a       	sbc	r11, r19
    3ba0:	95 01       	movw	r18, r10
    3ba2:	84 01       	movw	r16, r8
    3ba4:	44 23       	and	r20, r20
    3ba6:	09 f4       	brne	.+2      	; 0x3baa <main+0x65e>
    3ba8:	27 c2       	rjmp	.+1102   	; 0x3ff8 <main+0xaac>
    3baa:	05 36       	cpi	r16, 0x65	; 101
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:107
    {
        if((led_time_now - led_time_last) > 100UL)    // led on time expired
    3bac:	11 05       	cpc	r17, r1
    3bae:	21 05       	cpc	r18, r1
    3bb0:	31 05       	cpc	r19, r1
    3bb2:	70 f0       	brcs	.+28     	; 0x3bd0 <main+0x684>
    3bb4:	60 93 0d 63 	sts	0x630D, r22	; 0x80630d <sys_blink()::led_time_last>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:109
          {
              led_time_last = led_time_now;
    3bb8:	70 93 0e 63 	sts	0x630E, r23	; 0x80630e <sys_blink()::led_time_last+0x1>
    3bbc:	80 93 0f 63 	sts	0x630F, r24	; 0x80630f <sys_blink()::led_time_last+0x2>
    3bc0:	90 93 10 63 	sts	0x6310, r25	; 0x806310 <sys_blink()::led_time_last+0x3>
    3bc4:	10 92 11 63 	sts	0x6311, r1	; 0x806311 <sys_blink()::led_state>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:110
              led_state = false;
    3bc8:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:111
              digitalWrite(PIN_PF5,HIGH);
    3bca:	89 e1       	ldi	r24, 0x19	; 25
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:121
    {
        if((led_time_now - led_time_last) > 900UL)
          {
              led_time_last = led_time_now;
              led_state = true;
              digitalWrite(PIN_PF5,LOW);
    3bcc:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
scan_adc_channels():
    3bd0:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:211

  static uint32_t last_scan_time = 0UL, current_scan_time;
  int16_t adc_sample;
  static uint32_t scan_count = 0UL;

  current_scan_time = millis();
    3bd4:	00 91 72 63 	lds	r16, 0x6372	; 0x806372 <scan_adc_channels()::last_scan_time>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:213

  if((current_scan_time - last_scan_time) > 2000)   // 2 second scans
    3bd8:	10 91 73 63 	lds	r17, 0x6373	; 0x806373 <scan_adc_channels()::last_scan_time+0x1>
    3bdc:	20 91 74 63 	lds	r18, 0x6374	; 0x806374 <scan_adc_channels()::last_scan_time+0x2>
    3be0:	30 91 75 63 	lds	r19, 0x6375	; 0x806375 <scan_adc_channels()::last_scan_time+0x3>
    3be4:	4b 01       	movw	r8, r22
    3be6:	5c 01       	movw	r10, r24
    3be8:	80 1a       	sub	r8, r16
    3bea:	91 0a       	sbc	r9, r17
    3bec:	a2 0a       	sbc	r10, r18
    3bee:	b3 0a       	sbc	r11, r19
    3bf0:	95 01       	movw	r18, r10
    3bf2:	84 01       	movw	r16, r8
    3bf4:	01 3d       	cpi	r16, 0xD1	; 209
    3bf6:	17 40       	sbci	r17, 0x07	; 7
    3bf8:	21 05       	cpc	r18, r1
    3bfa:	31 05       	cpc	r19, r1
    3bfc:	08 f4       	brcc	.+2      	; 0x3c00 <main+0x6b4>
    3bfe:	70 c0       	rjmp	.+224    	; 0x3ce0 <main+0x794>
    3c00:	60 93 72 63 	sts	0x6372, r22	; 0x806372 <scan_adc_channels()::last_scan_time>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:216
  {

      last_scan_time = current_scan_time;
    3c04:	70 93 73 63 	sts	0x6373, r23	; 0x806373 <scan_adc_channels()::last_scan_time+0x1>
    3c08:	80 93 74 63 	sts	0x6374, r24	; 0x806374 <scan_adc_channels()::last_scan_time+0x2>
    3c0c:	90 93 75 63 	sts	0x6375, r25	; 0x806375 <scan_adc_channels()::last_scan_time+0x3>
    3c10:	80 91 6e 63 	lds	r24, 0x636E	; 0x80636e <scan_adc_channels()::scan_count>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:217
      scan_count++;
    3c14:	90 91 6f 63 	lds	r25, 0x636F	; 0x80636f <scan_adc_channels()::scan_count+0x1>
    3c18:	a0 91 70 63 	lds	r26, 0x6370	; 0x806370 <scan_adc_channels()::scan_count+0x2>
    3c1c:	b0 91 71 63 	lds	r27, 0x6371	; 0x806371 <scan_adc_channels()::scan_count+0x3>
    3c20:	01 96       	adiw	r24, 0x01	; 1
    3c22:	a1 1d       	adc	r26, r1
    3c24:	b1 1d       	adc	r27, r1
    3c26:	80 93 6e 63 	sts	0x636E, r24	; 0x80636e <scan_adc_channels()::scan_count>
    3c2a:	90 93 6f 63 	sts	0x636F, r25	; 0x80636f <scan_adc_channels()::scan_count+0x1>
    3c2e:	a0 93 70 63 	sts	0x6370, r26	; 0x806370 <scan_adc_channels()::scan_count+0x2>
    3c32:	b0 93 71 63 	sts	0x6371, r27	; 0x806371 <scan_adc_channels()::scan_count+0x3>
analogRead_Resolution():
    3c36:	e0 91 12 63 	lds	r30, 0x6312	; 0x806312 <adc_resolution>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:163
  }

void analogRead_Resolution(uint8_t adc_res)
{

    adc_resolution(adc_res);
    3c3a:	f0 91 13 63 	lds	r31, 0x6313	; 0x806313 <adc_resolution+0x1>
    3c3e:	8a e0       	ldi	r24, 0x0A	; 10
    3c40:	09 95       	icall
    3c42:	ec e0       	ldi	r30, 0x0C	; 12
    3c44:	f0 e6       	ldi	r31, 0x60	; 96
main():
    3c46:	8f ef       	ldi	r24, 0xFF	; 255
analogRead_setsample():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:319

#ifdef ADC_TYPE1
void analogRead_setsample(uint8_t sample_count)
{

  uint8_t scan_index,ctrlb_val = 0xFF;
    3c48:	90 85       	ldd	r25, Z+8	; 0x08
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:324

  for(scan_index = 0;scan_index < 8;scan_index++)
  {

    if(ADC0_samplenum_index[1][scan_index] == sample_count)
    3c4a:	91 30       	cpi	r25, 0x01	; 1
    3c4c:	09 f4       	brne	.+2      	; 0x3c50 <main+0x704>
    3c4e:	80 81       	ld	r24, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:325
      ctrlb_val = ADC0_samplenum_index[0][scan_index];    // extract correct value CTRLB reg
    3c50:	31 96       	adiw	r30, 0x01	; 1
    3c52:	a4 e1       	ldi	r26, 0x14	; 20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:321
void analogRead_setsample(uint8_t sample_count)
{

  uint8_t scan_index,ctrlb_val = 0xFF;

  for(scan_index = 0;scan_index < 8;scan_index++)
    3c54:	b0 e6       	ldi	r27, 0x60	; 96
    3c56:	ae 17       	cp	r26, r30
    3c58:	bf 07       	cpc	r27, r31
    3c5a:	b1 f7       	brne	.-20     	; 0x3c48 <main+0x6fc>
    3c5c:	d0 92 16 63 	sts	0x6316, r13	; 0x806316 <adc_config+0x2>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:331
  }

  if(ctrlb_val == 0xFF)
    {
      ctrlb_val = 0x00;      // set to single sample if not valid
      adc_config.sample_number = 1;  
    3c60:	8f 3f       	cpi	r24, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:328

    if(ADC0_samplenum_index[1][scan_index] == sample_count)
      ctrlb_val = ADC0_samplenum_index[0][scan_index];    // extract correct value CTRLB reg
  }

  if(ctrlb_val == 0xFF)
    3c62:	09 f4       	brne	.+2      	; 0x3c66 <main+0x71a>
main():
    3c64:	80 e0       	ldi	r24, 0x00	; 0
analogRead_setsample():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/adc_core.c:330
    {
      ctrlb_val = 0x00;      // set to single sample if not valid
    3c66:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x7f0601>
scan_adc_channels():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:221
      analogRead_Resolution(10);       // 10 bit resolution
      analogRead_setsample(1);        // single sample mode

      sprintf(uart_str,"adc scan %lu\r\n",scan_count);
    3c6a:	80 91 71 63 	lds	r24, 0x6371	; 0x806371 <scan_adc_channels()::scan_count+0x3>
    3c6e:	8f 93       	push	r24
    3c70:	80 91 70 63 	lds	r24, 0x6370	; 0x806370 <scan_adc_channels()::scan_count+0x2>
    3c74:	8f 93       	push	r24
    3c76:	80 91 6f 63 	lds	r24, 0x636F	; 0x80636f <scan_adc_channels()::scan_count+0x1>
    3c7a:	8f 93       	push	r24
    3c7c:	80 91 6e 63 	lds	r24, 0x636E	; 0x80636e <scan_adc_channels()::scan_count>
    3c80:	8f 93       	push	r24
    3c82:	ee ec       	ldi	r30, 0xCE	; 206
    3c84:	f2 e6       	ldi	r31, 0x62	; 98
    3c86:	ff 93       	push	r31
    3c88:	ef 93       	push	r30
    3c8a:	3f 92       	push	r3
    3c8c:	2f 92       	push	r2
    3c8e:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <sprintf>
write():
    3c92:	8e e1       	ldi	r24, 0x1E	; 30
    3c94:	93 e6       	ldi	r25, 0x63	; 99
    3c96:	90 d9       	rcall	.-3296   	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
scan_adc_channels():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:224
      Serial.print(uart_str);

      adc_sample = analogRead(PIN_PD7);
    3c98:	83 e1       	ldi	r24, 0x13	; 19
    3c9a:	0e 94 b7 07 	call	0xf6e	; 0xf6e <analogRead>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:225
      sprintf(uart_str,"analog PD7 : %d\r\n",adc_sample);
    3c9e:	9f 93       	push	r25
    3ca0:	8f 93       	push	r24
    3ca2:	ed ed       	ldi	r30, 0xDD	; 221
    3ca4:	ae 2e       	mov	r10, r30
    3ca6:	e2 e6       	ldi	r30, 0x62	; 98
    3ca8:	be 2e       	mov	r11, r30
    3caa:	bf 92       	push	r11
    3cac:	af 92       	push	r10
    3cae:	3f 92       	push	r3
    3cb0:	2f 92       	push	r2
    3cb2:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <sprintf>
write():
    3cb6:	8e e1       	ldi	r24, 0x1E	; 30
    3cb8:	93 e6       	ldi	r25, 0x63	; 99
    3cba:	7e d9       	rcall	.-3332   	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
scan_adc_channels():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:228
      Serial.print(uart_str);
 
      adc_sample = analogRead(PIN_PD6);
    3cbc:	82 e1       	ldi	r24, 0x12	; 18
    3cbe:	0e 94 b7 07 	call	0xf6e	; 0xf6e <analogRead>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:229
      sprintf(uart_str,"analog PD6 : %d\r\n\n",adc_sample);
    3cc2:	9f 93       	push	r25
    3cc4:	8f 93       	push	r24
    3cc6:	4f ee       	ldi	r20, 0xEF	; 239
    3cc8:	52 e6       	ldi	r21, 0x62	; 98
    3cca:	5f 93       	push	r21
    3ccc:	4f 93       	push	r20
    3cce:	3f 92       	push	r3
    3cd0:	2f 92       	push	r2
    3cd2:	0e 94 d4 27 	call	0x4fa8	; 0x4fa8 <sprintf>
write():
    3cd6:	8e e1       	ldi	r24, 0x1E	; 30
    3cd8:	93 e6       	ldi	r25, 0x63	; 99
    3cda:	6e d9       	rcall	.-3364   	; 0x2fb8 <Print::write(char const*) [clone .part.2] [clone .constprop.57]>
    3cdc:	cd bf       	out	0x3d, r28	; 61
    3cde:	de bf       	out	0x3e, r29	; 62
cylon():
    3ce0:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:164
    static uint8_t led_index = 0,led_state = false,led_dir = true;
    static unsigned long cylon_timer = 0UL;
    unsigned long now;
    uint8_t clr_index;

    now = millis();
    3ce4:	00 91 78 63 	lds	r16, 0x6378	; 0x806378 <cylon()::cylon_timer>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:165
    if(now - cylon_timer > 37UL)
    3ce8:	10 91 79 63 	lds	r17, 0x6379	; 0x806379 <cylon()::cylon_timer+0x1>
    3cec:	20 91 7a 63 	lds	r18, 0x637A	; 0x80637a <cylon()::cylon_timer+0x2>
    3cf0:	30 91 7b 63 	lds	r19, 0x637B	; 0x80637b <cylon()::cylon_timer+0x3>
    3cf4:	4b 01       	movw	r8, r22
    3cf6:	5c 01       	movw	r10, r24
    3cf8:	80 1a       	sub	r8, r16
    3cfa:	91 0a       	sbc	r9, r17
    3cfc:	a2 0a       	sbc	r10, r18
    3cfe:	b3 0a       	sbc	r11, r19
    3d00:	95 01       	movw	r18, r10
    3d02:	84 01       	movw	r16, r8
    3d04:	06 32       	cpi	r16, 0x26	; 38
    3d06:	11 05       	cpc	r17, r1
    3d08:	21 05       	cpc	r18, r1
    3d0a:	31 05       	cpc	r19, r1
    3d0c:	08 f4       	brcc	.+2      	; 0x3d10 <main+0x7c4>
    3d0e:	9c c1       	rjmp	.+824    	; 0x4048 <main+0xafc>
    3d10:	60 93 78 63 	sts	0x6378, r22	; 0x806378 <cylon()::cylon_timer>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:167
    {
        cylon_timer = now;
    3d14:	70 93 79 63 	sts	0x6379, r23	; 0x806379 <cylon()::cylon_timer+0x1>
    3d18:	80 93 7a 63 	sts	0x637A, r24	; 0x80637a <cylon()::cylon_timer+0x2>
    3d1c:	90 93 7b 63 	sts	0x637B, r25	; 0x80637b <cylon()::cylon_timer+0x3>
    3d20:	10 91 76 63 	lds	r17, 0x6376	; 0x806376 <cylon()::led_index>
    3d24:	80 91 77 63 	lds	r24, 0x6377	; 0x806377 <cylon()::led_state>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:168
        if(led_state)
    3d28:	88 23       	and	r24, r24
    3d2a:	09 f4       	brne	.+2      	; 0x3d2e <main+0x7e2>
    3d2c:	77 c1       	rjmp	.+750    	; 0x401c <main+0xad0>
    3d2e:	10 92 77 63 	sts	0x6377, r1	; 0x806377 <cylon()::led_state>
digitalWrite():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:170
          {
              led_state = false;
    3d32:	18 30       	cpi	r17, 0x08	; 8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:121
 */
bool Adafruit_MCP23008::digitalWrite(uint8_t p, uint8_t d) {
  uint8_t gpio;

  // only 8 bits!
  if (p > 7)
    3d34:	88 f4       	brcc	.+34     	; 0x3d58 <main+0x80c>
readGPIO():
    3d36:	89 e0       	ldi	r24, 0x09	; 9
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:99
 * @brief Reads the current GPIO input
 * @return Returns the current GPIO input
 */
uint8_t Adafruit_MCP23008::readGPIO(void) {
  // read the current GPIO input
  return read8(MCP23008_GPIO);
    3d38:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]>
digitalWrite():
    3d3c:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:129
  // read the current GPIO output latches
  gpio = readGPIO();

  // set the pin and direction
  if (d == HIGH) {
    gpio |= 1 << p;
    3d3e:	70 e0       	ldi	r23, 0x00	; 0
    3d40:	01 c0       	rjmp	.+2      	; 0x3d44 <main+0x7f8>
    3d42:	66 0f       	add	r22, r22
    3d44:	1a 95       	dec	r17
    3d46:	ea f7       	brpl	.-6      	; 0x3d42 <main+0x7f6>
    3d48:	68 2b       	or	r22, r24
writeGPIO():
    3d4a:	89 e0       	ldi	r24, 0x09	; 9
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:108
 * @brief Writes to the GPIO
 * @param gpio what to write
 * @returns True on success, False on bad input or I2C failure
 */
bool Adafruit_MCP23008::writeGPIO(uint8_t gpio) {
  return write8(MCP23008_GPIO, gpio);
    3d4c:	0e 94 9a 15 	call	0x2b34	; 0x2b34 <Adafruit_MCP23008::write8(unsigned char, unsigned char) [clone .constprop.35]>
cylon():
    3d50:	80 91 77 63 	lds	r24, 0x6377	; 0x806377 <cylon()::led_state>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:179
          {
            led_state = true;
            mcp_leds.digitalWrite(led_index,LOW);
          }
        
        if(led_state == false)
    3d54:	81 11       	cpse	r24, r1
    3d56:	78 c1       	rjmp	.+752    	; 0x4048 <main+0xafc>
    3d58:	80 91 76 63 	lds	r24, 0x6376	; 0x806376 <cylon()::led_index>
    3d5c:	90 91 00 60 	lds	r25, 0x6000	; 0x806000 <__DATA_REGION_ORIGIN__>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:181
        {
           if(led_dir)
    3d60:	99 23       	and	r25, r25
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <main+0x81a>
    3d64:	d6 c2       	rjmp	.+1452   	; 0x4312 <main+0xdc6>
    3d66:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:183
            {
              led_index++;
    3d68:	85 30       	cpi	r24, 0x05	; 5
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:184
              if(led_index > 4)
    3d6a:	08 f0       	brcs	.+2      	; 0x3d6e <main+0x822>
    3d6c:	67 c1       	rjmp	.+718    	; 0x403c <main+0xaf0>
    3d6e:	80 93 76 63 	sts	0x6376, r24	; 0x806376 <cylon()::led_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:192
                  led_dir = false;
                }
            }
           else
              {
                led_index--;
    3d72:	6a c1       	rjmp	.+724    	; 0x4048 <main+0xafc>
begin():
    3d74:	40 91 8f 65 	lds	r20, 0x658F	; 0x80658f <display+0x26>
check_valid_digital_pin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:524
    // can accept different SDA/SCL pins, or if two SSD1306 instances
    // with different addresses -- only a single begin() is needed).
    if (periphBegin)
      wire->begin();
  } else { // Using one of the SPI modes, either soft or hardware
    pinMode(dcPin, OUTPUT); // Set data/command pin as output
    3d78:	84 2f       	mov	r24, r20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    3d7a:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    3d7c:	4c 31       	cpi	r20, 0x1C	; 28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3d7e:	88 f4       	brcc	.+34     	; 0x3da2 <main+0x856>
    3d80:	dc 01       	movw	r26, r24
    3d82:	ae 5e       	subi	r26, 0xEE	; 238
    3d84:	bd 49       	sbci	r27, 0x9D	; 157
    3d86:	2c 91       	ld	r18, X
    3d88:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    3d8a:	59 f0       	breq	.+22     	; 0x3da2 <main+0x856>
    3d8c:	82 5d       	subi	r24, 0xD2	; 210
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3d8e:	9d 49       	sbci	r25, 0x9D	; 157
    3d90:	dc 01       	movw	r26, r24
    3d92:	9c 91       	ld	r25, X
    3d94:	e0 e2       	ldi	r30, 0x20	; 32
    3d96:	9e 9f       	mul	r25, r30
    3d98:	d0 01       	movw	r26, r0
    3d9a:	11 24       	eor	r1, r1
    3d9c:	bc 5f       	subi	r27, 0xFC	; 252
    3d9e:	11 96       	adiw	r26, 0x01	; 1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3da0:	2c 93       	st	X, r18
begin():
    3da2:	a0 91 90 65 	lds	r26, 0x6590	; 0x806590 <display+0x27>
check_valid_digital_pin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:525
    pinMode(csPin, OUTPUT); // Same for chip select
    3da6:	8a 2f       	mov	r24, r26
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    3da8:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    3daa:	ac 31       	cpi	r26, 0x1C	; 28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3dac:	90 f4       	brcc	.+36     	; 0x3dd2 <main+0x886>
    3dae:	9c 01       	movw	r18, r24
    3db0:	2e 5e       	subi	r18, 0xEE	; 238
    3db2:	3d 49       	sbci	r19, 0x9D	; 157
    3db4:	f9 01       	movw	r30, r18
    3db6:	20 81       	ld	r18, Z
    3db8:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    3dba:	59 f0       	breq	.+22     	; 0x3dd2 <main+0x886>
    3dbc:	82 5d       	subi	r24, 0xD2	; 210
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3dbe:	9d 49       	sbci	r25, 0x9D	; 157
    3dc0:	fc 01       	movw	r30, r24
    3dc2:	80 81       	ld	r24, Z
    3dc4:	f0 e2       	ldi	r31, 0x20	; 32
    3dc6:	8f 9f       	mul	r24, r31
    3dc8:	c0 01       	movw	r24, r0
    3dca:	11 24       	eor	r1, r1
    3dcc:	9c 5f       	subi	r25, 0xFC	; 252
    3dce:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3dd0:	21 83       	std	Z+1, r18	; 0x01
begin():
    3dd2:	4c 31       	cpi	r20, 0x1C	; 28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:527
#ifdef HAVE_PORTREG
    dcPort = (PortReg *)portOutputRegister(digitalPinToPort(dcPin));
    3dd4:	08 f0       	brcs	.+2      	; 0x3dd8 <main+0x88c>
    3dd6:	4d c0       	rjmp	.+154    	; 0x3e72 <main+0x926>
    3dd8:	84 2f       	mov	r24, r20
    3dda:	04 2e       	mov	r0, r20
    3ddc:	00 0c       	add	r0, r0
    3dde:	99 0b       	sbc	r25, r25
    3de0:	82 5d       	subi	r24, 0xD2	; 210
    3de2:	9d 49       	sbci	r25, 0x9D	; 157
    3de4:	fc 01       	movw	r30, r24
    3de6:	80 81       	ld	r24, Z
    3de8:	87 30       	cpi	r24, 0x07	; 7
    3dea:	08 f0       	brcs	.+2      	; 0x3dee <main+0x8a2>
    3dec:	42 c0       	rjmp	.+132    	; 0x3e72 <main+0x926>
    3dee:	f0 e2       	ldi	r31, 0x20	; 32
    3df0:	8f 9f       	mul	r24, r31
    3df2:	c0 01       	movw	r24, r0
    3df4:	11 24       	eor	r1, r1
    3df6:	9c 5f       	subi	r25, 0xFC	; 252
    3df8:	04 96       	adiw	r24, 0x04	; 4
    3dfa:	80 93 96 65 	sts	0x6596, r24	; 0x806596 <display+0x2d>
    3dfe:	90 93 97 65 	sts	0x6597, r25	; 0x806597 <display+0x2e>
main():
    3e02:	8f ef       	ldi	r24, 0xFF	; 255
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:528
    dcPinMask = digitalPinToBitMask(dcPin);
    3e04:	4c 31       	cpi	r20, 0x1C	; 28
    3e06:	30 f4       	brcc	.+12     	; 0x3e14 <main+0x8c8>
    3e08:	e4 2f       	mov	r30, r20
    3e0a:	44 0f       	add	r20, r20
    3e0c:	ff 0b       	sbc	r31, r31
    3e0e:	ee 5e       	subi	r30, 0xEE	; 238
    3e10:	fd 49       	sbci	r31, 0x9D	; 157
    3e12:	80 81       	ld	r24, Z
    3e14:	80 93 9c 65 	sts	0x659C, r24	; 0x80659c <display+0x33>
    3e18:	ac 31       	cpi	r26, 0x1C	; 28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:529
    csPort = (PortReg *)portOutputRegister(digitalPinToPort(csPin));
    3e1a:	70 f5       	brcc	.+92     	; 0x3e78 <main+0x92c>
    3e1c:	ea 2f       	mov	r30, r26
    3e1e:	0a 2e       	mov	r0, r26
    3e20:	00 0c       	add	r0, r0
    3e22:	ff 0b       	sbc	r31, r31
    3e24:	e2 5d       	subi	r30, 0xD2	; 210
    3e26:	fd 49       	sbci	r31, 0x9D	; 157
    3e28:	e0 81       	ld	r30, Z
    3e2a:	e7 30       	cpi	r30, 0x07	; 7
    3e2c:	28 f5       	brcc	.+74     	; 0x3e78 <main+0x92c>
    3e2e:	20 e2       	ldi	r18, 0x20	; 32
    3e30:	e2 9f       	mul	r30, r18
    3e32:	f0 01       	movw	r30, r0
    3e34:	11 24       	eor	r1, r1
    3e36:	fc 5f       	subi	r31, 0xFC	; 252
    3e38:	cf 01       	movw	r24, r30
    3e3a:	04 96       	adiw	r24, 0x04	; 4
    3e3c:	80 93 98 65 	sts	0x6598, r24	; 0x806598 <display+0x2f>
    3e40:	90 93 99 65 	sts	0x6599, r25	; 0x806599 <display+0x30>
main():
    3e44:	8f ef       	ldi	r24, 0xFF	; 255
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:530
    csPinMask = digitalPinToBitMask(csPin);
    3e46:	ac 31       	cpi	r26, 0x1C	; 28
    3e48:	30 f4       	brcc	.+12     	; 0x3e56 <main+0x90a>
    3e4a:	0a 2e       	mov	r0, r26
    3e4c:	00 0c       	add	r0, r0
    3e4e:	bb 0b       	sbc	r27, r27
    3e50:	ae 5e       	subi	r26, 0xEE	; 238
    3e52:	bd 49       	sbci	r27, 0x9D	; 157
    3e54:	8c 91       	ld	r24, X
    3e56:	80 93 9d 65 	sts	0x659D, r24	; 0x80659d <display+0x34>
    3e5a:	94 81       	ldd	r25, Z+4	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:532
#endif
    SSD1306_DESELECT
    3e5c:	89 2b       	or	r24, r25
    3e5e:	84 83       	std	Z+4, r24	; 0x04
    3e60:	80 91 84 65 	lds	r24, 0x6584	; 0x806584 <display+0x1b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:533
    if (spi) { // Hardware SPI
    3e64:	90 91 85 65 	lds	r25, 0x6585	; 0x806585 <display+0x1c>
    3e68:	00 97       	sbiw	r24, 0x00	; 0
    3e6a:	49 f0       	breq	.+18     	; 0x3e7e <main+0x932>
    3e6c:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <SPIClass::begin()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:536
      // SPI peripheral begin same as wire check above.
      if (periphBegin)
        spi->begin();
    3e70:	c4 cd       	rjmp	.-1144   	; 0x39fa <main+0x4ae>
main():
    3e72:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:527
      wire->begin();
  } else { // Using one of the SPI modes, either soft or hardware
    pinMode(dcPin, OUTPUT); // Set data/command pin as output
    pinMode(csPin, OUTPUT); // Same for chip select
#ifdef HAVE_PORTREG
    dcPort = (PortReg *)portOutputRegister(digitalPinToPort(dcPin));
    3e74:	80 e0       	ldi	r24, 0x00	; 0
    3e76:	c0 cf       	rjmp	.-128    	; 0x3df8 <main+0x8ac>
    3e78:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:529
    dcPinMask = digitalPinToBitMask(dcPin);
    csPort = (PortReg *)portOutputRegister(digitalPinToPort(csPin));
    3e7a:	e0 e0       	ldi	r30, 0x00	; 0
    3e7c:	dd cf       	rjmp	.-70     	; 0x3e38 <main+0x8ec>
begin():
    3e7e:	40 91 8d 65 	lds	r20, 0x658D	; 0x80658d <display+0x24>
check_valid_digital_pin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:538
    if (spi) { // Hardware SPI
      // SPI peripheral begin same as wire check above.
      if (periphBegin)
        spi->begin();
    } else {                    // Soft SPI
      pinMode(mosiPin, OUTPUT); // MOSI and SCLK outputs
    3e82:	84 2f       	mov	r24, r20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    3e84:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    3e86:	4c 31       	cpi	r20, 0x1C	; 28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3e88:	88 f4       	brcc	.+34     	; 0x3eac <main+0x960>
    3e8a:	dc 01       	movw	r26, r24
    3e8c:	ae 5e       	subi	r26, 0xEE	; 238
    3e8e:	bd 49       	sbci	r27, 0x9D	; 157
    3e90:	2c 91       	ld	r18, X
    3e92:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    3e94:	59 f0       	breq	.+22     	; 0x3eac <main+0x960>
    3e96:	82 5d       	subi	r24, 0xD2	; 210
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3e98:	9d 49       	sbci	r25, 0x9D	; 157
    3e9a:	dc 01       	movw	r26, r24
    3e9c:	9c 91       	ld	r25, X
    3e9e:	e0 e2       	ldi	r30, 0x20	; 32
    3ea0:	9e 9f       	mul	r25, r30
    3ea2:	d0 01       	movw	r26, r0
    3ea4:	11 24       	eor	r1, r1
    3ea6:	bc 5f       	subi	r27, 0xFC	; 252
    3ea8:	11 96       	adiw	r26, 0x01	; 1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3eaa:	2c 93       	st	X, r18
begin():
    3eac:	a0 91 8e 65 	lds	r26, 0x658E	; 0x80658e <display+0x25>
check_valid_digital_pin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:539
      pinMode(clkPin, OUTPUT);
    3eb0:	8a 2f       	mov	r24, r26
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    3eb2:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    3eb4:	ac 31       	cpi	r26, 0x1C	; 28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    3eb6:	90 f4       	brcc	.+36     	; 0x3edc <main+0x990>
    3eb8:	9c 01       	movw	r18, r24
    3eba:	2e 5e       	subi	r18, 0xEE	; 238
    3ebc:	3d 49       	sbci	r19, 0x9D	; 157
    3ebe:	f9 01       	movw	r30, r18
    3ec0:	20 81       	ld	r18, Z
    3ec2:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    3ec4:	59 f0       	breq	.+22     	; 0x3edc <main+0x990>
    3ec6:	82 5d       	subi	r24, 0xD2	; 210
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    3ec8:	9d 49       	sbci	r25, 0x9D	; 157
    3eca:	fc 01       	movw	r30, r24
    3ecc:	80 81       	ld	r24, Z
    3ece:	f0 e2       	ldi	r31, 0x20	; 32
    3ed0:	8f 9f       	mul	r24, r31
    3ed2:	c0 01       	movw	r24, r0
    3ed4:	11 24       	eor	r1, r1
    3ed6:	9c 5f       	subi	r25, 0xFC	; 252
    3ed8:	fc 01       	movw	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3eda:	21 83       	std	Z+1, r18	; 0x01
begin():
    3edc:	4c 31       	cpi	r20, 0x1C	; 28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:541
#ifdef HAVE_PORTREG
      mosiPort = (PortReg *)portOutputRegister(digitalPinToPort(mosiPin));
    3ede:	08 f0       	brcs	.+2      	; 0x3ee2 <main+0x996>
    3ee0:	45 c0       	rjmp	.+138    	; 0x3f6c <main+0xa20>
    3ee2:	84 2f       	mov	r24, r20
    3ee4:	04 2e       	mov	r0, r20
    3ee6:	00 0c       	add	r0, r0
    3ee8:	99 0b       	sbc	r25, r25
    3eea:	82 5d       	subi	r24, 0xD2	; 210
    3eec:	9d 49       	sbci	r25, 0x9D	; 157
    3eee:	fc 01       	movw	r30, r24
    3ef0:	80 81       	ld	r24, Z
    3ef2:	87 30       	cpi	r24, 0x07	; 7
    3ef4:	d8 f5       	brcc	.+118    	; 0x3f6c <main+0xa20>
    3ef6:	f0 e2       	ldi	r31, 0x20	; 32
    3ef8:	8f 9f       	mul	r24, r31
    3efa:	c0 01       	movw	r24, r0
    3efc:	11 24       	eor	r1, r1
    3efe:	9c 5f       	subi	r25, 0xFC	; 252
    3f00:	04 96       	adiw	r24, 0x04	; 4
    3f02:	80 93 92 65 	sts	0x6592, r24	; 0x806592 <display+0x29>
    3f06:	90 93 93 65 	sts	0x6593, r25	; 0x806593 <display+0x2a>
main():
    3f0a:	8f ef       	ldi	r24, 0xFF	; 255
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:542
      mosiPinMask = digitalPinToBitMask(mosiPin);
    3f0c:	4c 31       	cpi	r20, 0x1C	; 28
    3f0e:	30 f4       	brcc	.+12     	; 0x3f1c <main+0x9d0>
    3f10:	e4 2f       	mov	r30, r20
    3f12:	44 0f       	add	r20, r20
    3f14:	ff 0b       	sbc	r31, r31
    3f16:	ee 5e       	subi	r30, 0xEE	; 238
    3f18:	fd 49       	sbci	r31, 0x9D	; 157
    3f1a:	80 81       	ld	r24, Z
    3f1c:	80 93 9a 65 	sts	0x659A, r24	; 0x80659a <display+0x31>
    3f20:	ac 31       	cpi	r26, 0x1C	; 28
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:543
      clkPort = (PortReg *)portOutputRegister(digitalPinToPort(clkPin));
    3f22:	38 f5       	brcc	.+78     	; 0x3f72 <main+0xa26>
    3f24:	ea 2f       	mov	r30, r26
    3f26:	0a 2e       	mov	r0, r26
    3f28:	00 0c       	add	r0, r0
    3f2a:	ff 0b       	sbc	r31, r31
    3f2c:	e2 5d       	subi	r30, 0xD2	; 210
    3f2e:	fd 49       	sbci	r31, 0x9D	; 157
    3f30:	e0 81       	ld	r30, Z
    3f32:	e7 30       	cpi	r30, 0x07	; 7
    3f34:	f0 f4       	brcc	.+60     	; 0x3f72 <main+0xa26>
    3f36:	20 e2       	ldi	r18, 0x20	; 32
    3f38:	e2 9f       	mul	r30, r18
    3f3a:	f0 01       	movw	r30, r0
    3f3c:	11 24       	eor	r1, r1
    3f3e:	fc 5f       	subi	r31, 0xFC	; 252
    3f40:	cf 01       	movw	r24, r30
    3f42:	04 96       	adiw	r24, 0x04	; 4
    3f44:	80 93 94 65 	sts	0x6594, r24	; 0x806594 <display+0x2b>
    3f48:	90 93 95 65 	sts	0x6595, r25	; 0x806595 <display+0x2c>
main():
    3f4c:	8f ef       	ldi	r24, 0xFF	; 255
begin():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:544
      clkPinMask = digitalPinToBitMask(clkPin);
    3f4e:	ac 31       	cpi	r26, 0x1C	; 28
    3f50:	30 f4       	brcc	.+12     	; 0x3f5e <main+0xa12>
    3f52:	0a 2e       	mov	r0, r26
    3f54:	00 0c       	add	r0, r0
    3f56:	bb 0b       	sbc	r27, r27
    3f58:	ae 5e       	subi	r26, 0xEE	; 238
    3f5a:	bd 49       	sbci	r27, 0x9D	; 157
    3f5c:	8c 91       	ld	r24, X
    3f5e:	80 93 9b 65 	sts	0x659B, r24	; 0x80659b <display+0x32>
    3f62:	94 81       	ldd	r25, Z+4	; 0x04
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:545
      *clkPort &= ~clkPinMask; // Clock low
    3f64:	80 95       	com	r24
    3f66:	89 23       	and	r24, r25
    3f68:	84 83       	std	Z+4, r24	; 0x04
    3f6a:	47 cd       	rjmp	.-1394   	; 0x39fa <main+0x4ae>
main():
    3f6c:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:541
        spi->begin();
    } else {                    // Soft SPI
      pinMode(mosiPin, OUTPUT); // MOSI and SCLK outputs
      pinMode(clkPin, OUTPUT);
#ifdef HAVE_PORTREG
      mosiPort = (PortReg *)portOutputRegister(digitalPinToPort(mosiPin));
    3f6e:	80 e0       	ldi	r24, 0x00	; 0
    3f70:	c7 cf       	rjmp	.-114    	; 0x3f00 <main+0x9b4>
    3f72:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:543
      mosiPinMask = digitalPinToBitMask(mosiPin);
      clkPort = (PortReg *)portOutputRegister(digitalPinToPort(clkPin));
    3f74:	e0 e0       	ldi	r30, 0x00	; 0
    3f76:	e4 cf       	rjmp	.-56     	; 0x3f40 <main+0x9f4>
begin():
    3f78:	80 91 84 65 	lds	r24, 0x6584	; 0x806584 <display+0x1b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:562
    digitalWrite(rstPin, LOW);  // Bring reset low
    delay(10);                  // Wait 10 ms
    digitalWrite(rstPin, HIGH); // Bring out of reset
  }

  TRANSACTION_START
    3f7c:	90 91 85 65 	lds	r25, 0x6585	; 0x806585 <display+0x1c>
    3f80:	00 97       	sbiw	r24, 0x00	; 0
    3f82:	31 f0       	breq	.+12     	; 0x3f90 <main+0xa44>
    3f84:	60 91 a7 65 	lds	r22, 0x65A7	; 0x8065a7 <display+0x3e>
    3f88:	70 91 a8 65 	lds	r23, 0x65A8	; 0x8065a8 <display+0x3f>
    3f8c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <SPIClass::beginTransaction(SPISettings)>
    3f90:	e0 91 98 65 	lds	r30, 0x6598	; 0x806598 <display+0x2f>
    3f94:	f0 91 99 65 	lds	r31, 0x6599	; 0x806599 <display+0x30>
    3f98:	90 81       	ld	r25, Z
    3f9a:	80 91 9d 65 	lds	r24, 0x659D	; 0x80659d <display+0x34>
    3f9e:	80 95       	com	r24
    3fa0:	89 23       	and	r24, r25
    3fa2:	80 83       	st	Z, r24
    3fa4:	6f cd       	rjmp	.-1314   	; 0x3a84 <main+0x538>
main():
    3fa6:	8f ec       	ldi	r24, 0xCF	; 207
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:594
  if ((WIDTH == 128) && (HEIGHT == 32)) {
    comPins = 0x02;
    contrast = 0x8F;
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
    comPins = 0x12;
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF;
    3fa8:	a4 cd       	rjmp	.-1208   	; 0x3af2 <main+0x5a6>
begin():
    3faa:	80 36       	cpi	r24, 0x60	; 96
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:595
  } else if ((WIDTH == 96) && (HEIGHT == 16)) {
    3fac:	91 05       	cpc	r25, r1
    3fae:	69 f4       	brne	.+26     	; 0x3fca <main+0xa7e>
    3fb0:	80 91 6f 65 	lds	r24, 0x656F	; 0x80656f <display+0x6>
    3fb4:	90 91 70 65 	lds	r25, 0x6570	; 0x806570 <display+0x7>
    3fb8:	40 97       	sbiw	r24, 0x10	; 16
    3fba:	39 f4       	brne	.+14     	; 0x3fca <main+0xa7e>
    3fbc:	80 91 8b 65 	lds	r24, 0x658B	; 0x80658b <display+0x22>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:597
    comPins = 0x2; // ada x12
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0xAF;
    3fc0:	81 30       	cpi	r24, 0x01	; 1
    3fc2:	29 f4       	brne	.+10     	; 0x3fce <main+0xa82>
main():
    3fc4:	80 e1       	ldi	r24, 0x10	; 16
begin():
    3fc6:	80 93 a6 65 	sts	0x65A6, r24	; 0x8065a6 <display+0x3d>
main():
    3fca:	12 e0       	ldi	r17, 0x02	; 2
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:590

  uint8_t comPins = 0x02;
  contrast = 0x8F;

  if ((WIDTH == 128) && (HEIGHT == 32)) {
    comPins = 0x02;
    3fcc:	95 cd       	rjmp	.-1238   	; 0x3af8 <main+0x5ac>
    3fce:	8f ea       	ldi	r24, 0xAF	; 175
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:597
  } else if ((WIDTH == 128) && (HEIGHT == 64)) {
    comPins = 0x12;
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF;
  } else if ((WIDTH == 96) && (HEIGHT == 16)) {
    comPins = 0x2; // ada x12
    contrast = (vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0xAF;
    3fd0:	fa cf       	rjmp	.-12     	; 0x3fc6 <main+0xa7a>
begin():
    3fd2:	e0 91 98 65 	lds	r30, 0x6598	; 0x806598 <display+0x2f>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:618
      SSD1306_NORMALDISPLAY,       // 0xA6
      SSD1306_DEACTIVATE_SCROLL,
      SSD1306_DISPLAYON}; // Main screen turn on
  ssd1306_commandList(init5, sizeof(init5));

  TRANSACTION_END
    3fd6:	f0 91 99 65 	lds	r31, 0x6599	; 0x806599 <display+0x30>
    3fda:	80 81       	ld	r24, Z
    3fdc:	90 91 9d 65 	lds	r25, 0x659D	; 0x80659d <display+0x34>
    3fe0:	89 2b       	or	r24, r25
    3fe2:	80 83       	st	Z, r24
    3fe4:	80 91 84 65 	lds	r24, 0x6584	; 0x806584 <display+0x1b>
    3fe8:	90 91 85 65 	lds	r25, 0x6585	; 0x806585 <display+0x1c>
    3fec:	00 97       	sbiw	r24, 0x00	; 0
    3fee:	09 f4       	brne	.+2      	; 0x3ff2 <main+0xaa6>
    3ff0:	b8 cd       	rjmp	.-1168   	; 0x3b62 <main+0x616>
    3ff2:	0e 94 da 12 	call	0x25b4	; 0x25b4 <SPIClass::endTransaction()>
    3ff6:	b5 cd       	rjmp	.-1174   	; 0x3b62 <main+0x616>
sys_blink():
    3ff8:	05 38       	cpi	r16, 0x85	; 133
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:117
          }
    }

  else
    {
        if((led_time_now - led_time_last) > 900UL)
    3ffa:	13 40       	sbci	r17, 0x03	; 3
    3ffc:	21 05       	cpc	r18, r1
    3ffe:	31 05       	cpc	r19, r1
    4000:	08 f4       	brcc	.+2      	; 0x4004 <main+0xab8>
    4002:	e6 cd       	rjmp	.-1076   	; 0x3bd0 <main+0x684>
    4004:	60 93 0d 63 	sts	0x630D, r22	; 0x80630d <sys_blink()::led_time_last>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:119
          {
              led_time_last = led_time_now;
    4008:	70 93 0e 63 	sts	0x630E, r23	; 0x80630e <sys_blink()::led_time_last+0x1>
    400c:	80 93 0f 63 	sts	0x630F, r24	; 0x80630f <sys_blink()::led_time_last+0x2>
    4010:	90 93 10 63 	sts	0x6310, r25	; 0x806310 <sys_blink()::led_time_last+0x3>
    4014:	d0 92 11 63 	sts	0x6311, r13	; 0x806311 <sys_blink()::led_state>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:120
              led_state = true;
    4018:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:121
              digitalWrite(PIN_PF5,LOW);
    401a:	d7 cd       	rjmp	.-1106   	; 0x3bca <main+0x67e>
cylon():
    401c:	d0 92 77 63 	sts	0x6377, r13	; 0x806377 <cylon()::led_state>
digitalWrite():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:175
              led_state = false;
              mcp_leds.digitalWrite(led_index,HIGH);
          }
        else
          {
            led_state = true;
    4020:	18 30       	cpi	r17, 0x08	; 8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:121
 */
bool Adafruit_MCP23008::digitalWrite(uint8_t p, uint8_t d) {
  uint8_t gpio;

  // only 8 bits!
  if (p > 7)
    4022:	90 f4       	brcc	.+36     	; 0x4048 <main+0xafc>
readGPIO():
    4024:	89 e0       	ldi	r24, 0x09	; 9
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:99
 * @brief Reads the current GPIO input
 * @return Returns the current GPIO input
 */
uint8_t Adafruit_MCP23008::readGPIO(void) {
  // read the current GPIO input
  return read8(MCP23008_GPIO);
    4026:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <Adafruit_MCP23008::read8(unsigned char) [clone .constprop.38]>
digitalWrite():
    402a:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_MCP23008_library/Adafruit_MCP23008.cpp:131

  // set the pin and direction
  if (d == HIGH) {
    gpio |= 1 << p;
  } else {
    gpio &= ~(1 << p);
    402c:	70 e0       	ldi	r23, 0x00	; 0
    402e:	01 c0       	rjmp	.+2      	; 0x4032 <main+0xae6>
    4030:	66 0f       	add	r22, r22
    4032:	1a 95       	dec	r17
    4034:	ea f7       	brpl	.-6      	; 0x4030 <main+0xae4>
    4036:	60 95       	com	r22
    4038:	68 23       	and	r22, r24
    403a:	87 ce       	rjmp	.-754    	; 0x3d4a <main+0x7fe>
cylon():
    403c:	74 e0       	ldi	r23, 0x04	; 4
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:186
           if(led_dir)
            {
              led_index++;
              if(led_index > 4)
                {
                  led_index = 4;
    403e:	97 2e       	mov	r9, r23
    4040:	90 92 76 63 	sts	0x6376, r9	; 0x806376 <cylon()::led_index>
    4044:	10 92 00 60 	sts	0x6000, r1	; 0x806000 <__DATA_REGION_ORIGIN__>
ring_chase():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:187
                  led_dir = false;
    4048:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:297
  static unsigned long ring_timer = 0UL;
  unsigned long now;
  static uint8_t pixel_index = 0,color_index = 0;


   now = millis();
    404c:	00 91 7e 63 	lds	r16, 0x637E	; 0x80637e <ring_chase()::ring_timer>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:298
   if(now - ring_timer > 211UL)       // random prime number around 200ms
    4050:	10 91 7f 63 	lds	r17, 0x637F	; 0x80637f <ring_chase()::ring_timer+0x1>
    4054:	20 91 80 63 	lds	r18, 0x6380	; 0x806380 <ring_chase()::ring_timer+0x2>
    4058:	30 91 81 63 	lds	r19, 0x6381	; 0x806381 <ring_chase()::ring_timer+0x3>
    405c:	4b 01       	movw	r8, r22
    405e:	5c 01       	movw	r10, r24
    4060:	80 1a       	sub	r8, r16
    4062:	91 0a       	sbc	r9, r17
    4064:	a2 0a       	sbc	r10, r18
    4066:	b3 0a       	sbc	r11, r19
    4068:	95 01       	movw	r18, r10
    406a:	84 01       	movw	r16, r8
    406c:	04 3d       	cpi	r16, 0xD4	; 212
    406e:	11 05       	cpc	r17, r1
    4070:	21 05       	cpc	r18, r1
    4072:	31 05       	cpc	r19, r1
    4074:	08 f4       	brcc	.+2      	; 0x4078 <main+0xb2c>
    4076:	77 c0       	rjmp	.+238    	; 0x4166 <main+0xc1a>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:301
   {

      ring_timer = now;
    4078:	60 93 7e 63 	sts	0x637E, r22	; 0x80637e <ring_chase()::ring_timer>
    407c:	70 93 7f 63 	sts	0x637F, r23	; 0x80637f <ring_chase()::ring_timer+0x1>
    4080:	80 93 80 63 	sts	0x6380, r24	; 0x806380 <ring_chase()::ring_timer+0x2>
    4084:	90 93 81 63 	sts	0x6381, r25	; 0x806381 <ring_chase()::ring_timer+0x3>
clear():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1441
uint8_t tinyNeoPixel::getBrightness(void) const {
  return brightness - 1;
}

void tinyNeoPixel::clear() {
  memset(pixels, 0, numBytes);
    4088:	40 91 3d 64 	lds	r20, 0x643D	; 0x80643d <pixel_ring+0x3>
    408c:	50 91 3e 64 	lds	r21, 0x643E	; 0x80643e <pixel_ring+0x4>
    4090:	70 e0       	ldi	r23, 0x00	; 0
    4092:	60 e0       	ldi	r22, 0x00	; 0
    4094:	80 91 43 64 	lds	r24, 0x6443	; 0x806443 <pixel_ring+0x9>
    4098:	90 91 44 64 	lds	r25, 0x6444	; 0x806444 <pixel_ring+0xa>
    409c:	7e d7       	rcall	.+3836   	; 0x4f9a <memset>
show():
    409e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <tinyNeoPixel::show(unsigned int) [clone .constprop.13]>
ring_chase():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:124

// *INDENT-OFF*   astyle don't like assembly
#if (PROGMEM_SIZE > 4096UL)

void tinyNeoPixel::show(void) {
  show(0);
    40a2:	00 91 7d 63 	lds	r16, 0x637D	; 0x80637d <ring_chase()::color_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:304
      pixel_ring.clear();
      pixel_ring.show();    
      pixel_ring.setPixelColor(pixel_index,color_grid[color_index]);
    40a6:	10 91 7c 63 	lds	r17, 0x637C	; 0x80637c <ring_chase()::pixel_index>
    40aa:	21 2f       	mov	r18, r17
    40ac:	30 e0       	ldi	r19, 0x00	; 0
setPixelColor():
    40ae:	80 91 3b 64 	lds	r24, 0x643B	; 0x80643b <pixel_ring+0x1>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1185
  }
}

// Set pixel color from 'packed' 32-bit RGB color:
void tinyNeoPixel::setPixelColor(uint16_t n, uint32_t c) {
  if (n < numLEDs) {
    40b2:	90 91 3c 64 	lds	r25, 0x643C	; 0x80643c <pixel_ring+0x2>
    40b6:	28 17       	cp	r18, r24
    40b8:	39 07       	cpc	r19, r25
    40ba:	08 f0       	brcs	.+2      	; 0x40be <main+0xb72>
    40bc:	46 c0       	rjmp	.+140    	; 0x414a <main+0xbfe>
ring_chase():
    40be:	44 e0       	ldi	r20, 0x04	; 4
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:304
    40c0:	04 9f       	mul	r16, r20
    40c2:	f0 01       	movw	r30, r0
    40c4:	11 24       	eor	r1, r1
    40c6:	e4 5e       	subi	r30, 0xE4	; 228
    40c8:	ff 49       	sbci	r31, 0x9F	; 159
    40ca:	80 81       	ld	r24, Z
    40cc:	91 81       	ldd	r25, Z+1	; 0x01
    40ce:	a2 81       	ldd	r26, Z+2	; 0x02
    40d0:	b3 81       	ldd	r27, Z+3	; 0x03
setPixelColor():
    40d2:	ad 01       	movw	r20, r26
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1187
    uint8_t *p,
      r = (uint8_t)(c >> 16),
    40d4:	66 27       	eor	r22, r22
    40d6:	77 27       	eor	r23, r23
    40d8:	f4 2f       	mov	r31, r20
    40da:	89 2e       	mov	r8, r25
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1188
      g = (uint8_t)(c >>  8),
    40dc:	9a 2e       	mov	r9, r26
    40de:	ab 2e       	mov	r10, r27
    40e0:	bb 24       	eor	r11, r11
    40e2:	8c 86       	std	Y+12, r8	; 0x0c
    40e4:	f8 2e       	mov	r15, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1189
      b = (uint8_t)c;
    40e6:	e0 91 42 64 	lds	r30, 0x6442	; 0x806442 <pixel_ring+0x8>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1190
    if (brightness) { // See notes in setBrightness()
    40ea:	ee 23       	and	r30, r30
    40ec:	61 f0       	breq	.+24     	; 0x4106 <main+0xbba>
    40ee:	4e 9f       	mul	r20, r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1191
      r = (r * brightness) >> 8;
    40f0:	b0 01       	movw	r22, r0
    40f2:	11 24       	eor	r1, r1
    40f4:	f7 2f       	mov	r31, r23
    40f6:	e8 9d       	mul	r30, r8
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1192
      g = (g * brightness) >> 8;
    40f8:	40 01       	movw	r8, r0
    40fa:	11 24       	eor	r1, r1
    40fc:	9c 86       	std	Y+12, r9	; 0x0c
    40fe:	e8 9f       	mul	r30, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1193
      b = (b * brightness) >> 8;
    4100:	a0 01       	movw	r20, r0
    4102:	11 24       	eor	r1, r1
    4104:	f5 2e       	mov	r15, r21
    4106:	60 91 48 64 	lds	r22, 0x6448	; 0x806448 <pixel_ring+0xe>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1195
    }
    if (wOffset == rOffset) {
    410a:	40 91 43 64 	lds	r20, 0x6443	; 0x806443 <pixel_ring+0x9>
    410e:	50 91 44 64 	lds	r21, 0x6444	; 0x806444 <pixel_ring+0xa>
    4112:	e0 90 45 64 	lds	r14, 0x6445	; 0x806445 <pixel_ring+0xb>
    4116:	6e 11       	cpse	r22, r14
    4118:	04 c1       	rjmp	.+520    	; 0x4322 <main+0xdd6>
    411a:	9a 01       	movw	r18, r20
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1196
      p = &pixels[n * 3];
    411c:	1c 9d       	mul	r17, r12
    411e:	20 0d       	add	r18, r0
    4120:	31 1d       	adc	r19, r1
    4122:	11 24       	eor	r1, r1
    4124:	a0 91 45 64 	lds	r26, 0x6445	; 0x806445 <pixel_ring+0xb>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1202
    } else {
      p = &pixels[n * 4];
      uint8_t w = (uint8_t)(c >> 24);
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
    }
    p[rOffset] = r;
    4128:	a2 0f       	add	r26, r18
    412a:	b3 2f       	mov	r27, r19
    412c:	b1 1d       	adc	r27, r1
    412e:	fc 93       	st	X, r31
    4130:	e0 91 46 64 	lds	r30, 0x6446	; 0x806446 <pixel_ring+0xc>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1203
    p[gOffset] = g;
    4134:	e2 0f       	add	r30, r18
    4136:	f3 2f       	mov	r31, r19
    4138:	f1 1d       	adc	r31, r1
    413a:	5c 85       	ldd	r21, Y+12	; 0x0c
    413c:	50 83       	st	Z, r21
    413e:	40 91 47 64 	lds	r20, 0x6447	; 0x806447 <pixel_ring+0xd>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1204
    p[bOffset] = b;
    4142:	24 0f       	add	r18, r20
    4144:	31 1d       	adc	r19, r1
    4146:	d9 01       	movw	r26, r18
    4148:	fc 92       	st	X, r15
show():
    414a:	0e 94 9e 06 	call	0xd3c	; 0xd3c <tinyNeoPixel::show(unsigned int) [clone .constprop.13]>
ring_chase():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:124

// *INDENT-OFF*   astyle don't like assembly
#if (PROGMEM_SIZE > 4096UL)

void tinyNeoPixel::show(void) {
  show(0);
    414e:	1f 5f       	subi	r17, 0xFF	; 255
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:306
      pixel_ring.show();
      pixel_index++;
    4150:	18 30       	cpi	r17, 0x08	; 8
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:307
      if(pixel_index > 7)
    4152:	08 f0       	brcs	.+2      	; 0x4156 <main+0xc0a>
    4154:	01 c1       	rjmp	.+514    	; 0x4358 <main+0xe0c>
    4156:	10 93 7c 63 	sts	0x637C, r17	; 0x80637c <ring_chase()::pixel_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:306
      ring_timer = now;
      pixel_ring.clear();
      pixel_ring.show();    
      pixel_ring.setPixelColor(pixel_index,color_grid[color_index]);
      pixel_ring.show();
      pixel_index++;
    415a:	0f 5f       	subi	r16, 0xFF	; 255
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:309
      if(pixel_index > 7)
             pixel_index = 0;
      color_index++;
    415c:	03 30       	cpi	r16, 0x03	; 3
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:310
      if(color_index > 2)
    415e:	08 f0       	brcs	.+2      	; 0x4162 <main+0xc16>
    4160:	fe c0       	rjmp	.+508    	; 0x435e <main+0xe12>
    4162:	00 93 7d 63 	sts	0x637D, r16	; 0x80637d <ring_chase()::color_index>
meatball_drop():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:309
      pixel_ring.setPixelColor(pixel_index,color_grid[color_index]);
      pixel_ring.show();
      pixel_index++;
      if(pixel_index > 7)
             pixel_index = 0;
      color_index++;
    4166:	80 91 87 63 	lds	r24, 0x6387	; 0x806387 <guard variable for meatball_drop()::x_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:351

void meatball_drop(void)
{
  static unsigned long meatball_timer = 0UL;
  unsigned long now;
  static int8_t x_pos = ((display.width() - MEATBALL_W ) / 2), y_pos = -MEATBALL_H,dx = 0;
    416a:	81 11       	cpse	r24, r1
    416c:	0e c0       	rjmp	.+28     	; 0x418a <main+0xc3e>
    416e:	20 91 71 65 	lds	r18, 0x6571	; 0x806571 <display+0x8>
    4172:	30 91 72 65 	lds	r19, 0x6572	; 0x806572 <display+0x9>
    4176:	c9 01       	movw	r24, r18
    4178:	c4 97       	sbiw	r24, 0x34	; 52
    417a:	97 fd       	sbrc	r25, 7
    417c:	01 96       	adiw	r24, 0x01	; 1
    417e:	95 95       	asr	r25
    4180:	87 95       	ror	r24
    4182:	80 93 86 63 	sts	0x6386, r24	; 0x806386 <meatball_drop()::x_pos>
    4186:	d0 92 87 63 	sts	0x6387, r13	; 0x806387 <guard variable for meatball_drop()::x_pos>
    418a:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:353

  now = millis();
    418e:	00 91 82 63 	lds	r16, 0x6382	; 0x806382 <meatball_drop()::meatball_timer>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:354
  if(now - meatball_timer > 101UL)
    4192:	10 91 83 63 	lds	r17, 0x6383	; 0x806383 <meatball_drop()::meatball_timer+0x1>
    4196:	20 91 84 63 	lds	r18, 0x6384	; 0x806384 <meatball_drop()::meatball_timer+0x2>
    419a:	30 91 85 63 	lds	r19, 0x6385	; 0x806385 <meatball_drop()::meatball_timer+0x3>
    419e:	4b 01       	movw	r8, r22
    41a0:	5c 01       	movw	r10, r24
    41a2:	80 1a       	sub	r8, r16
    41a4:	91 0a       	sbc	r9, r17
    41a6:	a2 0a       	sbc	r10, r18
    41a8:	b3 0a       	sbc	r11, r19
    41aa:	95 01       	movw	r18, r10
    41ac:	84 01       	movw	r16, r8
    41ae:	06 36       	cpi	r16, 0x66	; 102
    41b0:	11 05       	cpc	r17, r1
    41b2:	21 05       	cpc	r18, r1
    41b4:	31 05       	cpc	r19, r1
    41b6:	08 f4       	brcc	.+2      	; 0x41ba <main+0xc6e>
    41b8:	2e c1       	rjmp	.+604    	; 0x4416 <main+0xeca>
    41ba:	60 93 82 63 	sts	0x6382, r22	; 0x806382 <meatball_drop()::meatball_timer>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:356
  {
     meatball_timer = now;
    41be:	70 93 83 63 	sts	0x6383, r23	; 0x806383 <meatball_drop()::meatball_timer+0x1>
    41c2:	80 93 84 63 	sts	0x6384, r24	; 0x806384 <meatball_drop()::meatball_timer+0x2>
    41c6:	90 93 85 63 	sts	0x6385, r25	; 0x806385 <meatball_drop()::meatball_timer+0x3>
    41ca:	0e 94 3a 13 	call	0x2674	; 0x2674 <Adafruit_SSD1306::clearDisplay() [clone .constprop.47]>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:357
     display.clearDisplay();
    41ce:	40 91 01 60 	lds	r20, 0x6001	; 0x806001 <meatball_drop()::y_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:358
     display.drawBitmap(x_pos,y_pos, meatball, MEATBALL_W, MEATBALL_H, 1);
    41d2:	04 2e       	mov	r0, r20
    41d4:	00 0c       	add	r0, r0
    41d6:	55 0b       	sbc	r21, r21
    41d8:	60 91 86 63 	lds	r22, 0x6386	; 0x806386 <meatball_drop()::x_pos>
    41dc:	06 2e       	mov	r0, r22
    41de:	00 0c       	add	r0, r0
    41e0:	77 0b       	sbc	r23, r23
    41e2:	e3 e3       	ldi	r30, 0x33	; 51
    41e4:	ee 2e       	mov	r14, r30
    41e6:	f1 2c       	mov	r15, r1
    41e8:	04 e3       	ldi	r16, 0x34	; 52
    41ea:	10 e0       	ldi	r17, 0x00	; 0
    41ec:	24 e9       	ldi	r18, 0x94	; 148
    41ee:	3a e0       	ldi	r19, 0x0A	; 10
    41f0:	89 e6       	ldi	r24, 0x69	; 105
    41f2:	95 e6       	ldi	r25, 0x65	; 101
    41f4:	0e 94 65 0f 	call	0x1eca	; 0x1eca <Adafruit_GFX::drawBitmap(int, int, unsigned char const*, int, int, unsigned int) [clone .constprop.48]>
display():
    41f8:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:993
    @note   Drawing operations are not visible until this function is
            called. Call after each graphics command, or after a whole set
            of graphics commands, as best needed by one's own application.
*/
void Adafruit_SSD1306::display(void) {
  TRANSACTION_START
    41fc:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    4200:	00 97       	sbiw	r24, 0x00	; 0
    4202:	09 f4       	brne	.+2      	; 0x4206 <main+0xcba>
    4204:	af c0       	rjmp	.+350    	; 0x4364 <main+0xe18>
setClock():
    4206:	40 91 9e 65 	lds	r20, 0x659E	; 0x80659e <display+0x35>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
    420a:	50 91 9f 65 	lds	r21, 0x659F	; 0x80659f <display+0x36>
    420e:	60 91 a0 65 	lds	r22, 0x65A0	; 0x8065a0 <display+0x37>
    4212:	70 91 a1 65 	lds	r23, 0x65A1	; 0x8065a1 <display+0x38>
    4216:	08 96       	adiw	r24, 0x08	; 8
    4218:	0e 94 c7 14 	call	0x298e	; 0x298e <TWI_MasterSetBaud>
display():
    421c:	65 e0       	ldi	r22, 0x05	; 5
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:999
  static const uint8_t PROGMEM dlist1[] = {
      SSD1306_PAGEADDR,
      0,                      // Page start address
      0xFF,                   // Page end (not really, but works here)
      SSD1306_COLUMNADDR, 0}; // Column start address
  ssd1306_commandList(dlist1, sizeof(dlist1));
    421e:	8f e8       	ldi	r24, 0x8F	; 143
    4220:	9a e0       	ldi	r25, 0x0A	; 10
    4222:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <Adafruit_SSD1306::ssd1306_commandList(unsigned char const*, unsigned char) [clone .constprop.49]>
    4226:	60 91 6d 65 	lds	r22, 0x656D	; 0x80656d <display+0x4>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1000
  ssd1306_command1(WIDTH - 1); // Column end address
    422a:	61 50       	subi	r22, 0x01	; 1
    422c:	89 e6       	ldi	r24, 0x69	; 105
    422e:	95 e6       	ldi	r25, 0x65	; 101
    4230:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <Adafruit_SSD1306::ssd1306_command1(unsigned char)>
    4234:	20 91 6f 65 	lds	r18, 0x656F	; 0x80656f <display+0x6>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1011
  // a screen write and one immediately after should cover it.  But if
  // not, if this becomes a problem, yields() might be added in the
  // 32-byte transfer condition below.
  yield();
#endif
  uint16_t count = WIDTH * ((HEIGHT + 7) / 8);
    4238:	30 91 70 65 	lds	r19, 0x6570	; 0x806570 <display+0x7>
    423c:	c9 01       	movw	r24, r18
    423e:	07 96       	adiw	r24, 0x07	; 7
    4240:	97 fd       	sbrc	r25, 7
    4242:	07 96       	adiw	r24, 0x07	; 7
    4244:	53 e0       	ldi	r21, 0x03	; 3
    4246:	95 95       	asr	r25
    4248:	87 95       	ror	r24
    424a:	5a 95       	dec	r21
    424c:	e1 f7       	brne	.-8      	; 0x4246 <main+0xcfa>
    424e:	20 91 6d 65 	lds	r18, 0x656D	; 0x80656d <display+0x4>
    4252:	30 91 6e 65 	lds	r19, 0x656E	; 0x80656e <display+0x5>
    4256:	82 9f       	mul	r24, r18
    4258:	70 01       	movw	r14, r0
    425a:	83 9f       	mul	r24, r19
    425c:	f0 0c       	add	r15, r0
    425e:	92 9f       	mul	r25, r18
    4260:	f0 0c       	add	r15, r0
    4262:	11 24       	eor	r1, r1
    4264:	00 91 88 65 	lds	r16, 0x6588	; 0x806588 <display+0x1f>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1012
  uint8_t *ptr = buffer;
    4268:	10 91 89 65 	lds	r17, 0x6589	; 0x806589 <display+0x20>
    426c:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1013
  if (wire) { // I2C
    4270:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    4274:	e0 0e       	add	r14, r16
    4276:	f1 1e       	adc	r15, r17
    4278:	00 97       	sbiw	r24, 0x00	; 0
    427a:	09 f4       	brne	.+2      	; 0x427e <main+0xd32>
    427c:	12 c1       	rjmp	.+548    	; 0x44a2 <main+0xf56>
_ZN7TwoWire17beginTransmissionEi():
    427e:	60 91 8a 65 	lds	r22, 0x658A	; 0x80658a <display+0x21>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.h:91
    4282:	0e 94 ed 14 	call	0x29da	; 0x29da <TwoWire::beginTransmission(unsigned char)>
display():
    4286:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1015
    wire->beginTransmission(i2caddr);
    WIRE_WRITE((uint8_t)0x40);
    428a:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    428e:	dc 01       	movw	r26, r24
    4290:	ed 91       	ld	r30, X+
    4292:	fc 91       	ld	r31, X
    4294:	01 90       	ld	r0, Z+
    4296:	f0 81       	ld	r31, Z
    4298:	e0 2d       	mov	r30, r0
    429a:	60 e4       	ldi	r22, 0x40	; 64
    429c:	09 95       	icall
main():
    429e:	aa 24       	eor	r10, r10
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1016
    uint16_t bytesOut = 1;
    42a0:	a3 94       	inc	r10
    42a2:	b1 2c       	mov	r11, r1
    42a4:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    42a8:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
display():
    42ac:	e0 16       	cp	r14, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1017
    while (count--) {
    42ae:	f1 06       	cpc	r15, r17
    42b0:	09 f4       	brne	.+2      	; 0x42b4 <main+0xd68>
    42b2:	6f c0       	rjmp	.+222    	; 0x4392 <main+0xe46>
    42b4:	b2 e8       	ldi	r27, 0x82	; 130
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1018
      if (bytesOut >= WIRE_MAX) {
    42b6:	ab 16       	cp	r10, r27
    42b8:	b1 04       	cpc	r11, r1
    42ba:	c8 f0       	brcs	.+50     	; 0x42ee <main+0xda2>
    42bc:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TwoWire::endTransmission()>
_ZN7TwoWire17beginTransmissionEi():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1019
        wire->endTransmission();
    42c0:	60 91 8a 65 	lds	r22, 0x658A	; 0x80658a <display+0x21>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.h:91
    42c4:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
    42c8:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    42cc:	0e 94 ed 14 	call	0x29da	; 0x29da <TwoWire::beginTransmission(unsigned char)>
display():
    42d0:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1021
        wire->beginTransmission(i2caddr);
        WIRE_WRITE((uint8_t)0x40);
    42d4:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    42d8:	dc 01       	movw	r26, r24
    42da:	ed 91       	ld	r30, X+
    42dc:	fc 91       	ld	r31, X
    42de:	01 90       	ld	r0, Z+
    42e0:	f0 81       	ld	r31, Z
    42e2:	e0 2d       	mov	r30, r0
    42e4:	60 e4       	ldi	r22, 0x40	; 64
    42e6:	09 95       	icall
main():
    42e8:	aa 24       	eor	r10, r10
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1022
        bytesOut = 1;
    42ea:	a3 94       	inc	r10
    42ec:	b1 2c       	mov	r11, r1
display():
    42ee:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1024
      }
      WIRE_WRITE(*ptr++);
    42f2:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    42f6:	f8 01       	movw	r30, r16
    42f8:	61 91       	ld	r22, Z+
    42fa:	8f 01       	movw	r16, r30
    42fc:	dc 01       	movw	r26, r24
    42fe:	ed 91       	ld	r30, X+
    4300:	fc 91       	ld	r31, X
    4302:	01 90       	ld	r0, Z+
    4304:	f0 81       	ld	r31, Z
    4306:	e0 2d       	mov	r30, r0
    4308:	09 95       	icall
    430a:	bf ef       	ldi	r27, 0xFF	; 255
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1025
      bytesOut++;
    430c:	ab 1a       	sub	r10, r27
    430e:	bb 0a       	sbc	r11, r27
    4310:	c9 cf       	rjmp	.-110    	; 0x42a4 <main+0xd58>
cylon():
    4312:	81 50       	subi	r24, 0x01	; 1
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:192
                  led_dir = false;
                }
            }
           else
              {
                led_index--;
    4314:	87 ff       	sbrs	r24, 7
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:193
                if(led_index > 127)     // unsigned 8 bit gone negative
    4316:	2b cd       	rjmp	.-1450   	; 0x3d6e <main+0x822>
    4318:	10 92 76 63 	sts	0x6376, r1	; 0x806376 <cylon()::led_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:195
                  {
                    led_index = 0;
    431c:	d0 92 00 60 	sts	0x6000, r13	; 0x806000 <__DATA_REGION_ORIGIN__>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:196
                    led_dir = true;
    4320:	93 ce       	rjmp	.-730    	; 0x4048 <main+0xafc>
setPixelColor():
    4322:	22 0f       	add	r18, r18
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1198
      b = (b * brightness) >> 8;
    }
    if (wOffset == rOffset) {
      p = &pixels[n * 3];
    } else {
      p = &pixels[n * 4];
    4324:	33 1f       	adc	r19, r19
    4326:	22 0f       	add	r18, r18
    4328:	33 1f       	adc	r19, r19
    432a:	24 0f       	add	r18, r20
    432c:	35 1f       	adc	r19, r21
    432e:	8b 2f       	mov	r24, r27
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1199
      uint8_t w = (uint8_t)(c >> 24);
    4330:	99 27       	eor	r25, r25
    4332:	aa 27       	eor	r26, r26
    4334:	bb 27       	eor	r27, r27
    4336:	ee 23       	and	r30, r30
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:1200
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
    4338:	51 f0       	breq	.+20     	; 0x434e <main+0xe02>
    433a:	ae 2e       	mov	r10, r30
    433c:	b1 2c       	mov	r11, r1
    433e:	a8 9e       	mul	r10, r24
    4340:	a0 01       	movw	r20, r0
    4342:	a9 9e       	mul	r10, r25
    4344:	50 0d       	add	r21, r0
    4346:	b8 9e       	mul	r11, r24
    4348:	50 0d       	add	r21, r0
    434a:	11 24       	eor	r1, r1
    434c:	85 2f       	mov	r24, r21
    434e:	d9 01       	movw	r26, r18
    4350:	a6 0f       	add	r26, r22
    4352:	b1 1d       	adc	r27, r1
    4354:	8c 93       	st	X, r24
    4356:	e6 ce       	rjmp	.-564    	; 0x4124 <main+0xbd8>
ring_chase():
    4358:	10 92 7c 63 	sts	0x637C, r1	; 0x80637c <ring_chase()::pixel_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:308
      pixel_ring.show();    
      pixel_ring.setPixelColor(pixel_index,color_grid[color_index]);
      pixel_ring.show();
      pixel_index++;
      if(pixel_index > 7)
             pixel_index = 0;
    435c:	fe ce       	rjmp	.-516    	; 0x415a <main+0xc0e>
    435e:	10 92 7d 63 	sts	0x637D, r1	; 0x80637d <ring_chase()::color_index>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:311
      color_index++;
      if(color_index > 2)
        color_index = 0;
    4362:	01 cf       	rjmp	.-510    	; 0x4166 <main+0xc1a>
display():
    4364:	80 91 84 65 	lds	r24, 0x6584	; 0x806584 <display+0x1b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:993
    @note   Drawing operations are not visible until this function is
            called. Call after each graphics command, or after a whole set
            of graphics commands, as best needed by one's own application.
*/
void Adafruit_SSD1306::display(void) {
  TRANSACTION_START
    4368:	90 91 85 65 	lds	r25, 0x6585	; 0x806585 <display+0x1c>
    436c:	00 97       	sbiw	r24, 0x00	; 0
    436e:	31 f0       	breq	.+12     	; 0x437c <main+0xe30>
    4370:	60 91 a7 65 	lds	r22, 0x65A7	; 0x8065a7 <display+0x3e>
    4374:	70 91 a8 65 	lds	r23, 0x65A8	; 0x8065a8 <display+0x3f>
    4378:	0e 94 e5 12 	call	0x25ca	; 0x25ca <SPIClass::beginTransaction(SPISettings)>
    437c:	e0 91 98 65 	lds	r30, 0x6598	; 0x806598 <display+0x2f>
    4380:	f0 91 99 65 	lds	r31, 0x6599	; 0x806599 <display+0x30>
    4384:	90 81       	ld	r25, Z
    4386:	80 91 9d 65 	lds	r24, 0x659D	; 0x80659d <display+0x34>
    438a:	80 95       	com	r24
    438c:	89 23       	and	r24, r25
    438e:	80 83       	st	Z, r24
    4390:	45 cf       	rjmp	.-374    	; 0x421c <main+0xcd0>
    4392:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TwoWire::endTransmission()>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1027
        bytesOut = 1;
      }
      WIRE_WRITE(*ptr++);
      bytesOut++;
    }
    wire->endTransmission();
    4396:	80 91 86 65 	lds	r24, 0x6586	; 0x806586 <display+0x1d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1033
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
  }
  TRANSACTION_END
    439a:	90 91 87 65 	lds	r25, 0x6587	; 0x806587 <display+0x1e>
    439e:	00 97       	sbiw	r24, 0x00	; 0
    43a0:	09 f4       	brne	.+2      	; 0x43a4 <main+0xe58>
    43a2:	c3 c0       	rjmp	.+390    	; 0x452a <main+0xfde>
setClock():
    43a4:	40 91 a2 65 	lds	r20, 0x65A2	; 0x8065a2 <display+0x39>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\Wire\src/Wire.cpp:293
    43a8:	50 91 a3 65 	lds	r21, 0x65A3	; 0x8065a3 <display+0x3a>
    43ac:	60 91 a4 65 	lds	r22, 0x65A4	; 0x8065a4 <display+0x3b>
    43b0:	70 91 a5 65 	lds	r23, 0x65A5	; 0x8065a5 <display+0x3c>
    43b4:	08 96       	adiw	r24, 0x08	; 8
    43b6:	0e 94 c7 14 	call	0x298e	; 0x298e <TWI_MasterSetBaud>
meatball_drop():
    43ba:	80 91 01 60 	lds	r24, 0x6001	; 0x806001 <meatball_drop()::y_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:361
     meatball_timer = now;
     display.clearDisplay();
     display.drawBitmap(x_pos,y_pos, meatball, MEATBALL_W, MEATBALL_H, 1);
     display.display();

     y_pos += 2;
    43be:	8e 5f       	subi	r24, 0xFE	; 254
    43c0:	80 93 01 60 	sts	0x6001, r24	; 0x806001 <meatball_drop()::y_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:362
       if(y_pos >= display.height())
    43c4:	08 2e       	mov	r0, r24
    43c6:	00 0c       	add	r0, r0
    43c8:	99 0b       	sbc	r25, r25
    43ca:	20 91 73 65 	lds	r18, 0x6573	; 0x806573 <display+0xa>
    43ce:	30 91 74 65 	lds	r19, 0x6574	; 0x806574 <display+0xb>
    43d2:	82 17       	cp	r24, r18
    43d4:	93 07       	cpc	r25, r19
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:364
          {
            y_pos = -MEATBALL_H;
    43d6:	fc f0       	brlt	.+62     	; 0x4416 <main+0xeca>
    43d8:	8d ec       	ldi	r24, 0xCD	; 205
    43da:	80 93 01 60 	sts	0x6001, r24	; 0x806001 <meatball_drop()::y_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:365
            x_pos = ((display.width() - MEATBALL_W ) / 2);
    43de:	20 91 71 65 	lds	r18, 0x6571	; 0x806571 <display+0x8>
    43e2:	30 91 72 65 	lds	r19, 0x6572	; 0x806572 <display+0x9>
    43e6:	c9 01       	movw	r24, r18
    43e8:	c4 97       	sbiw	r24, 0x34	; 52
    43ea:	97 fd       	sbrc	r25, 7
    43ec:	01 96       	adiw	r24, 0x01	; 1
    43ee:	95 95       	asr	r25
    43f0:	87 95       	ror	r24
    43f2:	80 93 86 63 	sts	0x6386, r24	; 0x806386 <meatball_drop()::x_pos>
random():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/WMath.cpp:38
    43f6:	3c d1       	rcall	.+632    	; 0x4670 <random>
    43f8:	a3 01       	movw	r20, r6
    43fa:	92 01       	movw	r18, r4
    43fc:	fd d3       	rcall	.+2042   	; 0x4bf8 <__divmodsi4>
meatball_drop():
    43fe:	65 30       	cpi	r22, 0x05	; 5
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:366
            dx = (random(1,10) > 5 ? -15 : 15);
    4400:	71 05       	cpc	r23, r1
    4402:	81 05       	cpc	r24, r1
    4404:	91 05       	cpc	r25, r1
    4406:	0c f4       	brge	.+2      	; 0x440a <main+0xebe>
    4408:	a3 c0       	rjmp	.+326    	; 0x4550 <main+0x1004>
main():
    440a:	91 ef       	ldi	r25, 0xF1	; 241
meatball_drop():
    440c:	80 91 86 63 	lds	r24, 0x6386	; 0x806386 <meatball_drop()::x_pos>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:367
            x_pos += dx;
    4410:	89 0f       	add	r24, r25
    4412:	80 93 86 63 	sts	0x6386, r24	; 0x806386 <meatball_drop()::x_pos>
dac_test():
    4416:	0e 94 46 07 	call	0xe8c	; 0xe8c <millis>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:261
    static unsigned long last_beep_time = 0UL,now;
    
    int array_index, sample;  
    uint8_t high_byte,low_byte;

    now = millis();
    441a:	00 91 8f 63 	lds	r16, 0x638F	; 0x80638f <dac_test()::last_beep_time>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:262
    if((now - last_beep_time) > 2000)    // beep every three seconds
    441e:	10 91 90 63 	lds	r17, 0x6390	; 0x806390 <dac_test()::last_beep_time+0x1>
    4422:	20 91 91 63 	lds	r18, 0x6391	; 0x806391 <dac_test()::last_beep_time+0x2>
    4426:	30 91 92 63 	lds	r19, 0x6392	; 0x806392 <dac_test()::last_beep_time+0x3>
    442a:	4b 01       	movw	r8, r22
    442c:	5c 01       	movw	r10, r24
    442e:	80 1a       	sub	r8, r16
    4430:	91 0a       	sbc	r9, r17
    4432:	a2 0a       	sbc	r10, r18
    4434:	b3 0a       	sbc	r11, r19
    4436:	95 01       	movw	r18, r10
    4438:	84 01       	movw	r16, r8
    443a:	01 3d       	cpi	r16, 0xD1	; 209
    443c:	17 40       	sbci	r17, 0x07	; 7
    443e:	21 05       	cpc	r18, r1
    4440:	31 05       	cpc	r19, r1
    4442:	08 f4       	brcc	.+2      	; 0x4446 <main+0xefa>
    4444:	9b cb       	rjmp	.-2250   	; 0x3b7c <main+0x630>
    4446:	60 93 8f 63 	sts	0x638F, r22	; 0x80638f <dac_test()::last_beep_time>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:265
    {

        last_beep_time = now;
    444a:	70 93 90 63 	sts	0x6390, r23	; 0x806390 <dac_test()::last_beep_time+0x1>
    444e:	80 93 91 63 	sts	0x6391, r24	; 0x806391 <dac_test()::last_beep_time+0x2>
    4452:	90 93 92 63 	sts	0x6392, r25	; 0x806392 <dac_test()::last_beep_time+0x3>
    4456:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:266
        Serial.println(">> beep");
    4458:	93 e6       	ldi	r25, 0x63	; 99
    445a:	0e 94 08 18 	call	0x3010	; 0x3010 <Print::println(char const*) [clone .constprop.25]>
    445e:	88 e2       	ldi	r24, 0x28	; 40
    4460:	a8 2e       	mov	r10, r24
    4462:	80 e6       	ldi	r24, 0x60	; 96
    4464:	b8 2e       	mov	r11, r24
    4466:	98 eb       	ldi	r25, 0xB8	; 184
    4468:	e9 2e       	mov	r14, r25
    446a:	91 e6       	ldi	r25, 0x61	; 97
    446c:	f9 2e       	mov	r15, r25
    446e:	d5 01       	movw	r26, r10
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:270
        for(array_index = 0;array_index < 199;array_index += 4)       // array step 4 gets about 1.3 kHz saw tooth
          {

            sample = sine_wave[array_index] + 2048;       // add DC offset
    4470:	0d 91       	ld	r16, X+
    4472:	1c 91       	ld	r17, X
    4474:	18 5f       	subi	r17, 0xF8	; 248
    4476:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:275
            high_byte = (uint8_t)(sample >> 8);
            high_byte |= 0x30;                            // set gain X1 bit
            low_byte = (uint8_t)(sample & 0xFF);

            digitalWrite(DAC_CS,LOW);
    4478:	8a e0       	ldi	r24, 0x0A	; 10
    447a:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
    447e:	81 2f       	mov	r24, r17
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:276
            SPI.transfer(high_byte);
    4480:	80 63       	ori	r24, 0x30	; 48
    4482:	0e 94 3d 06 	call	0xc7a	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>
    4486:	80 2f       	mov	r24, r16
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:277
            SPI.transfer(low_byte);
    4488:	0e 94 3d 06 	call	0xc7a	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>
    448c:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:278
            digitalWrite(DAC_CS,HIGH);
    448e:	8a e0       	ldi	r24, 0x0A	; 10
    4490:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <digitalWrite>
    4494:	b8 e0       	ldi	r27, 0x08	; 8
    4496:	ab 0e       	add	r10, r27
    4498:	b1 1c       	adc	r11, r1
    449a:	ea 14       	cp	r14, r10
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:267
    if((now - last_beep_time) > 2000)    // beep every three seconds
    {

        last_beep_time = now;
        Serial.println(">> beep");
        for(array_index = 0;array_index < 199;array_index += 4)       // array step 4 gets about 1.3 kHz saw tooth
    449c:	fb 04       	cpc	r15, r11
    449e:	39 f7       	brne	.-50     	; 0x446e <main+0xf22>
    44a0:	69 cb       	rjmp	.-2350   	; 0x3b74 <main+0x628>
display():
    44a2:	e0 91 96 65 	lds	r30, 0x6596	; 0x806596 <display+0x2d>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1029
      WIRE_WRITE(*ptr++);
      bytesOut++;
    }
    wire->endTransmission();
  } else { // SPI
    SSD1306_MODE_DATA
    44a6:	f0 91 97 65 	lds	r31, 0x6597	; 0x806597 <display+0x2e>
    44aa:	80 81       	ld	r24, Z
    44ac:	90 91 9c 65 	lds	r25, 0x659C	; 0x80659c <display+0x33>
    44b0:	89 2b       	or	r24, r25
    44b2:	80 83       	st	Z, r24
    44b4:	e0 16       	cp	r14, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1030
    while (count--)
    44b6:	f1 06       	cpc	r15, r17
    44b8:	09 f4       	brne	.+2      	; 0x44bc <main+0xf70>
    44ba:	6d cf       	rjmp	.-294    	; 0x4396 <main+0xe4a>
    44bc:	f8 01       	movw	r30, r16
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1031
      SPIwrite(*ptr++);
    44be:	81 91       	ld	r24, Z+
    44c0:	8f 01       	movw	r16, r30
_ZN16Adafruit_SSD13068SPIwriteEh():
    44c2:	20 91 84 65 	lds	r18, 0x6584	; 0x806584 <display+0x1b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    44c6:	30 91 85 65 	lds	r19, 0x6585	; 0x806585 <display+0x1c>
    44ca:	23 2b       	or	r18, r19
    44cc:	19 f0       	breq	.+6      	; 0x44d4 <main+0xf88>
    44ce:	0e 94 3d 06 	call	0xc7a	; 0xc7a <SPIClass::transfer(unsigned char) [clone .constprop.53]>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:361
    (void)spi->transfer(d);
    44d2:	f0 cf       	rjmp	.-32     	; 0x44b4 <main+0xf68>
    44d4:	28 e0       	ldi	r18, 0x08	; 8
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:360
    @return void
    @note   See HAVE_PORTREG which defines if the method uses a port or bit-bang
   method
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    44d6:	30 e0       	ldi	r19, 0x00	; 0
main():
    44d8:	40 e8       	ldi	r20, 0x80	; 128
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    44da:	e0 91 92 65 	lds	r30, 0x6592	; 0x806592 <display+0x29>
    44de:	f0 91 93 65 	lds	r31, 0x6593	; 0x806593 <display+0x2a>
    44e2:	90 91 9a 65 	lds	r25, 0x659A	; 0x80659a <display+0x31>
_ZN16Adafruit_SSD13068SPIwriteEh():
    44e6:	54 2f       	mov	r21, r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:365
#ifdef HAVE_PORTREG
      if (d & bit)
    44e8:	58 23       	and	r21, r24
    44ea:	d9 f0       	breq	.+54     	; 0x4522 <main+0xfd6>
    44ec:	50 81       	ld	r21, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:366
        *mosiPort |= mosiPinMask;
    44ee:	95 2b       	or	r25, r21
    44f0:	90 83       	st	Z, r25
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
      else
        *mosiPort &= ~mosiPinMask;
    44f2:	e0 91 94 65 	lds	r30, 0x6594	; 0x806594 <display+0x2b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:369
      *clkPort |= clkPinMask;  // Clock high
    44f6:	f0 91 95 65 	lds	r31, 0x6595	; 0x806595 <display+0x2c>
    44fa:	90 81       	ld	r25, Z
    44fc:	50 91 9b 65 	lds	r21, 0x659B	; 0x80659b <display+0x32>
    4500:	95 2b       	or	r25, r21
    4502:	90 83       	st	Z, r25
    4504:	e0 91 94 65 	lds	r30, 0x6594	; 0x806594 <display+0x2b>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:370
      *clkPort &= ~clkPinMask; // Clock low
    4508:	f0 91 95 65 	lds	r31, 0x6595	; 0x806595 <display+0x2c>
    450c:	50 81       	ld	r21, Z
    450e:	90 91 9b 65 	lds	r25, 0x659B	; 0x80659b <display+0x32>
    4512:	90 95       	com	r25
    4514:	95 23       	and	r25, r21
    4516:	90 83       	st	Z, r25
    4518:	46 95       	lsr	r20
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:363
*/
inline void Adafruit_SSD1306::SPIwrite(uint8_t d) {
  if (spi) {
    (void)spi->transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
    451a:	21 50       	subi	r18, 0x01	; 1
    451c:	31 09       	sbc	r19, r1
    451e:	e9 f6       	brne	.-70     	; 0x44da <main+0xf8e>
    4520:	c9 cf       	rjmp	.-110    	; 0x44b4 <main+0xf68>
    4522:	50 81       	ld	r21, Z
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:368
#ifdef HAVE_PORTREG
      if (d & bit)
        *mosiPort |= mosiPinMask;
      else
        *mosiPort &= ~mosiPinMask;
    4524:	90 95       	com	r25
    4526:	95 23       	and	r25, r21
    4528:	e3 cf       	rjmp	.-58     	; 0x44f0 <main+0xfa4>
display():
    452a:	e0 91 98 65 	lds	r30, 0x6598	; 0x806598 <display+0x2f>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:1033
  } else { // SPI
    SSD1306_MODE_DATA
    while (count--)
      SPIwrite(*ptr++);
  }
  TRANSACTION_END
    452e:	f0 91 99 65 	lds	r31, 0x6599	; 0x806599 <display+0x30>
    4532:	80 81       	ld	r24, Z
    4534:	90 91 9d 65 	lds	r25, 0x659D	; 0x80659d <display+0x34>
    4538:	89 2b       	or	r24, r25
    453a:	80 83       	st	Z, r24
    453c:	80 91 84 65 	lds	r24, 0x6584	; 0x806584 <display+0x1b>
    4540:	90 91 85 65 	lds	r25, 0x6585	; 0x806585 <display+0x1c>
    4544:	00 97       	sbiw	r24, 0x00	; 0
    4546:	09 f4       	brne	.+2      	; 0x454a <main+0xffe>
    4548:	38 cf       	rjmp	.-400    	; 0x43ba <main+0xe6e>
    454a:	0e 94 da 12 	call	0x25b4	; 0x25b4 <SPIClass::endTransaction()>
    454e:	35 cf       	rjmp	.-406    	; 0x43ba <main+0xe6e>
main():
    4550:	9f e0       	ldi	r25, 0x0F	; 15
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:366
     y_pos += 2;
       if(y_pos >= display.height())
          {
            y_pos = -MEATBALL_H;
            x_pos = ((display.width() - MEATBALL_W ) / 2);
            dx = (random(1,10) > 5 ? -15 : 15);
    4552:	5c cf       	rjmp	.-328    	; 0x440c <main+0xec0>

00004554 <_GLOBAL__sub_D_sine_wave>:
_GLOBAL__sub_D_sine_wave():
    4554:	cf 93       	push	r28
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:371
            x_pos += dx;
          }
  }

}
    4556:	df 93       	push	r29
__base_dtor ():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:70
  begun(false), numLEDs(0), numBytes(0), pin(NOT_A_PIN), brightness(0), pixels(NULL),
  rOffset(1), gOffset(0), bOffset(2), wOffset(1), latchTime(50), endTime(0)  {
}

tinyNeoPixel::~tinyNeoPixel() {
  if (pixels) {
    4558:	80 91 43 64 	lds	r24, 0x6443	; 0x806443 <pixel_ring+0x9>
    455c:	90 91 44 64 	lds	r25, 0x6444	; 0x806444 <pixel_ring+0xa>
    4560:	00 97       	sbiw	r24, 0x00	; 0
    4562:	09 f0       	breq	.+2      	; 0x4566 <_GLOBAL__sub_D_sine_wave+0x12>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:71
    free(pixels);
    4564:	8d d4       	rcall	.+2330   	; 0x4e80 <free>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\libraries\tinyNeoPixel/tinyNeoPixel.cpp:73
  }
  pinMode(pin, INPUT);
    4566:	80 91 41 64 	lds	r24, 0x6441	; 0x806441 <pixel_ring+0x7>
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    456a:	8c 31       	cpi	r24, 0x1C	; 28
    456c:	18 f5       	brcc	.+70     	; 0x45b4 <_GLOBAL__sub_D_sine_wave+0x60>
check_valid_digital_pin():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/Arduino.h:904
    456e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:79
    4570:	fc 01       	movw	r30, r24
    4572:	ee 5e       	subi	r30, 0xEE	; 238
    4574:	fd 49       	sbci	r31, 0x9D	; 157
    4576:	20 81       	ld	r18, Z
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    4578:	2f 3f       	cpi	r18, 0xFF	; 255
    457a:	e1 f0       	breq	.+56     	; 0x45b4 <_GLOBAL__sub_D_sine_wave+0x60>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    457c:	fc 01       	movw	r30, r24
    457e:	e2 5d       	subi	r30, 0xD2	; 210
    4580:	fd 49       	sbci	r31, 0x9D	; 157
    4582:	a0 81       	ld	r26, Z
    4584:	30 e2       	ldi	r19, 0x20	; 32
    4586:	a3 9f       	mul	r26, r19
    4588:	d0 01       	movw	r26, r0
    458a:	11 24       	eor	r1, r1
    458c:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    458e:	8a 50       	subi	r24, 0x0A	; 10
    4590:	9e 49       	sbci	r25, 0x9E	; 158
    4592:	ec 01       	movw	r28, r24
    4594:	e8 81       	ld	r30, Y
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    4596:	e8 30       	cpi	r30, 0x08	; 8
    4598:	e0 f4       	brcc	.+56     	; 0x45d2 <_GLOBAL__sub_D_sine_wave+0x7e>
    459a:	cd 01       	movw	r24, r26
    459c:	40 96       	adiw	r24, 0x10	; 16
    459e:	e8 0f       	add	r30, r24
    45a0:	f9 2f       	mov	r31, r25
    45a2:	f1 1d       	adc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
    45a4:	9f b7       	in	r25, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    45a6:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    45a8:	12 96       	adiw	r26, 0x02	; 2
    45aa:	2c 93       	st	X, r18
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:97
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    45ac:	80 81       	ld	r24, Z
    45ae:	87 7f       	andi	r24, 0xF7	; 247
    45b0:	80 83       	st	Z, r24
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:99
    }
    SREG = status;                      /* Restore state */
    45b2:	9f bf       	out	0x3f, r25	; 63
__base_dtor ():
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:338
      rstPin(rst_pin) {}

/*!
    @brief  Destructor for Adafruit_SSD1306 object.
*/
Adafruit_SSD1306::~Adafruit_SSD1306(void) {
    45b4:	8e e4       	ldi	r24, 0x4E	; 78
    45b6:	92 e6       	ldi	r25, 0x62	; 98
    45b8:	80 93 69 65 	sts	0x6569, r24	; 0x806569 <display>
    45bc:	90 93 6a 65 	sts	0x656A, r25	; 0x80656a <display+0x1>
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:339
  if (buffer) {
    45c0:	80 91 88 65 	lds	r24, 0x6588	; 0x806588 <display+0x1f>
    45c4:	90 91 89 65 	lds	r25, 0x6589	; 0x806589 <display+0x20>
    45c8:	00 97       	sbiw	r24, 0x00	; 0
    45ca:	31 f0       	breq	.+12     	; 0x45d8 <_GLOBAL__sub_D_sine_wave+0x84>
_GLOBAL__sub_D_sine_wave():
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:371
    45cc:	df 91       	pop	r29
c:\Users\c40769\Documents\Arduino\libraries\Adafruit_SSD1306/Adafruit_SSD1306.cpp:340
    free(buffer);
    45ce:	cf 91       	pop	r28
__base_dtor ():
    45d0:	57 c4       	rjmp	.+2222   	; 0x4e80 <free>
_GLOBAL__sub_D_sine_wave():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.1\cores\avrcore/wiring_digital.c:90
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    45d2:	f0 e0       	ldi	r31, 0x00	; 0
    45d4:	e0 e0       	ldi	r30, 0x00	; 0
    45d6:	e6 cf       	rjmp	.-52     	; 0x45a4 <_GLOBAL__sub_D_sine_wave+0x50>
C:\Users\c40769\active_projects\AVRCore\AVRCore\testcode\avr_dd_testsuite/avr_dd_testsuite.ino:371
    45d8:	df 91       	pop	r29
    45da:	cf 91       	pop	r28
    45dc:	08 95       	ret

000045de <random_r>:
random_r():
    45de:	8f 92       	push	r8
    45e0:	9f 92       	push	r9
    45e2:	af 92       	push	r10
    45e4:	bf 92       	push	r11
    45e6:	cf 92       	push	r12
    45e8:	df 92       	push	r13
    45ea:	ef 92       	push	r14
    45ec:	ff 92       	push	r15
    45ee:	cf 93       	push	r28
    45f0:	df 93       	push	r29
    45f2:	ec 01       	movw	r28, r24
    45f4:	68 81       	ld	r22, Y
    45f6:	79 81       	ldd	r23, Y+1	; 0x01
    45f8:	8a 81       	ldd	r24, Y+2	; 0x02
    45fa:	9b 81       	ldd	r25, Y+3	; 0x03
    45fc:	61 15       	cp	r22, r1
    45fe:	71 05       	cpc	r23, r1
    4600:	81 05       	cpc	r24, r1
    4602:	91 05       	cpc	r25, r1
    4604:	21 f4       	brne	.+8      	; 0x460e <random_r+0x30>
    4606:	64 e2       	ldi	r22, 0x24	; 36
    4608:	79 ed       	ldi	r23, 0xD9	; 217
    460a:	8b e5       	ldi	r24, 0x5B	; 91
    460c:	97 e0       	ldi	r25, 0x07	; 7
    460e:	2d e1       	ldi	r18, 0x1D	; 29
    4610:	33 ef       	ldi	r19, 0xF3	; 243
    4612:	41 e0       	ldi	r20, 0x01	; 1
    4614:	50 e0       	ldi	r21, 0x00	; 0
    4616:	f0 d2       	rcall	.+1504   	; 0x4bf8 <__divmodsi4>
    4618:	49 01       	movw	r8, r18
    461a:	5a 01       	movw	r10, r20
    461c:	9b 01       	movw	r18, r22
    461e:	ac 01       	movw	r20, r24
    4620:	a7 ea       	ldi	r26, 0xA7	; 167
    4622:	b1 e4       	ldi	r27, 0x41	; 65
    4624:	05 d3       	rcall	.+1546   	; 0x4c30 <__muluhisi3>
    4626:	6b 01       	movw	r12, r22
    4628:	7c 01       	movw	r14, r24
    462a:	ac ee       	ldi	r26, 0xEC	; 236
    462c:	b4 ef       	ldi	r27, 0xF4	; 244
    462e:	a5 01       	movw	r20, r10
    4630:	94 01       	movw	r18, r8
    4632:	0a d3       	rcall	.+1556   	; 0x4c48 <__mulohisi3>
    4634:	c6 0e       	add	r12, r22
    4636:	d7 1e       	adc	r13, r23
    4638:	e8 1e       	adc	r14, r24
    463a:	f9 1e       	adc	r15, r25
    463c:	f7 fe       	sbrs	r15, 7
    463e:	06 c0       	rjmp	.+12     	; 0x464c <random_r+0x6e>
    4640:	81 e0       	ldi	r24, 0x01	; 1
    4642:	c8 1a       	sub	r12, r24
    4644:	d1 08       	sbc	r13, r1
    4646:	e1 08       	sbc	r14, r1
    4648:	80 e8       	ldi	r24, 0x80	; 128
    464a:	f8 0a       	sbc	r15, r24
    464c:	c8 82       	st	Y, r12
    464e:	d9 82       	std	Y+1, r13	; 0x01
    4650:	ea 82       	std	Y+2, r14	; 0x02
    4652:	fb 82       	std	Y+3, r15	; 0x03
    4654:	c7 01       	movw	r24, r14
    4656:	b6 01       	movw	r22, r12
    4658:	9f 77       	andi	r25, 0x7F	; 127
    465a:	df 91       	pop	r29
    465c:	cf 91       	pop	r28
    465e:	ff 90       	pop	r15
    4660:	ef 90       	pop	r14
    4662:	df 90       	pop	r13
    4664:	cf 90       	pop	r12
    4666:	bf 90       	pop	r11
    4668:	af 90       	pop	r10
    466a:	9f 90       	pop	r9
    466c:	8f 90       	pop	r8
    466e:	08 95       	ret

00004670 <random>:
random():
    4670:	8f 92       	push	r8
    4672:	9f 92       	push	r9
    4674:	af 92       	push	r10
    4676:	bf 92       	push	r11
    4678:	cf 92       	push	r12
    467a:	df 92       	push	r13
    467c:	ef 92       	push	r14
    467e:	ff 92       	push	r15
    4680:	60 91 02 60 	lds	r22, 0x6002	; 0x806002 <next>
    4684:	70 91 03 60 	lds	r23, 0x6003	; 0x806003 <next+0x1>
    4688:	80 91 04 60 	lds	r24, 0x6004	; 0x806004 <next+0x2>
    468c:	90 91 05 60 	lds	r25, 0x6005	; 0x806005 <next+0x3>
    4690:	61 15       	cp	r22, r1
    4692:	71 05       	cpc	r23, r1
    4694:	81 05       	cpc	r24, r1
    4696:	91 05       	cpc	r25, r1
    4698:	21 f4       	brne	.+8      	; 0x46a2 <random+0x32>
    469a:	64 e2       	ldi	r22, 0x24	; 36
    469c:	79 ed       	ldi	r23, 0xD9	; 217
    469e:	8b e5       	ldi	r24, 0x5B	; 91
    46a0:	97 e0       	ldi	r25, 0x07	; 7
    46a2:	2d e1       	ldi	r18, 0x1D	; 29
    46a4:	33 ef       	ldi	r19, 0xF3	; 243
    46a6:	41 e0       	ldi	r20, 0x01	; 1
    46a8:	50 e0       	ldi	r21, 0x00	; 0
    46aa:	a6 d2       	rcall	.+1356   	; 0x4bf8 <__divmodsi4>
    46ac:	49 01       	movw	r8, r18
    46ae:	5a 01       	movw	r10, r20
    46b0:	9b 01       	movw	r18, r22
    46b2:	ac 01       	movw	r20, r24
    46b4:	a7 ea       	ldi	r26, 0xA7	; 167
    46b6:	b1 e4       	ldi	r27, 0x41	; 65
    46b8:	bb d2       	rcall	.+1398   	; 0x4c30 <__muluhisi3>
    46ba:	6b 01       	movw	r12, r22
    46bc:	7c 01       	movw	r14, r24
    46be:	ac ee       	ldi	r26, 0xEC	; 236
    46c0:	b4 ef       	ldi	r27, 0xF4	; 244
    46c2:	a5 01       	movw	r20, r10
    46c4:	94 01       	movw	r18, r8
    46c6:	c0 d2       	rcall	.+1408   	; 0x4c48 <__mulohisi3>
    46c8:	c6 0e       	add	r12, r22
    46ca:	d7 1e       	adc	r13, r23
    46cc:	e8 1e       	adc	r14, r24
    46ce:	f9 1e       	adc	r15, r25
    46d0:	f7 fe       	sbrs	r15, 7
    46d2:	06 c0       	rjmp	.+12     	; 0x46e0 <random+0x70>
    46d4:	81 e0       	ldi	r24, 0x01	; 1
    46d6:	c8 1a       	sub	r12, r24
    46d8:	d1 08       	sbc	r13, r1
    46da:	e1 08       	sbc	r14, r1
    46dc:	80 e8       	ldi	r24, 0x80	; 128
    46de:	f8 0a       	sbc	r15, r24
    46e0:	c0 92 02 60 	sts	0x6002, r12	; 0x806002 <next>
    46e4:	d0 92 03 60 	sts	0x6003, r13	; 0x806003 <next+0x1>
    46e8:	e0 92 04 60 	sts	0x6004, r14	; 0x806004 <next+0x2>
    46ec:	f0 92 05 60 	sts	0x6005, r15	; 0x806005 <next+0x3>
    46f0:	c7 01       	movw	r24, r14
    46f2:	b6 01       	movw	r22, r12
    46f4:	9f 77       	andi	r25, 0x7F	; 127
    46f6:	ff 90       	pop	r15
    46f8:	ef 90       	pop	r14
    46fa:	df 90       	pop	r13
    46fc:	cf 90       	pop	r12
    46fe:	bf 90       	pop	r11
    4700:	af 90       	pop	r10
    4702:	9f 90       	pop	r9
    4704:	8f 90       	pop	r8
    4706:	08 95       	ret

00004708 <srandom>:
srandom():
    4708:	60 93 02 60 	sts	0x6002, r22	; 0x806002 <next>
    470c:	70 93 03 60 	sts	0x6003, r23	; 0x806003 <next+0x1>
    4710:	80 93 04 60 	sts	0x6004, r24	; 0x806004 <next+0x2>
    4714:	90 93 05 60 	sts	0x6005, r25	; 0x806005 <next+0x3>
    4718:	08 95       	ret

0000471a <vfprintf>:
vfprintf():
    471a:	ab e0       	ldi	r26, 0x0B	; 11
    471c:	b0 e0       	ldi	r27, 0x00	; 0
    471e:	e2 e9       	ldi	r30, 0x92	; 146
    4720:	f3 e2       	ldi	r31, 0x23	; 35
    4722:	96 c2       	rjmp	.+1324   	; 0x4c50 <__prologue_saves__>
    4724:	7c 01       	movw	r14, r24
    4726:	3b 01       	movw	r6, r22
    4728:	8a 01       	movw	r16, r20
    472a:	fc 01       	movw	r30, r24
    472c:	16 82       	std	Z+6, r1	; 0x06
    472e:	17 82       	std	Z+7, r1	; 0x07
    4730:	83 81       	ldd	r24, Z+3	; 0x03
    4732:	81 ff       	sbrs	r24, 1
    4734:	ba c1       	rjmp	.+884    	; 0x4aaa <vfprintf+0x390>
    4736:	ce 01       	movw	r24, r28
    4738:	01 96       	adiw	r24, 0x01	; 1
    473a:	5c 01       	movw	r10, r24
    473c:	f7 01       	movw	r30, r14
    473e:	93 81       	ldd	r25, Z+3	; 0x03
    4740:	f3 01       	movw	r30, r6
    4742:	93 fd       	sbrc	r25, 3
    4744:	85 91       	lpm	r24, Z+
    4746:	93 ff       	sbrs	r25, 3
    4748:	81 91       	ld	r24, Z+
    474a:	3f 01       	movw	r6, r30
    474c:	88 23       	and	r24, r24
    474e:	09 f4       	brne	.+2      	; 0x4752 <vfprintf+0x38>
    4750:	49 c1       	rjmp	.+658    	; 0x49e4 <vfprintf+0x2ca>
    4752:	85 32       	cpi	r24, 0x25	; 37
    4754:	39 f4       	brne	.+14     	; 0x4764 <vfprintf+0x4a>
    4756:	93 fd       	sbrc	r25, 3
    4758:	85 91       	lpm	r24, Z+
    475a:	93 ff       	sbrs	r25, 3
    475c:	81 91       	ld	r24, Z+
    475e:	3f 01       	movw	r6, r30
    4760:	85 32       	cpi	r24, 0x25	; 37
    4762:	21 f4       	brne	.+8      	; 0x476c <vfprintf+0x52>
    4764:	b7 01       	movw	r22, r14
    4766:	90 e0       	ldi	r25, 0x00	; 0
    4768:	b9 d1       	rcall	.+882    	; 0x4adc <fputc>
    476a:	e8 cf       	rjmp	.-48     	; 0x473c <vfprintf+0x22>
    476c:	91 2c       	mov	r9, r1
    476e:	21 2c       	mov	r2, r1
    4770:	31 2c       	mov	r3, r1
    4772:	ff e1       	ldi	r31, 0x1F	; 31
    4774:	f3 15       	cp	r31, r3
    4776:	38 f0       	brcs	.+14     	; 0x4786 <vfprintf+0x6c>
    4778:	8b 32       	cpi	r24, 0x2B	; 43
    477a:	11 f1       	breq	.+68     	; 0x47c0 <vfprintf+0xa6>
    477c:	90 f4       	brcc	.+36     	; 0x47a2 <vfprintf+0x88>
    477e:	80 32       	cpi	r24, 0x20	; 32
    4780:	09 f1       	breq	.+66     	; 0x47c4 <vfprintf+0xaa>
    4782:	83 32       	cpi	r24, 0x23	; 35
    4784:	29 f1       	breq	.+74     	; 0x47d0 <vfprintf+0xb6>
    4786:	37 fc       	sbrc	r3, 7
    4788:	3c c0       	rjmp	.+120    	; 0x4802 <vfprintf+0xe8>
    478a:	20 ed       	ldi	r18, 0xD0	; 208
    478c:	28 0f       	add	r18, r24
    478e:	2a 30       	cpi	r18, 0x0A	; 10
    4790:	50 f5       	brcc	.+84     	; 0x47e6 <vfprintf+0xcc>
    4792:	36 fe       	sbrs	r3, 6
    4794:	20 c0       	rjmp	.+64     	; 0x47d6 <vfprintf+0xbc>
    4796:	8a e0       	ldi	r24, 0x0A	; 10
    4798:	98 9e       	mul	r9, r24
    479a:	20 0d       	add	r18, r0
    479c:	11 24       	eor	r1, r1
    479e:	92 2e       	mov	r9, r18
    47a0:	06 c0       	rjmp	.+12     	; 0x47ae <vfprintf+0x94>
    47a2:	8d 32       	cpi	r24, 0x2D	; 45
    47a4:	91 f0       	breq	.+36     	; 0x47ca <vfprintf+0xb0>
    47a6:	80 33       	cpi	r24, 0x30	; 48
    47a8:	71 f7       	brne	.-36     	; 0x4786 <vfprintf+0x6c>
    47aa:	68 94       	set
    47ac:	30 f8       	bld	r3, 0
    47ae:	f3 01       	movw	r30, r6
    47b0:	93 fd       	sbrc	r25, 3
    47b2:	85 91       	lpm	r24, Z+
    47b4:	93 ff       	sbrs	r25, 3
    47b6:	81 91       	ld	r24, Z+
    47b8:	3f 01       	movw	r6, r30
    47ba:	81 11       	cpse	r24, r1
    47bc:	da cf       	rjmp	.-76     	; 0x4772 <vfprintf+0x58>
    47be:	21 c0       	rjmp	.+66     	; 0x4802 <vfprintf+0xe8>
    47c0:	68 94       	set
    47c2:	31 f8       	bld	r3, 1
    47c4:	68 94       	set
    47c6:	32 f8       	bld	r3, 2
    47c8:	f2 cf       	rjmp	.-28     	; 0x47ae <vfprintf+0x94>
    47ca:	68 94       	set
    47cc:	33 f8       	bld	r3, 3
    47ce:	ef cf       	rjmp	.-34     	; 0x47ae <vfprintf+0x94>
    47d0:	68 94       	set
    47d2:	34 f8       	bld	r3, 4
    47d4:	ec cf       	rjmp	.-40     	; 0x47ae <vfprintf+0x94>
    47d6:	ea e0       	ldi	r30, 0x0A	; 10
    47d8:	2e 9e       	mul	r2, r30
    47da:	20 0d       	add	r18, r0
    47dc:	11 24       	eor	r1, r1
    47de:	22 2e       	mov	r2, r18
    47e0:	68 94       	set
    47e2:	35 f8       	bld	r3, 5
    47e4:	e4 cf       	rjmp	.-56     	; 0x47ae <vfprintf+0x94>
    47e6:	8e 32       	cpi	r24, 0x2E	; 46
    47e8:	29 f4       	brne	.+10     	; 0x47f4 <vfprintf+0xda>
    47ea:	36 fc       	sbrc	r3, 6
    47ec:	fb c0       	rjmp	.+502    	; 0x49e4 <vfprintf+0x2ca>
    47ee:	68 94       	set
    47f0:	36 f8       	bld	r3, 6
    47f2:	dd cf       	rjmp	.-70     	; 0x47ae <vfprintf+0x94>
    47f4:	8c 36       	cpi	r24, 0x6C	; 108
    47f6:	19 f4       	brne	.+6      	; 0x47fe <vfprintf+0xe4>
    47f8:	68 94       	set
    47fa:	37 f8       	bld	r3, 7
    47fc:	d8 cf       	rjmp	.-80     	; 0x47ae <vfprintf+0x94>
    47fe:	88 36       	cpi	r24, 0x68	; 104
    4800:	b1 f2       	breq	.-84     	; 0x47ae <vfprintf+0x94>
    4802:	98 2f       	mov	r25, r24
    4804:	9f 7d       	andi	r25, 0xDF	; 223
    4806:	95 54       	subi	r25, 0x45	; 69
    4808:	93 30       	cpi	r25, 0x03	; 3
    480a:	d8 f0       	brcs	.+54     	; 0x4842 <vfprintf+0x128>
    480c:	83 36       	cpi	r24, 0x63	; 99
    480e:	91 f1       	breq	.+100    	; 0x4874 <vfprintf+0x15a>
    4810:	83 37       	cpi	r24, 0x73	; 115
    4812:	b1 f1       	breq	.+108    	; 0x4880 <vfprintf+0x166>
    4814:	83 35       	cpi	r24, 0x53	; 83
    4816:	09 f0       	breq	.+2      	; 0x481a <vfprintf+0x100>
    4818:	5e c0       	rjmp	.+188    	; 0x48d6 <vfprintf+0x1bc>
    481a:	28 01       	movw	r4, r16
    481c:	f2 e0       	ldi	r31, 0x02	; 2
    481e:	4f 0e       	add	r4, r31
    4820:	51 1c       	adc	r5, r1
    4822:	f8 01       	movw	r30, r16
    4824:	c0 80       	ld	r12, Z
    4826:	d1 80       	ldd	r13, Z+1	; 0x01
    4828:	69 2d       	mov	r22, r9
    482a:	70 e0       	ldi	r23, 0x00	; 0
    482c:	36 fc       	sbrc	r3, 6
    482e:	02 c0       	rjmp	.+4      	; 0x4834 <vfprintf+0x11a>
    4830:	6f ef       	ldi	r22, 0xFF	; 255
    4832:	7f ef       	ldi	r23, 0xFF	; 255
    4834:	c6 01       	movw	r24, r12
    4836:	3c d1       	rcall	.+632    	; 0x4ab0 <strnlen_P>
    4838:	4c 01       	movw	r8, r24
    483a:	68 94       	set
    483c:	37 f8       	bld	r3, 7
    483e:	82 01       	movw	r16, r4
    4840:	0a c0       	rjmp	.+20     	; 0x4856 <vfprintf+0x13c>
    4842:	0c 5f       	subi	r16, 0xFC	; 252
    4844:	1f 4f       	sbci	r17, 0xFF	; 255
    4846:	ff e3       	ldi	r31, 0x3F	; 63
    4848:	f9 83       	std	Y+1, r31	; 0x01
    484a:	88 24       	eor	r8, r8
    484c:	83 94       	inc	r8
    484e:	91 2c       	mov	r9, r1
    4850:	65 01       	movw	r12, r10
    4852:	e8 94       	clt
    4854:	37 f8       	bld	r3, 7
    4856:	33 fe       	sbrs	r3, 3
    4858:	2a c0       	rjmp	.+84     	; 0x48ae <vfprintf+0x194>
    485a:	52 2c       	mov	r5, r2
    485c:	81 14       	cp	r8, r1
    485e:	91 04       	cpc	r9, r1
    4860:	59 f5       	brne	.+86     	; 0x48b8 <vfprintf+0x19e>
    4862:	55 20       	and	r5, r5
    4864:	09 f4       	brne	.+2      	; 0x4868 <vfprintf+0x14e>
    4866:	6a cf       	rjmp	.-300    	; 0x473c <vfprintf+0x22>
    4868:	b7 01       	movw	r22, r14
    486a:	80 e2       	ldi	r24, 0x20	; 32
    486c:	90 e0       	ldi	r25, 0x00	; 0
    486e:	36 d1       	rcall	.+620    	; 0x4adc <fputc>
    4870:	5a 94       	dec	r5
    4872:	f7 cf       	rjmp	.-18     	; 0x4862 <vfprintf+0x148>
    4874:	f8 01       	movw	r30, r16
    4876:	80 81       	ld	r24, Z
    4878:	89 83       	std	Y+1, r24	; 0x01
    487a:	0e 5f       	subi	r16, 0xFE	; 254
    487c:	1f 4f       	sbci	r17, 0xFF	; 255
    487e:	e5 cf       	rjmp	.-54     	; 0x484a <vfprintf+0x130>
    4880:	28 01       	movw	r4, r16
    4882:	f2 e0       	ldi	r31, 0x02	; 2
    4884:	4f 0e       	add	r4, r31
    4886:	51 1c       	adc	r5, r1
    4888:	f8 01       	movw	r30, r16
    488a:	c0 80       	ld	r12, Z
    488c:	d1 80       	ldd	r13, Z+1	; 0x01
    488e:	69 2d       	mov	r22, r9
    4890:	70 e0       	ldi	r23, 0x00	; 0
    4892:	36 fc       	sbrc	r3, 6
    4894:	02 c0       	rjmp	.+4      	; 0x489a <vfprintf+0x180>
    4896:	6f ef       	ldi	r22, 0xFF	; 255
    4898:	7f ef       	ldi	r23, 0xFF	; 255
    489a:	c6 01       	movw	r24, r12
    489c:	14 d1       	rcall	.+552    	; 0x4ac6 <strnlen>
    489e:	4c 01       	movw	r8, r24
    48a0:	82 01       	movw	r16, r4
    48a2:	d7 cf       	rjmp	.-82     	; 0x4852 <vfprintf+0x138>
    48a4:	b7 01       	movw	r22, r14
    48a6:	80 e2       	ldi	r24, 0x20	; 32
    48a8:	90 e0       	ldi	r25, 0x00	; 0
    48aa:	18 d1       	rcall	.+560    	; 0x4adc <fputc>
    48ac:	2a 94       	dec	r2
    48ae:	28 14       	cp	r2, r8
    48b0:	19 04       	cpc	r1, r9
    48b2:	09 f0       	breq	.+2      	; 0x48b6 <vfprintf+0x19c>
    48b4:	b8 f7       	brcc	.-18     	; 0x48a4 <vfprintf+0x18a>
    48b6:	d1 cf       	rjmp	.-94     	; 0x485a <vfprintf+0x140>
    48b8:	f6 01       	movw	r30, r12
    48ba:	37 fc       	sbrc	r3, 7
    48bc:	85 91       	lpm	r24, Z+
    48be:	37 fe       	sbrs	r3, 7
    48c0:	81 91       	ld	r24, Z+
    48c2:	6f 01       	movw	r12, r30
    48c4:	b7 01       	movw	r22, r14
    48c6:	90 e0       	ldi	r25, 0x00	; 0
    48c8:	09 d1       	rcall	.+530    	; 0x4adc <fputc>
    48ca:	51 10       	cpse	r5, r1
    48cc:	5a 94       	dec	r5
    48ce:	f1 e0       	ldi	r31, 0x01	; 1
    48d0:	8f 1a       	sub	r8, r31
    48d2:	91 08       	sbc	r9, r1
    48d4:	c3 cf       	rjmp	.-122    	; 0x485c <vfprintf+0x142>
    48d6:	84 36       	cpi	r24, 0x64	; 100
    48d8:	19 f0       	breq	.+6      	; 0x48e0 <vfprintf+0x1c6>
    48da:	89 36       	cpi	r24, 0x69	; 105
    48dc:	09 f0       	breq	.+2      	; 0x48e0 <vfprintf+0x1c6>
    48de:	73 c0       	rjmp	.+230    	; 0x49c6 <vfprintf+0x2ac>
    48e0:	f8 01       	movw	r30, r16
    48e2:	37 fe       	sbrs	r3, 7
    48e4:	67 c0       	rjmp	.+206    	; 0x49b4 <vfprintf+0x29a>
    48e6:	60 81       	ld	r22, Z
    48e8:	71 81       	ldd	r23, Z+1	; 0x01
    48ea:	82 81       	ldd	r24, Z+2	; 0x02
    48ec:	93 81       	ldd	r25, Z+3	; 0x03
    48ee:	0c 5f       	subi	r16, 0xFC	; 252
    48f0:	1f 4f       	sbci	r17, 0xFF	; 255
    48f2:	f3 2d       	mov	r31, r3
    48f4:	ff 76       	andi	r31, 0x6F	; 111
    48f6:	3f 2e       	mov	r3, r31
    48f8:	97 ff       	sbrs	r25, 7
    48fa:	09 c0       	rjmp	.+18     	; 0x490e <vfprintf+0x1f4>
    48fc:	90 95       	com	r25
    48fe:	80 95       	com	r24
    4900:	70 95       	com	r23
    4902:	61 95       	neg	r22
    4904:	7f 4f       	sbci	r23, 0xFF	; 255
    4906:	8f 4f       	sbci	r24, 0xFF	; 255
    4908:	9f 4f       	sbci	r25, 0xFF	; 255
    490a:	68 94       	set
    490c:	37 f8       	bld	r3, 7
    490e:	2a e0       	ldi	r18, 0x0A	; 10
    4910:	30 e0       	ldi	r19, 0x00	; 0
    4912:	a5 01       	movw	r20, r10
    4914:	13 d1       	rcall	.+550    	; 0x4b3c <__ultoa_invert>
    4916:	c8 2e       	mov	r12, r24
    4918:	ca 18       	sub	r12, r10
    491a:	8c 2c       	mov	r8, r12
    491c:	43 2c       	mov	r4, r3
    491e:	36 fe       	sbrs	r3, 6
    4920:	0c c0       	rjmp	.+24     	; 0x493a <vfprintf+0x220>
    4922:	e8 94       	clt
    4924:	40 f8       	bld	r4, 0
    4926:	c9 14       	cp	r12, r9
    4928:	40 f4       	brcc	.+16     	; 0x493a <vfprintf+0x220>
    492a:	34 fe       	sbrs	r3, 4
    492c:	05 c0       	rjmp	.+10     	; 0x4938 <vfprintf+0x21e>
    492e:	32 fc       	sbrc	r3, 2
    4930:	03 c0       	rjmp	.+6      	; 0x4938 <vfprintf+0x21e>
    4932:	f3 2d       	mov	r31, r3
    4934:	fe 7e       	andi	r31, 0xEE	; 238
    4936:	4f 2e       	mov	r4, r31
    4938:	89 2c       	mov	r8, r9
    493a:	44 fe       	sbrs	r4, 4
    493c:	90 c0       	rjmp	.+288    	; 0x4a5e <vfprintf+0x344>
    493e:	fe 01       	movw	r30, r28
    4940:	ec 0d       	add	r30, r12
    4942:	f1 1d       	adc	r31, r1
    4944:	80 81       	ld	r24, Z
    4946:	80 33       	cpi	r24, 0x30	; 48
    4948:	09 f0       	breq	.+2      	; 0x494c <vfprintf+0x232>
    494a:	82 c0       	rjmp	.+260    	; 0x4a50 <vfprintf+0x336>
    494c:	24 2d       	mov	r18, r4
    494e:	29 7e       	andi	r18, 0xE9	; 233
    4950:	42 2e       	mov	r4, r18
    4952:	84 2d       	mov	r24, r4
    4954:	88 70       	andi	r24, 0x08	; 8
    4956:	58 2e       	mov	r5, r24
    4958:	43 fc       	sbrc	r4, 3
    495a:	8f c0       	rjmp	.+286    	; 0x4a7a <vfprintf+0x360>
    495c:	40 fe       	sbrs	r4, 0
    495e:	89 c0       	rjmp	.+274    	; 0x4a72 <vfprintf+0x358>
    4960:	9c 2c       	mov	r9, r12
    4962:	82 14       	cp	r8, r2
    4964:	18 f4       	brcc	.+6      	; 0x496c <vfprintf+0x252>
    4966:	2c 0c       	add	r2, r12
    4968:	92 2c       	mov	r9, r2
    496a:	98 18       	sub	r9, r8
    496c:	44 fe       	sbrs	r4, 4
    496e:	8b c0       	rjmp	.+278    	; 0x4a86 <vfprintf+0x36c>
    4970:	b7 01       	movw	r22, r14
    4972:	80 e3       	ldi	r24, 0x30	; 48
    4974:	90 e0       	ldi	r25, 0x00	; 0
    4976:	b2 d0       	rcall	.+356    	; 0x4adc <fputc>
    4978:	42 fe       	sbrs	r4, 2
    497a:	08 c0       	rjmp	.+16     	; 0x498c <vfprintf+0x272>
    497c:	88 e7       	ldi	r24, 0x78	; 120
    497e:	90 e0       	ldi	r25, 0x00	; 0
    4980:	41 fe       	sbrs	r4, 1
    4982:	02 c0       	rjmp	.+4      	; 0x4988 <vfprintf+0x26e>
    4984:	88 e5       	ldi	r24, 0x58	; 88
    4986:	90 e0       	ldi	r25, 0x00	; 0
    4988:	b7 01       	movw	r22, r14
    498a:	a8 d0       	rcall	.+336    	; 0x4adc <fputc>
    498c:	c9 14       	cp	r12, r9
    498e:	08 f4       	brcc	.+2      	; 0x4992 <vfprintf+0x278>
    4990:	86 c0       	rjmp	.+268    	; 0x4a9e <vfprintf+0x384>
    4992:	ca 94       	dec	r12
    4994:	d1 2c       	mov	r13, r1
    4996:	9f ef       	ldi	r25, 0xFF	; 255
    4998:	c9 1a       	sub	r12, r25
    499a:	d9 0a       	sbc	r13, r25
    499c:	ca 0c       	add	r12, r10
    499e:	db 1c       	adc	r13, r11
    49a0:	f6 01       	movw	r30, r12
    49a2:	82 91       	ld	r24, -Z
    49a4:	6f 01       	movw	r12, r30
    49a6:	b7 01       	movw	r22, r14
    49a8:	90 e0       	ldi	r25, 0x00	; 0
    49aa:	98 d0       	rcall	.+304    	; 0x4adc <fputc>
    49ac:	ac 14       	cp	r10, r12
    49ae:	bd 04       	cpc	r11, r13
    49b0:	b9 f7       	brne	.-18     	; 0x49a0 <vfprintf+0x286>
    49b2:	57 cf       	rjmp	.-338    	; 0x4862 <vfprintf+0x148>
    49b4:	60 81       	ld	r22, Z
    49b6:	71 81       	ldd	r23, Z+1	; 0x01
    49b8:	07 2e       	mov	r0, r23
    49ba:	00 0c       	add	r0, r0
    49bc:	88 0b       	sbc	r24, r24
    49be:	99 0b       	sbc	r25, r25
    49c0:	0e 5f       	subi	r16, 0xFE	; 254
    49c2:	1f 4f       	sbci	r17, 0xFF	; 255
    49c4:	96 cf       	rjmp	.-212    	; 0x48f2 <vfprintf+0x1d8>
    49c6:	d3 2c       	mov	r13, r3
    49c8:	e8 94       	clt
    49ca:	d4 f8       	bld	r13, 4
    49cc:	2a e0       	ldi	r18, 0x0A	; 10
    49ce:	30 e0       	ldi	r19, 0x00	; 0
    49d0:	85 37       	cpi	r24, 0x75	; 117
    49d2:	31 f1       	breq	.+76     	; 0x4a20 <vfprintf+0x306>
    49d4:	23 2d       	mov	r18, r3
    49d6:	29 7f       	andi	r18, 0xF9	; 249
    49d8:	d2 2e       	mov	r13, r18
    49da:	8f 36       	cpi	r24, 0x6F	; 111
    49dc:	f9 f0       	breq	.+62     	; 0x4a1c <vfprintf+0x302>
    49de:	40 f4       	brcc	.+16     	; 0x49f0 <vfprintf+0x2d6>
    49e0:	88 35       	cpi	r24, 0x58	; 88
    49e2:	a1 f0       	breq	.+40     	; 0x4a0c <vfprintf+0x2f2>
    49e4:	f7 01       	movw	r30, r14
    49e6:	86 81       	ldd	r24, Z+6	; 0x06
    49e8:	97 81       	ldd	r25, Z+7	; 0x07
    49ea:	2b 96       	adiw	r28, 0x0b	; 11
    49ec:	e2 e1       	ldi	r30, 0x12	; 18
    49ee:	49 c1       	rjmp	.+658    	; 0x4c82 <__epilogue_restores__>
    49f0:	80 37       	cpi	r24, 0x70	; 112
    49f2:	49 f0       	breq	.+18     	; 0x4a06 <vfprintf+0x2ec>
    49f4:	88 37       	cpi	r24, 0x78	; 120
    49f6:	b1 f7       	brne	.-20     	; 0x49e4 <vfprintf+0x2ca>
    49f8:	d4 fe       	sbrs	r13, 4
    49fa:	02 c0       	rjmp	.+4      	; 0x4a00 <vfprintf+0x2e6>
    49fc:	68 94       	set
    49fe:	d2 f8       	bld	r13, 2
    4a00:	20 e1       	ldi	r18, 0x10	; 16
    4a02:	30 e0       	ldi	r19, 0x00	; 0
    4a04:	0d c0       	rjmp	.+26     	; 0x4a20 <vfprintf+0x306>
    4a06:	68 94       	set
    4a08:	d4 f8       	bld	r13, 4
    4a0a:	f6 cf       	rjmp	.-20     	; 0x49f8 <vfprintf+0x2de>
    4a0c:	34 fe       	sbrs	r3, 4
    4a0e:	03 c0       	rjmp	.+6      	; 0x4a16 <vfprintf+0x2fc>
    4a10:	82 2f       	mov	r24, r18
    4a12:	86 60       	ori	r24, 0x06	; 6
    4a14:	d8 2e       	mov	r13, r24
    4a16:	20 e1       	ldi	r18, 0x10	; 16
    4a18:	32 e0       	ldi	r19, 0x02	; 2
    4a1a:	02 c0       	rjmp	.+4      	; 0x4a20 <vfprintf+0x306>
    4a1c:	28 e0       	ldi	r18, 0x08	; 8
    4a1e:	30 e0       	ldi	r19, 0x00	; 0
    4a20:	f8 01       	movw	r30, r16
    4a22:	d7 fe       	sbrs	r13, 7
    4a24:	0e c0       	rjmp	.+28     	; 0x4a42 <vfprintf+0x328>
    4a26:	60 81       	ld	r22, Z
    4a28:	71 81       	ldd	r23, Z+1	; 0x01
    4a2a:	82 81       	ldd	r24, Z+2	; 0x02
    4a2c:	93 81       	ldd	r25, Z+3	; 0x03
    4a2e:	0c 5f       	subi	r16, 0xFC	; 252
    4a30:	1f 4f       	sbci	r17, 0xFF	; 255
    4a32:	a5 01       	movw	r20, r10
    4a34:	83 d0       	rcall	.+262    	; 0x4b3c <__ultoa_invert>
    4a36:	c8 2e       	mov	r12, r24
    4a38:	ca 18       	sub	r12, r10
    4a3a:	3d 2c       	mov	r3, r13
    4a3c:	e8 94       	clt
    4a3e:	37 f8       	bld	r3, 7
    4a40:	6c cf       	rjmp	.-296    	; 0x491a <vfprintf+0x200>
    4a42:	60 81       	ld	r22, Z
    4a44:	71 81       	ldd	r23, Z+1	; 0x01
    4a46:	90 e0       	ldi	r25, 0x00	; 0
    4a48:	80 e0       	ldi	r24, 0x00	; 0
    4a4a:	0e 5f       	subi	r16, 0xFE	; 254
    4a4c:	1f 4f       	sbci	r17, 0xFF	; 255
    4a4e:	f1 cf       	rjmp	.-30     	; 0x4a32 <vfprintf+0x318>
    4a50:	42 fc       	sbrc	r4, 2
    4a52:	02 c0       	rjmp	.+4      	; 0x4a58 <vfprintf+0x33e>
    4a54:	83 94       	inc	r8
    4a56:	7d cf       	rjmp	.-262    	; 0x4952 <vfprintf+0x238>
    4a58:	83 94       	inc	r8
    4a5a:	83 94       	inc	r8
    4a5c:	7a cf       	rjmp	.-268    	; 0x4952 <vfprintf+0x238>
    4a5e:	84 2d       	mov	r24, r4
    4a60:	86 78       	andi	r24, 0x86	; 134
    4a62:	09 f4       	brne	.+2      	; 0x4a66 <vfprintf+0x34c>
    4a64:	76 cf       	rjmp	.-276    	; 0x4952 <vfprintf+0x238>
    4a66:	f6 cf       	rjmp	.-20     	; 0x4a54 <vfprintf+0x33a>
    4a68:	b7 01       	movw	r22, r14
    4a6a:	80 e2       	ldi	r24, 0x20	; 32
    4a6c:	90 e0       	ldi	r25, 0x00	; 0
    4a6e:	36 d0       	rcall	.+108    	; 0x4adc <fputc>
    4a70:	83 94       	inc	r8
    4a72:	82 14       	cp	r8, r2
    4a74:	c8 f3       	brcs	.-14     	; 0x4a68 <vfprintf+0x34e>
    4a76:	51 2c       	mov	r5, r1
    4a78:	79 cf       	rjmp	.-270    	; 0x496c <vfprintf+0x252>
    4a7a:	52 2c       	mov	r5, r2
    4a7c:	58 18       	sub	r5, r8
    4a7e:	82 14       	cp	r8, r2
    4a80:	08 f4       	brcc	.+2      	; 0x4a84 <vfprintf+0x36a>
    4a82:	74 cf       	rjmp	.-280    	; 0x496c <vfprintf+0x252>
    4a84:	f8 cf       	rjmp	.-16     	; 0x4a76 <vfprintf+0x35c>
    4a86:	84 2d       	mov	r24, r4
    4a88:	86 78       	andi	r24, 0x86	; 134
    4a8a:	09 f4       	brne	.+2      	; 0x4a8e <vfprintf+0x374>
    4a8c:	7f cf       	rjmp	.-258    	; 0x498c <vfprintf+0x272>
    4a8e:	8b e2       	ldi	r24, 0x2B	; 43
    4a90:	41 fe       	sbrs	r4, 1
    4a92:	80 e2       	ldi	r24, 0x20	; 32
    4a94:	47 fc       	sbrc	r4, 7
    4a96:	8d e2       	ldi	r24, 0x2D	; 45
    4a98:	b7 01       	movw	r22, r14
    4a9a:	90 e0       	ldi	r25, 0x00	; 0
    4a9c:	76 cf       	rjmp	.-276    	; 0x498a <vfprintf+0x270>
    4a9e:	b7 01       	movw	r22, r14
    4aa0:	80 e3       	ldi	r24, 0x30	; 48
    4aa2:	90 e0       	ldi	r25, 0x00	; 0
    4aa4:	1b d0       	rcall	.+54     	; 0x4adc <fputc>
    4aa6:	9a 94       	dec	r9
    4aa8:	71 cf       	rjmp	.-286    	; 0x498c <vfprintf+0x272>
    4aaa:	8f ef       	ldi	r24, 0xFF	; 255
    4aac:	9f ef       	ldi	r25, 0xFF	; 255
    4aae:	9d cf       	rjmp	.-198    	; 0x49ea <vfprintf+0x2d0>

00004ab0 <strnlen_P>:
strnlen_P():
    4ab0:	fc 01       	movw	r30, r24
    4ab2:	05 90       	lpm	r0, Z+
    4ab4:	61 50       	subi	r22, 0x01	; 1
    4ab6:	70 40       	sbci	r23, 0x00	; 0
    4ab8:	01 10       	cpse	r0, r1
    4aba:	d8 f7       	brcc	.-10     	; 0x4ab2 <strnlen_P+0x2>
    4abc:	80 95       	com	r24
    4abe:	90 95       	com	r25
    4ac0:	8e 0f       	add	r24, r30
    4ac2:	9f 1f       	adc	r25, r31
    4ac4:	08 95       	ret

00004ac6 <strnlen>:
strnlen():
    4ac6:	fc 01       	movw	r30, r24
    4ac8:	61 50       	subi	r22, 0x01	; 1
    4aca:	70 40       	sbci	r23, 0x00	; 0
    4acc:	01 90       	ld	r0, Z+
    4ace:	01 10       	cpse	r0, r1
    4ad0:	d8 f7       	brcc	.-10     	; 0x4ac8 <strnlen+0x2>
    4ad2:	80 95       	com	r24
    4ad4:	90 95       	com	r25
    4ad6:	8e 0f       	add	r24, r30
    4ad8:	9f 1f       	adc	r25, r31
    4ada:	08 95       	ret

00004adc <fputc>:
fputc():
    4adc:	0f 93       	push	r16
    4ade:	1f 93       	push	r17
    4ae0:	cf 93       	push	r28
    4ae2:	df 93       	push	r29
    4ae4:	18 2f       	mov	r17, r24
    4ae6:	09 2f       	mov	r16, r25
    4ae8:	eb 01       	movw	r28, r22
    4aea:	8b 81       	ldd	r24, Y+3	; 0x03
    4aec:	81 fd       	sbrc	r24, 1
    4aee:	09 c0       	rjmp	.+18     	; 0x4b02 <fputc+0x26>
    4af0:	1f ef       	ldi	r17, 0xFF	; 255
    4af2:	0f ef       	ldi	r16, 0xFF	; 255
    4af4:	81 2f       	mov	r24, r17
    4af6:	90 2f       	mov	r25, r16
    4af8:	df 91       	pop	r29
    4afa:	cf 91       	pop	r28
    4afc:	1f 91       	pop	r17
    4afe:	0f 91       	pop	r16
    4b00:	08 95       	ret
    4b02:	82 ff       	sbrs	r24, 2
    4b04:	14 c0       	rjmp	.+40     	; 0x4b2e <fputc+0x52>
    4b06:	2e 81       	ldd	r18, Y+6	; 0x06
    4b08:	3f 81       	ldd	r19, Y+7	; 0x07
    4b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b0e:	28 17       	cp	r18, r24
    4b10:	39 07       	cpc	r19, r25
    4b12:	3c f4       	brge	.+14     	; 0x4b22 <fputc+0x46>
    4b14:	e8 81       	ld	r30, Y
    4b16:	f9 81       	ldd	r31, Y+1	; 0x01
    4b18:	cf 01       	movw	r24, r30
    4b1a:	01 96       	adiw	r24, 0x01	; 1
    4b1c:	88 83       	st	Y, r24
    4b1e:	99 83       	std	Y+1, r25	; 0x01
    4b20:	10 83       	st	Z, r17
    4b22:	8e 81       	ldd	r24, Y+6	; 0x06
    4b24:	9f 81       	ldd	r25, Y+7	; 0x07
    4b26:	01 96       	adiw	r24, 0x01	; 1
    4b28:	8e 83       	std	Y+6, r24	; 0x06
    4b2a:	9f 83       	std	Y+7, r25	; 0x07
    4b2c:	e3 cf       	rjmp	.-58     	; 0x4af4 <fputc+0x18>
    4b2e:	e8 85       	ldd	r30, Y+8	; 0x08
    4b30:	f9 85       	ldd	r31, Y+9	; 0x09
    4b32:	81 2f       	mov	r24, r17
    4b34:	09 95       	icall
    4b36:	89 2b       	or	r24, r25
    4b38:	a1 f3       	breq	.-24     	; 0x4b22 <fputc+0x46>
    4b3a:	da cf       	rjmp	.-76     	; 0x4af0 <fputc+0x14>

00004b3c <__ultoa_invert>:
__ultoa_invert():
    4b3c:	fa 01       	movw	r30, r20
    4b3e:	aa 27       	eor	r26, r26
    4b40:	28 30       	cpi	r18, 0x08	; 8
    4b42:	51 f1       	breq	.+84     	; 0x4b98 <__ultoa_invert+0x5c>
    4b44:	20 31       	cpi	r18, 0x10	; 16
    4b46:	81 f1       	breq	.+96     	; 0x4ba8 <__ultoa_invert+0x6c>
    4b48:	e8 94       	clt
    4b4a:	6f 93       	push	r22
    4b4c:	6e 7f       	andi	r22, 0xFE	; 254
    4b4e:	6e 5f       	subi	r22, 0xFE	; 254
    4b50:	7f 4f       	sbci	r23, 0xFF	; 255
    4b52:	8f 4f       	sbci	r24, 0xFF	; 255
    4b54:	9f 4f       	sbci	r25, 0xFF	; 255
    4b56:	af 4f       	sbci	r26, 0xFF	; 255
    4b58:	b1 e0       	ldi	r27, 0x01	; 1
    4b5a:	3e d0       	rcall	.+124    	; 0x4bd8 <__ultoa_invert+0x9c>
    4b5c:	b4 e0       	ldi	r27, 0x04	; 4
    4b5e:	3c d0       	rcall	.+120    	; 0x4bd8 <__ultoa_invert+0x9c>
    4b60:	67 0f       	add	r22, r23
    4b62:	78 1f       	adc	r23, r24
    4b64:	89 1f       	adc	r24, r25
    4b66:	9a 1f       	adc	r25, r26
    4b68:	a1 1d       	adc	r26, r1
    4b6a:	68 0f       	add	r22, r24
    4b6c:	79 1f       	adc	r23, r25
    4b6e:	8a 1f       	adc	r24, r26
    4b70:	91 1d       	adc	r25, r1
    4b72:	a1 1d       	adc	r26, r1
    4b74:	6a 0f       	add	r22, r26
    4b76:	71 1d       	adc	r23, r1
    4b78:	81 1d       	adc	r24, r1
    4b7a:	91 1d       	adc	r25, r1
    4b7c:	a1 1d       	adc	r26, r1
    4b7e:	20 d0       	rcall	.+64     	; 0x4bc0 <__ultoa_invert+0x84>
    4b80:	09 f4       	brne	.+2      	; 0x4b84 <__ultoa_invert+0x48>
    4b82:	68 94       	set
    4b84:	3f 91       	pop	r19
    4b86:	2a e0       	ldi	r18, 0x0A	; 10
    4b88:	26 9f       	mul	r18, r22
    4b8a:	11 24       	eor	r1, r1
    4b8c:	30 19       	sub	r19, r0
    4b8e:	30 5d       	subi	r19, 0xD0	; 208
    4b90:	31 93       	st	Z+, r19
    4b92:	de f6       	brtc	.-74     	; 0x4b4a <__ultoa_invert+0xe>
    4b94:	cf 01       	movw	r24, r30
    4b96:	08 95       	ret
    4b98:	46 2f       	mov	r20, r22
    4b9a:	47 70       	andi	r20, 0x07	; 7
    4b9c:	40 5d       	subi	r20, 0xD0	; 208
    4b9e:	41 93       	st	Z+, r20
    4ba0:	b3 e0       	ldi	r27, 0x03	; 3
    4ba2:	0f d0       	rcall	.+30     	; 0x4bc2 <__ultoa_invert+0x86>
    4ba4:	c9 f7       	brne	.-14     	; 0x4b98 <__ultoa_invert+0x5c>
    4ba6:	f6 cf       	rjmp	.-20     	; 0x4b94 <__ultoa_invert+0x58>
    4ba8:	46 2f       	mov	r20, r22
    4baa:	4f 70       	andi	r20, 0x0F	; 15
    4bac:	40 5d       	subi	r20, 0xD0	; 208
    4bae:	4a 33       	cpi	r20, 0x3A	; 58
    4bb0:	18 f0       	brcs	.+6      	; 0x4bb8 <__ultoa_invert+0x7c>
    4bb2:	49 5d       	subi	r20, 0xD9	; 217
    4bb4:	31 fd       	sbrc	r19, 1
    4bb6:	40 52       	subi	r20, 0x20	; 32
    4bb8:	41 93       	st	Z+, r20
    4bba:	02 d0       	rcall	.+4      	; 0x4bc0 <__ultoa_invert+0x84>
    4bbc:	a9 f7       	brne	.-22     	; 0x4ba8 <__ultoa_invert+0x6c>
    4bbe:	ea cf       	rjmp	.-44     	; 0x4b94 <__ultoa_invert+0x58>
    4bc0:	b4 e0       	ldi	r27, 0x04	; 4
    4bc2:	a6 95       	lsr	r26
    4bc4:	97 95       	ror	r25
    4bc6:	87 95       	ror	r24
    4bc8:	77 95       	ror	r23
    4bca:	67 95       	ror	r22
    4bcc:	ba 95       	dec	r27
    4bce:	c9 f7       	brne	.-14     	; 0x4bc2 <__ultoa_invert+0x86>
    4bd0:	00 97       	sbiw	r24, 0x00	; 0
    4bd2:	61 05       	cpc	r22, r1
    4bd4:	71 05       	cpc	r23, r1
    4bd6:	08 95       	ret
    4bd8:	9b 01       	movw	r18, r22
    4bda:	ac 01       	movw	r20, r24
    4bdc:	0a 2e       	mov	r0, r26
    4bde:	06 94       	lsr	r0
    4be0:	57 95       	ror	r21
    4be2:	47 95       	ror	r20
    4be4:	37 95       	ror	r19
    4be6:	27 95       	ror	r18
    4be8:	ba 95       	dec	r27
    4bea:	c9 f7       	brne	.-14     	; 0x4bde <__ultoa_invert+0xa2>
    4bec:	62 0f       	add	r22, r18
    4bee:	73 1f       	adc	r23, r19
    4bf0:	84 1f       	adc	r24, r20
    4bf2:	95 1f       	adc	r25, r21
    4bf4:	a0 1d       	adc	r26, r0
    4bf6:	08 95       	ret

00004bf8 <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    4bf8:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    4bfa:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    4bfc:	16 f4       	brtc	.+4      	; 0x4c02 <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    4bfe:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    4c00:	0f d0       	rcall	.+30     	; 0x4c20 <__negsi2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    4c02:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    4c04:	05 d0       	rcall	.+10     	; 0x4c10 <__divmodsi4_neg2>
    4c06:	55 d0       	rcall	.+170    	; 0x4cb2 <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    4c08:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    4c0a:	02 d0       	rcall	.+4      	; 0x4c10 <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    4c0c:	46 f4       	brtc	.+16     	; 0x4c1e <__divmodsi4_exit>
    4c0e:	08 c0       	rjmp	.+16     	; 0x4c20 <__negsi2>

00004c10 <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    4c10:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    4c12:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    4c14:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    4c16:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    4c18:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    4c1a:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    4c1c:	5f 4f       	sbci	r21, 0xFF	; 255

00004c1e <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    4c1e:	08 95       	ret

00004c20 <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    4c20:	90 95       	com	r25
    4c22:	80 95       	com	r24
    4c24:	70 95       	com	r23
    4c26:	61 95       	neg	r22
    4c28:	7f 4f       	sbci	r23, 0xFF	; 255
    4c2a:	8f 4f       	sbci	r24, 0xFF	; 255
    4c2c:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    4c2e:	08 95       	ret

00004c30 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    4c30:	62 d0       	rcall	.+196    	; 0x4cf6 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    4c32:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    4c34:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    4c36:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    4c38:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    4c3a:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    4c3c:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    4c3e:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    4c40:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    4c42:	08 95       	ret

00004c44 <__mulshisi3>:
__mulshisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    4c44:	b7 ff       	sbrs	r27, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    4c46:	f4 cf       	rjmp	.-24     	; 0x4c30 <__muluhisi3>

00004c48 <__mulohisi3>:
__mulohisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    4c48:	f3 df       	rcall	.-26     	; 0x4c30 <__muluhisi3>
    4c4a:	82 1b       	sub	r24, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    4c4c:	93 0b       	sbc	r25, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    4c4e:	08 95       	ret

00004c50 <__prologue_saves__>:
__prologue_saves__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    4c50:	2f 92       	push	r2
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    4c52:	3f 92       	push	r3
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    4c54:	4f 92       	push	r4
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    4c56:	5f 92       	push	r5
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    4c58:	6f 92       	push	r6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    4c5a:	7f 92       	push	r7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    4c5c:	8f 92       	push	r8
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    4c5e:	9f 92       	push	r9
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    4c60:	af 92       	push	r10
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    4c62:	bf 92       	push	r11
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    4c64:	cf 92       	push	r12
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    4c66:	df 92       	push	r13
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    4c68:	ef 92       	push	r14
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    4c6a:	ff 92       	push	r15
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    4c6c:	0f 93       	push	r16
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    4c6e:	1f 93       	push	r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    4c70:	cf 93       	push	r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    4c72:	df 93       	push	r29
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2193
    4c74:	cd b7       	in	r28, 0x3d	; 61
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2194
    4c76:	de b7       	in	r29, 0x3e	; 62
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2195
    4c78:	ca 1b       	sub	r28, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2196
    4c7a:	db 0b       	sbc	r29, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2197
    4c7c:	cd bf       	out	0x3d, r28	; 61
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2198
    4c7e:	de bf       	out	0x3e, r29	; 62
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    4c80:	09 94       	ijmp

00004c82 <__epilogue_restores__>:
__epilogue_restores__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    4c82:	2a 88       	ldd	r2, Y+18	; 0x12
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    4c84:	39 88       	ldd	r3, Y+17	; 0x11
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    4c86:	48 88       	ldd	r4, Y+16	; 0x10
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    4c88:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    4c8a:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    4c8c:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    4c8e:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    4c90:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    4c92:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    4c94:	b9 84       	ldd	r11, Y+9	; 0x09
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    4c96:	c8 84       	ldd	r12, Y+8	; 0x08
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    4c98:	df 80       	ldd	r13, Y+7	; 0x07
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    4c9a:	ee 80       	ldd	r14, Y+6	; 0x06
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    4c9c:	fd 80       	ldd	r15, Y+5	; 0x05
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    4c9e:	0c 81       	ldd	r16, Y+4	; 0x04
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    4ca0:	1b 81       	ldd	r17, Y+3	; 0x03
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    4ca2:	aa 81       	ldd	r26, Y+2	; 0x02
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2245
    4ca4:	b9 81       	ldd	r27, Y+1	; 0x01
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2246
    4ca6:	ce 0f       	add	r28, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2247
    4ca8:	d1 1d       	adc	r29, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2248
    4caa:	cd bf       	out	0x3d, r28	; 61
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2249
    4cac:	de bf       	out	0x3e, r29	; 62
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2250
    4cae:	ed 01       	movw	r28, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    4cb0:	08 95       	ret

00004cb2 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    4cb2:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    4cb4:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    4cb6:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    4cb8:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    4cba:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    4cbc:	0d c0       	rjmp	.+26     	; 0x4cd8 <__udivmodsi4_ep>

00004cbe <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    4cbe:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    4cc0:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    4cc2:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    4cc4:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    4cc6:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    4cc8:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    4cca:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    4ccc:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    4cce:	20 f0       	brcs	.+8      	; 0x4cd8 <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    4cd0:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    4cd2:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    4cd4:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    4cd6:	f5 0b       	sbc	r31, r21

00004cd8 <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    4cd8:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    4cda:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    4cdc:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    4cde:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    4ce0:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    4ce2:	69 f7       	brne	.-38     	; 0x4cbe <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    4ce4:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    4ce6:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    4ce8:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    4cea:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    4cec:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    4cee:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    4cf0:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    4cf2:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    4cf4:	08 95       	ret

00004cf6 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    4cf6:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    4cf8:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    4cfa:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    4cfc:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    4cfe:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    4d00:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    4d02:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    4d04:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    4d06:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    4d08:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    4d0a:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    4d0c:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    4d0e:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    4d10:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    4d12:	08 95       	ret

00004d14 <__udivmodhi4>:
__udivmodhi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    4d14:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    4d16:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    4d18:	51 e1       	ldi	r21, 0x11	; 17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    4d1a:	07 c0       	rjmp	.+14     	; 0x4d2a <__udivmodhi4_ep>

00004d1c <__udivmodhi4_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    4d1c:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    4d1e:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    4d20:	a6 17       	cp	r26, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    4d22:	b7 07       	cpc	r27, r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    4d24:	10 f0       	brcs	.+4      	; 0x4d2a <__udivmodhi4_ep>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    4d26:	a6 1b       	sub	r26, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    4d28:	b7 0b       	sbc	r27, r23

00004d2a <__udivmodhi4_ep>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    4d2a:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    4d2c:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    4d2e:	5a 95       	dec	r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    4d30:	a9 f7       	brne	.-22     	; 0x4d1c <__udivmodhi4_loop>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    4d32:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    4d34:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    4d36:	bc 01       	movw	r22, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    4d38:	cd 01       	movw	r24, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    4d3a:	08 95       	ret

00004d3c <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    4d3c:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    4d3e:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    4d40:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    4d42:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    4d44:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    4d46:	09 94       	ijmp

00004d48 <malloc>:
malloc():
    4d48:	0f 93       	push	r16
    4d4a:	1f 93       	push	r17
    4d4c:	cf 93       	push	r28
    4d4e:	df 93       	push	r29
    4d50:	82 30       	cpi	r24, 0x02	; 2
    4d52:	91 05       	cpc	r25, r1
    4d54:	10 f4       	brcc	.+4      	; 0x4d5a <malloc+0x12>
    4d56:	82 e0       	ldi	r24, 0x02	; 2
    4d58:	90 e0       	ldi	r25, 0x00	; 0
    4d5a:	e0 91 ab 65 	lds	r30, 0x65AB	; 0x8065ab <__flp>
    4d5e:	f0 91 ac 65 	lds	r31, 0x65AC	; 0x8065ac <__flp+0x1>
    4d62:	30 e0       	ldi	r19, 0x00	; 0
    4d64:	20 e0       	ldi	r18, 0x00	; 0
    4d66:	b0 e0       	ldi	r27, 0x00	; 0
    4d68:	a0 e0       	ldi	r26, 0x00	; 0
    4d6a:	30 97       	sbiw	r30, 0x00	; 0
    4d6c:	99 f4       	brne	.+38     	; 0x4d94 <malloc+0x4c>
    4d6e:	21 15       	cp	r18, r1
    4d70:	31 05       	cpc	r19, r1
    4d72:	09 f4       	brne	.+2      	; 0x4d76 <malloc+0x2e>
    4d74:	4a c0       	rjmp	.+148    	; 0x4e0a <malloc+0xc2>
    4d76:	28 1b       	sub	r18, r24
    4d78:	39 0b       	sbc	r19, r25
    4d7a:	24 30       	cpi	r18, 0x04	; 4
    4d7c:	31 05       	cpc	r19, r1
    4d7e:	d8 f5       	brcc	.+118    	; 0x4df6 <malloc+0xae>
    4d80:	8a 81       	ldd	r24, Y+2	; 0x02
    4d82:	9b 81       	ldd	r25, Y+3	; 0x03
    4d84:	61 15       	cp	r22, r1
    4d86:	71 05       	cpc	r23, r1
    4d88:	89 f1       	breq	.+98     	; 0x4dec <malloc+0xa4>
    4d8a:	fb 01       	movw	r30, r22
    4d8c:	82 83       	std	Z+2, r24	; 0x02
    4d8e:	93 83       	std	Z+3, r25	; 0x03
    4d90:	fe 01       	movw	r30, r28
    4d92:	11 c0       	rjmp	.+34     	; 0x4db6 <malloc+0x6e>
    4d94:	40 81       	ld	r20, Z
    4d96:	51 81       	ldd	r21, Z+1	; 0x01
    4d98:	02 81       	ldd	r16, Z+2	; 0x02
    4d9a:	13 81       	ldd	r17, Z+3	; 0x03
    4d9c:	48 17       	cp	r20, r24
    4d9e:	59 07       	cpc	r21, r25
    4da0:	e0 f0       	brcs	.+56     	; 0x4dda <malloc+0x92>
    4da2:	48 17       	cp	r20, r24
    4da4:	59 07       	cpc	r21, r25
    4da6:	99 f4       	brne	.+38     	; 0x4dce <malloc+0x86>
    4da8:	10 97       	sbiw	r26, 0x00	; 0
    4daa:	61 f0       	breq	.+24     	; 0x4dc4 <malloc+0x7c>
    4dac:	12 96       	adiw	r26, 0x02	; 2
    4dae:	0c 93       	st	X, r16
    4db0:	12 97       	sbiw	r26, 0x02	; 2
    4db2:	13 96       	adiw	r26, 0x03	; 3
    4db4:	1c 93       	st	X, r17
    4db6:	32 96       	adiw	r30, 0x02	; 2
    4db8:	cf 01       	movw	r24, r30
    4dba:	df 91       	pop	r29
    4dbc:	cf 91       	pop	r28
    4dbe:	1f 91       	pop	r17
    4dc0:	0f 91       	pop	r16
    4dc2:	08 95       	ret
    4dc4:	00 93 ab 65 	sts	0x65AB, r16	; 0x8065ab <__flp>
    4dc8:	10 93 ac 65 	sts	0x65AC, r17	; 0x8065ac <__flp+0x1>
    4dcc:	f4 cf       	rjmp	.-24     	; 0x4db6 <malloc+0x6e>
    4dce:	21 15       	cp	r18, r1
    4dd0:	31 05       	cpc	r19, r1
    4dd2:	51 f0       	breq	.+20     	; 0x4de8 <malloc+0xa0>
    4dd4:	42 17       	cp	r20, r18
    4dd6:	53 07       	cpc	r21, r19
    4dd8:	38 f0       	brcs	.+14     	; 0x4de8 <malloc+0xa0>
    4dda:	a9 01       	movw	r20, r18
    4ddc:	db 01       	movw	r26, r22
    4dde:	9a 01       	movw	r18, r20
    4de0:	bd 01       	movw	r22, r26
    4de2:	df 01       	movw	r26, r30
    4de4:	f8 01       	movw	r30, r16
    4de6:	c1 cf       	rjmp	.-126    	; 0x4d6a <malloc+0x22>
    4de8:	ef 01       	movw	r28, r30
    4dea:	f9 cf       	rjmp	.-14     	; 0x4dde <malloc+0x96>
    4dec:	80 93 ab 65 	sts	0x65AB, r24	; 0x8065ab <__flp>
    4df0:	90 93 ac 65 	sts	0x65AC, r25	; 0x8065ac <__flp+0x1>
    4df4:	cd cf       	rjmp	.-102    	; 0x4d90 <malloc+0x48>
    4df6:	fe 01       	movw	r30, r28
    4df8:	e2 0f       	add	r30, r18
    4dfa:	f3 1f       	adc	r31, r19
    4dfc:	81 93       	st	Z+, r24
    4dfe:	91 93       	st	Z+, r25
    4e00:	22 50       	subi	r18, 0x02	; 2
    4e02:	31 09       	sbc	r19, r1
    4e04:	28 83       	st	Y, r18
    4e06:	39 83       	std	Y+1, r19	; 0x01
    4e08:	d7 cf       	rjmp	.-82     	; 0x4db8 <malloc+0x70>
    4e0a:	20 91 a9 65 	lds	r18, 0x65A9	; 0x8065a9 <__brkval>
    4e0e:	30 91 aa 65 	lds	r19, 0x65AA	; 0x8065aa <__brkval+0x1>
    4e12:	23 2b       	or	r18, r19
    4e14:	41 f4       	brne	.+16     	; 0x4e26 <malloc+0xde>
    4e16:	20 91 08 60 	lds	r18, 0x6008	; 0x806008 <__malloc_heap_start>
    4e1a:	30 91 09 60 	lds	r19, 0x6009	; 0x806009 <__malloc_heap_start+0x1>
    4e1e:	20 93 a9 65 	sts	0x65A9, r18	; 0x8065a9 <__brkval>
    4e22:	30 93 aa 65 	sts	0x65AA, r19	; 0x8065aa <__brkval+0x1>
    4e26:	20 91 06 60 	lds	r18, 0x6006	; 0x806006 <__malloc_heap_end>
    4e2a:	30 91 07 60 	lds	r19, 0x6007	; 0x806007 <__malloc_heap_end+0x1>
    4e2e:	21 15       	cp	r18, r1
    4e30:	31 05       	cpc	r19, r1
    4e32:	41 f4       	brne	.+16     	; 0x4e44 <malloc+0xfc>
    4e34:	2d b7       	in	r18, 0x3d	; 61
    4e36:	3e b7       	in	r19, 0x3e	; 62
    4e38:	40 91 0a 60 	lds	r20, 0x600A	; 0x80600a <__malloc_margin>
    4e3c:	50 91 0b 60 	lds	r21, 0x600B	; 0x80600b <__malloc_margin+0x1>
    4e40:	24 1b       	sub	r18, r20
    4e42:	35 0b       	sbc	r19, r21
    4e44:	e0 91 a9 65 	lds	r30, 0x65A9	; 0x8065a9 <__brkval>
    4e48:	f0 91 aa 65 	lds	r31, 0x65AA	; 0x8065aa <__brkval+0x1>
    4e4c:	e2 17       	cp	r30, r18
    4e4e:	f3 07       	cpc	r31, r19
    4e50:	a0 f4       	brcc	.+40     	; 0x4e7a <malloc+0x132>
    4e52:	2e 1b       	sub	r18, r30
    4e54:	3f 0b       	sbc	r19, r31
    4e56:	28 17       	cp	r18, r24
    4e58:	39 07       	cpc	r19, r25
    4e5a:	78 f0       	brcs	.+30     	; 0x4e7a <malloc+0x132>
    4e5c:	ac 01       	movw	r20, r24
    4e5e:	4e 5f       	subi	r20, 0xFE	; 254
    4e60:	5f 4f       	sbci	r21, 0xFF	; 255
    4e62:	24 17       	cp	r18, r20
    4e64:	35 07       	cpc	r19, r21
    4e66:	48 f0       	brcs	.+18     	; 0x4e7a <malloc+0x132>
    4e68:	4e 0f       	add	r20, r30
    4e6a:	5f 1f       	adc	r21, r31
    4e6c:	40 93 a9 65 	sts	0x65A9, r20	; 0x8065a9 <__brkval>
    4e70:	50 93 aa 65 	sts	0x65AA, r21	; 0x8065aa <__brkval+0x1>
    4e74:	81 93       	st	Z+, r24
    4e76:	91 93       	st	Z+, r25
    4e78:	9f cf       	rjmp	.-194    	; 0x4db8 <malloc+0x70>
    4e7a:	f0 e0       	ldi	r31, 0x00	; 0
    4e7c:	e0 e0       	ldi	r30, 0x00	; 0
    4e7e:	9c cf       	rjmp	.-200    	; 0x4db8 <malloc+0x70>

00004e80 <free>:
free():
    4e80:	cf 93       	push	r28
    4e82:	df 93       	push	r29
    4e84:	00 97       	sbiw	r24, 0x00	; 0
    4e86:	e9 f0       	breq	.+58     	; 0x4ec2 <free+0x42>
    4e88:	fc 01       	movw	r30, r24
    4e8a:	32 97       	sbiw	r30, 0x02	; 2
    4e8c:	12 82       	std	Z+2, r1	; 0x02
    4e8e:	13 82       	std	Z+3, r1	; 0x03
    4e90:	a0 91 ab 65 	lds	r26, 0x65AB	; 0x8065ab <__flp>
    4e94:	b0 91 ac 65 	lds	r27, 0x65AC	; 0x8065ac <__flp+0x1>
    4e98:	ed 01       	movw	r28, r26
    4e9a:	30 e0       	ldi	r19, 0x00	; 0
    4e9c:	20 e0       	ldi	r18, 0x00	; 0
    4e9e:	10 97       	sbiw	r26, 0x00	; 0
    4ea0:	a1 f4       	brne	.+40     	; 0x4eca <free+0x4a>
    4ea2:	20 81       	ld	r18, Z
    4ea4:	31 81       	ldd	r19, Z+1	; 0x01
    4ea6:	82 0f       	add	r24, r18
    4ea8:	93 1f       	adc	r25, r19
    4eaa:	20 91 a9 65 	lds	r18, 0x65A9	; 0x8065a9 <__brkval>
    4eae:	30 91 aa 65 	lds	r19, 0x65AA	; 0x8065aa <__brkval+0x1>
    4eb2:	28 17       	cp	r18, r24
    4eb4:	39 07       	cpc	r19, r25
    4eb6:	09 f0       	breq	.+2      	; 0x4eba <free+0x3a>
    4eb8:	61 c0       	rjmp	.+194    	; 0x4f7c <free+0xfc>
    4eba:	e0 93 a9 65 	sts	0x65A9, r30	; 0x8065a9 <__brkval>
    4ebe:	f0 93 aa 65 	sts	0x65AA, r31	; 0x8065aa <__brkval+0x1>
    4ec2:	df 91       	pop	r29
    4ec4:	cf 91       	pop	r28
    4ec6:	08 95       	ret
    4ec8:	ea 01       	movw	r28, r20
    4eca:	ce 17       	cp	r28, r30
    4ecc:	df 07       	cpc	r29, r31
    4ece:	e8 f5       	brcc	.+122    	; 0x4f4a <free+0xca>
    4ed0:	4a 81       	ldd	r20, Y+2	; 0x02
    4ed2:	5b 81       	ldd	r21, Y+3	; 0x03
    4ed4:	9e 01       	movw	r18, r28
    4ed6:	41 15       	cp	r20, r1
    4ed8:	51 05       	cpc	r21, r1
    4eda:	b1 f7       	brne	.-20     	; 0x4ec8 <free+0x48>
    4edc:	e9 01       	movw	r28, r18
    4ede:	ea 83       	std	Y+2, r30	; 0x02
    4ee0:	fb 83       	std	Y+3, r31	; 0x03
    4ee2:	49 91       	ld	r20, Y+
    4ee4:	59 91       	ld	r21, Y+
    4ee6:	c4 0f       	add	r28, r20
    4ee8:	d5 1f       	adc	r29, r21
    4eea:	ec 17       	cp	r30, r28
    4eec:	fd 07       	cpc	r31, r29
    4eee:	61 f4       	brne	.+24     	; 0x4f08 <free+0x88>
    4ef0:	80 81       	ld	r24, Z
    4ef2:	91 81       	ldd	r25, Z+1	; 0x01
    4ef4:	02 96       	adiw	r24, 0x02	; 2
    4ef6:	84 0f       	add	r24, r20
    4ef8:	95 1f       	adc	r25, r21
    4efa:	e9 01       	movw	r28, r18
    4efc:	88 83       	st	Y, r24
    4efe:	99 83       	std	Y+1, r25	; 0x01
    4f00:	82 81       	ldd	r24, Z+2	; 0x02
    4f02:	93 81       	ldd	r25, Z+3	; 0x03
    4f04:	8a 83       	std	Y+2, r24	; 0x02
    4f06:	9b 83       	std	Y+3, r25	; 0x03
    4f08:	f0 e0       	ldi	r31, 0x00	; 0
    4f0a:	e0 e0       	ldi	r30, 0x00	; 0
    4f0c:	12 96       	adiw	r26, 0x02	; 2
    4f0e:	8d 91       	ld	r24, X+
    4f10:	9c 91       	ld	r25, X
    4f12:	13 97       	sbiw	r26, 0x03	; 3
    4f14:	00 97       	sbiw	r24, 0x00	; 0
    4f16:	b9 f5       	brne	.+110    	; 0x4f86 <free+0x106>
    4f18:	2d 91       	ld	r18, X+
    4f1a:	3c 91       	ld	r19, X
    4f1c:	11 97       	sbiw	r26, 0x01	; 1
    4f1e:	cd 01       	movw	r24, r26
    4f20:	02 96       	adiw	r24, 0x02	; 2
    4f22:	82 0f       	add	r24, r18
    4f24:	93 1f       	adc	r25, r19
    4f26:	20 91 a9 65 	lds	r18, 0x65A9	; 0x8065a9 <__brkval>
    4f2a:	30 91 aa 65 	lds	r19, 0x65AA	; 0x8065aa <__brkval+0x1>
    4f2e:	28 17       	cp	r18, r24
    4f30:	39 07       	cpc	r19, r25
    4f32:	39 f6       	brne	.-114    	; 0x4ec2 <free+0x42>
    4f34:	30 97       	sbiw	r30, 0x00	; 0
    4f36:	51 f5       	brne	.+84     	; 0x4f8c <free+0x10c>
    4f38:	10 92 ab 65 	sts	0x65AB, r1	; 0x8065ab <__flp>
    4f3c:	10 92 ac 65 	sts	0x65AC, r1	; 0x8065ac <__flp+0x1>
    4f40:	a0 93 a9 65 	sts	0x65A9, r26	; 0x8065a9 <__brkval>
    4f44:	b0 93 aa 65 	sts	0x65AA, r27	; 0x8065aa <__brkval+0x1>
    4f48:	bc cf       	rjmp	.-136    	; 0x4ec2 <free+0x42>
    4f4a:	c2 83       	std	Z+2, r28	; 0x02
    4f4c:	d3 83       	std	Z+3, r29	; 0x03
    4f4e:	40 81       	ld	r20, Z
    4f50:	51 81       	ldd	r21, Z+1	; 0x01
    4f52:	84 0f       	add	r24, r20
    4f54:	95 1f       	adc	r25, r21
    4f56:	c8 17       	cp	r28, r24
    4f58:	d9 07       	cpc	r29, r25
    4f5a:	61 f4       	brne	.+24     	; 0x4f74 <free+0xf4>
    4f5c:	4e 5f       	subi	r20, 0xFE	; 254
    4f5e:	5f 4f       	sbci	r21, 0xFF	; 255
    4f60:	88 81       	ld	r24, Y
    4f62:	99 81       	ldd	r25, Y+1	; 0x01
    4f64:	48 0f       	add	r20, r24
    4f66:	59 1f       	adc	r21, r25
    4f68:	40 83       	st	Z, r20
    4f6a:	51 83       	std	Z+1, r21	; 0x01
    4f6c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f6e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f70:	82 83       	std	Z+2, r24	; 0x02
    4f72:	93 83       	std	Z+3, r25	; 0x03
    4f74:	21 15       	cp	r18, r1
    4f76:	31 05       	cpc	r19, r1
    4f78:	09 f0       	breq	.+2      	; 0x4f7c <free+0xfc>
    4f7a:	b0 cf       	rjmp	.-160    	; 0x4edc <free+0x5c>
    4f7c:	e0 93 ab 65 	sts	0x65AB, r30	; 0x8065ab <__flp>
    4f80:	f0 93 ac 65 	sts	0x65AC, r31	; 0x8065ac <__flp+0x1>
    4f84:	9e cf       	rjmp	.-196    	; 0x4ec2 <free+0x42>
    4f86:	fd 01       	movw	r30, r26
    4f88:	dc 01       	movw	r26, r24
    4f8a:	c0 cf       	rjmp	.-128    	; 0x4f0c <free+0x8c>
    4f8c:	12 82       	std	Z+2, r1	; 0x02
    4f8e:	13 82       	std	Z+3, r1	; 0x03
    4f90:	d7 cf       	rjmp	.-82     	; 0x4f40 <free+0xc0>

00004f92 <abort>:
abort():
    4f92:	81 e0       	ldi	r24, 0x01	; 1
    4f94:	90 e0       	ldi	r25, 0x00	; 0
    4f96:	f8 94       	cli
    4f98:	27 c0       	rjmp	.+78     	; 0x4fe8 <__do_global_dtors>

00004f9a <memset>:
memset():
    4f9a:	dc 01       	movw	r26, r24
    4f9c:	01 c0       	rjmp	.+2      	; 0x4fa0 <memset+0x6>
    4f9e:	6d 93       	st	X+, r22
    4fa0:	41 50       	subi	r20, 0x01	; 1
    4fa2:	50 40       	sbci	r21, 0x00	; 0
    4fa4:	e0 f7       	brcc	.-8      	; 0x4f9e <memset+0x4>
    4fa6:	08 95       	ret

00004fa8 <sprintf>:
sprintf():
    4fa8:	ae e0       	ldi	r26, 0x0E	; 14
    4faa:	b0 e0       	ldi	r27, 0x00	; 0
    4fac:	e9 ed       	ldi	r30, 0xD9	; 217
    4fae:	f7 e2       	ldi	r31, 0x27	; 39
    4fb0:	5d ce       	rjmp	.-838    	; 0x4c6c <__prologue_saves__+0x1c>
    4fb2:	0d 89       	ldd	r16, Y+21	; 0x15
    4fb4:	1e 89       	ldd	r17, Y+22	; 0x16
    4fb6:	86 e0       	ldi	r24, 0x06	; 6
    4fb8:	8c 83       	std	Y+4, r24	; 0x04
    4fba:	09 83       	std	Y+1, r16	; 0x01
    4fbc:	1a 83       	std	Y+2, r17	; 0x02
    4fbe:	8f ef       	ldi	r24, 0xFF	; 255
    4fc0:	9f e7       	ldi	r25, 0x7F	; 127
    4fc2:	8d 83       	std	Y+5, r24	; 0x05
    4fc4:	9e 83       	std	Y+6, r25	; 0x06
    4fc6:	ae 01       	movw	r20, r28
    4fc8:	47 5e       	subi	r20, 0xE7	; 231
    4fca:	5f 4f       	sbci	r21, 0xFF	; 255
    4fcc:	6f 89       	ldd	r22, Y+23	; 0x17
    4fce:	78 8d       	ldd	r23, Y+24	; 0x18
    4fd0:	ce 01       	movw	r24, r28
    4fd2:	01 96       	adiw	r24, 0x01	; 1
    4fd4:	a2 db       	rcall	.-2236   	; 0x471a <vfprintf>
    4fd6:	2f 81       	ldd	r18, Y+7	; 0x07
    4fd8:	38 85       	ldd	r19, Y+8	; 0x08
    4fda:	02 0f       	add	r16, r18
    4fdc:	13 1f       	adc	r17, r19
    4fde:	f8 01       	movw	r30, r16
    4fe0:	10 82       	st	Z, r1
    4fe2:	2e 96       	adiw	r28, 0x0e	; 14
    4fe4:	e4 e0       	ldi	r30, 0x04	; 4
    4fe6:	5b ce       	rjmp	.-842    	; 0x4c9e <__epilogue_restores__+0x1c>

00004fe8 <__do_global_dtors>:
__do_global_dtors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    4fe8:	16 e0       	ldi	r17, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    4fea:	c7 e0       	ldi	r28, 0x07	; 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    4fec:	d6 e0       	ldi	r29, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    4fee:	03 c0       	rjmp	.+6      	; 0x4ff6 <__do_global_dtors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    4ff0:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    4ff2:	a4 de       	rcall	.-696    	; 0x4d3c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    4ff4:	21 96       	adiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    4ff6:	c8 30       	cpi	r28, 0x08	; 8
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    4ff8:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    4ffa:	d1 f7       	brne	.-12     	; 0x4ff0 <__do_global_dtors+0x8>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    4ffc:	f8 94       	cli

00004ffe <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    4ffe:	ff cf       	rjmp	.-2      	; 0x4ffe <__stop_program>
