
C:\Users\c40769\AppData\Local\arduino\sketches\2BFE081DF0FBD991CBB807DF7BE60B2C/Blink_dd.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	47 c0       	rjmp	.+142    	; 0x90 <__ctors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	68 c0       	rjmp	.+208    	; 0xd6 <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	66 c0       	rjmp	.+204    	; 0xd6 <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	64 c0       	rjmp	.+200    	; 0xd6 <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	62 c0       	rjmp	.+196    	; 0xd6 <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	60 c0       	rjmp	.+192    	; 0xd6 <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	5e c0       	rjmp	.+188    	; 0xd6 <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	5c c0       	rjmp	.+184    	; 0xd6 <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	5a c0       	rjmp	.+180    	; 0xd6 <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	58 c0       	rjmp	.+176    	; 0xd6 <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	56 c0       	rjmp	.+172    	; 0xd6 <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	54 c0       	rjmp	.+168    	; 0xd6 <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	52 c0       	rjmp	.+164    	; 0xd6 <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	50 c0       	rjmp	.+160    	; 0xd6 <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	4e c0       	rjmp	.+156    	; 0xd6 <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	4c c0       	rjmp	.+152    	; 0xd6 <__bad_interrupt>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	4a c0       	rjmp	.+148    	; 0xd6 <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	48 c0       	rjmp	.+144    	; 0xd6 <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	46 c0       	rjmp	.+140    	; 0xd6 <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	44 c0       	rjmp	.+136    	; 0xd6 <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	42 c0       	rjmp	.+132    	; 0xd6 <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	40 c0       	rjmp	.+128    	; 0xd6 <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	3e c0       	rjmp	.+124    	; 0xd6 <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	3c c0       	rjmp	.+120    	; 0xd6 <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	3a c0       	rjmp	.+116    	; 0xd6 <__bad_interrupt>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	38 c0       	rjmp	.+112    	; 0xd6 <__bad_interrupt>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	36 c0       	rjmp	.+108    	; 0xd6 <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	34 c0       	rjmp	.+104    	; 0xd6 <__bad_interrupt>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	32 c0       	rjmp	.+100    	; 0xd6 <__bad_interrupt>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	30 c0       	rjmp	.+96     	; 0xd6 <__bad_interrupt>
  76:	00 00       	nop
../../../../crt1/gcrt1.S:96
  78:	bf c0       	rjmp	.+382    	; 0x1f8 <__vector_30>
  7a:	00 00       	nop
../../../../crt1/gcrt1.S:97
  7c:	2c c0       	rjmp	.+88     	; 0xd6 <__bad_interrupt>
  7e:	00 00       	nop
../../../../crt1/gcrt1.S:98
  80:	2a c0       	rjmp	.+84     	; 0xd6 <__bad_interrupt>
  82:	00 00       	nop
../../../../crt1/gcrt1.S:99
  84:	28 c0       	rjmp	.+80     	; 0xd6 <__bad_interrupt>
  86:	00 00       	nop
../../../../crt1/gcrt1.S:100
  88:	26 c0       	rjmp	.+76     	; 0xd6 <__bad_interrupt>
  8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
  8c:	24 c0       	rjmp	.+72     	; 0xd6 <__bad_interrupt>
	...

00000090 <__ctors_end>:
__trampolines_start():
../../../../crt1/gcrt1.S:230
  90:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  92:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  94:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  96:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  98:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
  9a:	de bf       	out	0x3e, r29	; 62

0000009c <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:139

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  9c:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:140
    RSTCTRL.RSTFR = flags;
  a0:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f0040>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:141
    if (flags == 0) {
  a4:	81 11       	cpse	r24, r1
  a6:	05 c0       	rjmp	.+10     	; 0xb2 <_initThreeStuff()+0x16>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:142
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  a8:	98 ed       	ldi	r25, 0xD8	; 216
  aa:	21 e0       	ldi	r18, 0x01	; 1
  ac:	94 bf       	out	0x34, r25	; 52
  ae:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7f0041>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:144
    }
    GPIOR0 = flags;
  b2:	8c bb       	out	0x1c, r24	; 28
doFLMAP():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:67
      #pragma message("PROGMEM_MAPPED points to section 0 of the flash")
    #else
      #warning "no FLMAP section defined, yet LOCK_FLMAP IS!"
      temp = 0x30; // should always end up as the highest up to 3.
    #endif
    NVMCTRL.CTRLB = temp;
  b4:	10 92 01 10 	sts	0x1001, r1	; 0x801001 <__TEXT_REGION_LENGTH__+0x7f1001>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:69
    temp |= 0x80;
    _PROTECTED_WRITE(NVMCTRL_CTRLB, temp);
  b8:	88 ed       	ldi	r24, 0xD8	; 216
  ba:	90 e8       	ldi	r25, 0x80	; 128
  bc:	84 bf       	out	0x34, r24	; 52
  be:	90 93 01 10 	sts	0x1001, r25	; 0x801001 <__TEXT_REGION_LENGTH__+0x7f1001>

000000c2 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  c2:	20 e6       	ldi	r18, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  c4:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  c6:	b0 e6       	ldi	r27, 0x60	; 96
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  c8:	01 c0       	rjmp	.+2      	; 0xcc <.do_clear_bss_start>

000000ca <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  ca:	1d 92       	st	X+, r1

000000cc <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  cc:	a4 30       	cpi	r26, 0x04	; 4
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  ce:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  d0:	e1 f7       	brne	.-8      	; 0xca <.do_clear_bss_loop>
.do_clear_bss_start():
../../../../crt1/gcrt1.S:314
  d2:	ae d0       	rcall	.+348    	; 0x230 <main>
../../../../crt1/gcrt1.S:315
  d4:	1c c1       	rjmp	.+568    	; 0x30e <_exit>

000000d6 <__bad_interrupt>:
__vector_22():
  d6:	94 cf       	rjmp	.-216    	; 0x0 <__vectors>

000000d8 <micros>:
micros():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:449
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
  d8:	9f b7       	in	r25, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:450
      cli(); /* INTERRUPTS OFF */
  da:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:466
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
  dc:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7f0b2a>
  e0:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7f0b2b>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:467
        flags = _timer->INTFLAGS;
  e4:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:475
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
  e8:	20 91 00 60 	lds	r18, 0x6000	; 0x806000 <__DATA_REGION_ORIGIN__>
  ec:	30 91 01 60 	lds	r19, 0x6001	; 0x806001 <__DATA_REGION_ORIGIN__+0x1>
  f0:	40 91 02 60 	lds	r20, 0x6002	; 0x806002 <__DATA_REGION_ORIGIN__+0x2>
  f4:	50 91 03 60 	lds	r21, 0x6003	; 0x806003 <__DATA_REGION_ORIGIN__+0x3>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:480
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
  f8:	9f bf       	out	0x3f, r25	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:490
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  fa:	80 ff       	sbrs	r24, 0
  fc:	08 c0       	rjmp	.+16     	; 0x10e <__EEPROM_REGION_LENGTH__+0xe>
  fe:	cf 01       	movw	r24, r30
 100:	88 27       	eor	r24, r24
 102:	89 2b       	or	r24, r25
 104:	21 f4       	brne	.+8      	; 0x10e <__EEPROM_REGION_LENGTH__+0xe>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:495
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
 106:	2f 5f       	subi	r18, 0xFF	; 255
 108:	3f 4f       	sbci	r19, 0xFF	; 255
 10a:	4f 4f       	sbci	r20, 0xFF	; 255
 10c:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:785
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.

        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          // The terrible twelves!
            __asm__ __volatile__(
 10e:	0f 01       	movw	r0, r30
 110:	16 94       	lsr	r1
 112:	07 94       	ror	r0
 114:	16 94       	lsr	r1
 116:	07 94       	ror	r0
 118:	16 94       	lsr	r1
 11a:	07 94       	ror	r0
 11c:	16 94       	lsr	r1
 11e:	07 94       	ror	r0
 120:	f0 01       	movw	r30, r0
 122:	16 94       	lsr	r1
 124:	07 94       	ror	r0
 126:	e0 0d       	add	r30, r0
 128:	f1 1d       	adc	r31, r1
 12a:	16 94       	lsr	r1
 12c:	07 94       	ror	r0
 12e:	10 2c       	mov	r1, r0
 130:	16 94       	lsr	r1
 132:	01 18       	sub	r0, r1
 134:	16 94       	lsr	r1
 136:	01 0c       	add	r0, r1
 138:	16 94       	lsr	r1
 13a:	01 18       	sub	r0, r1
 13c:	16 94       	lsr	r1
 13e:	01 0c       	add	r0, r1
 140:	16 94       	lsr	r1
 142:	01 18       	sub	r0, r1
 144:	16 94       	lsr	r1
 146:	16 94       	lsr	r1
 148:	01 0c       	add	r0, r1
 14a:	11 24       	eor	r1, r1
 14c:	e0 19       	sub	r30, r0
 14e:	f1 09       	sbc	r31, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:830
          "add r0,r1"     "\n\t"  // + ticks >> 9
          "eor r1,r1"     "\n\t"  // clear out r1
          "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
          "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
          : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
        microseconds = overflows * 1000 + ticks;
 150:	a8 ee       	ldi	r26, 0xE8	; 232
 152:	b3 e0       	ldi	r27, 0x03	; 3
 154:	c3 d0       	rcall	.+390    	; 0x2dc <__muluhisi3>
 156:	6e 0f       	add	r22, r30
 158:	7f 1f       	adc	r23, r31
 15a:	81 1d       	adc	r24, r1
 15c:	91 1d       	adc	r25, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1039
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
 15e:	08 95       	ret

00000160 <delay.constprop.4>:
delay.constprop.4():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1100


#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
 160:	cf 92       	push	r12
 162:	df 92       	push	r13
 164:	ef 92       	push	r14
 166:	ff 92       	push	r15
 168:	cf 93       	push	r28
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1102
  {
    uint16_t start = (uint16_t)micros();
 16a:	df 93       	push	r29
 16c:	b5 df       	rcall	.-150    	; 0xd8 <micros>
 16e:	eb 01       	movw	r28, r22
 170:	84 ef       	ldi	r24, 0xF4	; 244
 172:	c8 2e       	mov	r12, r24
 174:	dd 24       	eor	r13, r13
 176:	d3 94       	inc	r13
 178:	e1 2c       	mov	r14, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1106
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
 17a:	f1 2c       	mov	r15, r1
 17c:	ad df       	rcall	.-166    	; 0xd8 <micros>
 17e:	6c 1b       	sub	r22, r28
 180:	7d 0b       	sbc	r23, r29
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1107
      if (us_passed >= 1000) {
 182:	68 3e       	cpi	r22, 0xE8	; 232
 184:	73 40       	sbci	r23, 0x03	; 3
 186:	d0 f3       	brcs	.-12     	; 0x17c <delay.constprop.4+0x1c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1108
        ms--;
 188:	81 e0       	ldi	r24, 0x01	; 1
 18a:	c8 1a       	sub	r12, r24
 18c:	d1 08       	sbc	r13, r1
 18e:	e1 08       	sbc	r14, r1
 190:	f1 08       	sbc	r15, r1
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1109
        start += 1000;
 192:	c8 51       	subi	r28, 0x18	; 24
 194:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1104
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
 196:	c1 14       	cp	r12, r1
 198:	d1 04       	cpc	r13, r1
 19a:	e1 04       	cpc	r14, r1
 19c:	f1 04       	cpc	r15, r1
 19e:	71 f7       	brne	.-36     	; 0x17c <delay.constprop.4+0x1c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1112
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
 1a0:	df 91       	pop	r29
 1a2:	cf 91       	pop	r28
 1a4:	ff 90       	pop	r15
 1a6:	ef 90       	pop	r14
 1a8:	df 90       	pop	r13
 1aa:	cf 90       	pop	r12
 1ac:	08 95       	ret

000001ae <digitalWrite.constprop.0>:
digitalWrite.constprop.0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:227
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
 1ae:	90 e2       	ldi	r25, 0x20	; 32
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 1b0:	81 11       	cpse	r24, r1
 1b2:	1b c0       	rjmp	.+54     	; 0x1ea <digitalWrite.constprop.0+0x3c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
 1b4:	90 93 a6 04 	sts	0x04A6, r25	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7f04a6>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 1b8:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <__TEXT_REGION_LENGTH__+0x7f04a0>
 1bc:	95 fd       	sbrc	r25, 5
 1be:	0a c0       	rjmp	.+20     	; 0x1d4 <digitalWrite.constprop.0+0x26>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:264

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 1c0:	9f b7       	in	r25, 0x3f	; 63
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:265
    cli();
 1c2:	f8 94       	cli
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:267

    if (val == LOW) {
 1c4:	81 11       	cpse	r24, r1
 1c6:	14 c0       	rjmp	.+40     	; 0x1f0 <digitalWrite.constprop.0+0x42>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 1c8:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
 1cc:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 1ce:	80 93 b5 04 	sts	0x04B5, r24	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
 1d2:	9f bf       	out	0x3f, r25	; 63
digitalPinToTimerNow():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_analog.c:531
        return TIMERA1;                              /* mux options, not 3-channel ones on bit 4:6 */
      }
    }
  #elif defined(TCA0)
    if (__PeripheralControl & TIMERA0) {               /* here we don't need to store tcamux */
      if ((PORTMUX.TCAROUTEA & PORTMUX_TCA0_gm) == port) { /* because it is only used once */
 1d4:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
 1d8:	87 70       	andi	r24, 0x07	; 7
 1da:	85 30       	cpi	r24, 0x05	; 5
 1dc:	29 f4       	brne	.+10     	; 0x1e8 <digitalWrite.constprop.0+0x3a>
turnOffPWM():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:130
  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
 1de:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
 1e2:	8f 7b       	andi	r24, 0xBF	; 191
 1e4:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7f0a01>
digitalWrite.constprop.0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 1e8:	08 95       	ret
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 1ea:	90 93 a5 04 	sts	0x04A5, r25	; 0x8004a5 <__TEXT_REGION_LENGTH__+0x7f04a5>
 1ee:	e4 cf       	rjmp	.-56     	; 0x1b8 <digitalWrite.constprop.0+0xa>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 1f0:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <__TEXT_REGION_LENGTH__+0x7f04b5>
 1f4:	88 60       	ori	r24, 0x08	; 8
 1f6:	eb cf       	rjmp	.-42     	; 0x1ce <digitalWrite.constprop.0+0x20>

000001f8 <__vector_30>:
__vector_30():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:135
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #elif !defined(MILLIS_USE_TIMERNONE)
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
 1f8:	ef 93       	push	r30
 1fa:	ff 93       	push	r31
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:140
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
 1fc:	e0 e0       	ldi	r30, 0x00	; 0
 1fe:	f0 e6       	ldi	r31, 0x60	; 96
 200:	8f 93       	push	r24
 202:	8f b7       	in	r24, 0x3f	; 63
 204:	8f 93       	push	r24
 206:	80 81       	ld	r24, Z
 208:	8f 5f       	subi	r24, 0xFF	; 255
 20a:	80 83       	st	Z, r24
 20c:	81 81       	ldd	r24, Z+1	; 0x01
 20e:	8f 4f       	sbci	r24, 0xFF	; 255
 210:	81 83       	std	Z+1, r24	; 0x01
 212:	82 81       	ldd	r24, Z+2	; 0x02
 214:	8f 4f       	sbci	r24, 0xFF	; 255
 216:	82 83       	std	Z+2, r24	; 0x02
 218:	83 81       	ldd	r24, Z+3	; 0x03
 21a:	8f 4f       	sbci	r24, 0xFF	; 255
 21c:	83 83       	std	Z+3, r24	; 0x03
 21e:	81 e0       	ldi	r24, 0x01	; 1
 220:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7f0b26>
 224:	8f 91       	pop	r24
 226:	8f bf       	out	0x3f, r24	; 63
 228:	8f 91       	pop	r24
 22a:	ff 91       	pop	r31
 22c:	ef 91       	pop	r30
 22e:	18 95       	reti

00000230 <main>:
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1885
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
      #elif (F_CPU == 28000000)
        /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
      #elif (F_CPU == 24000000)
        _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
 230:	88 ed       	ldi	r24, 0xD8	; 216
 232:	94 e2       	ldi	r25, 0x24	; 36
 234:	84 bf       	out	0x34, r24	; 52
 236:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7f0068>
init_TCA0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2241
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
 23a:	c1 e0       	ldi	r28, 0x01	; 1
 23c:	c0 93 03 0a 	sts	0x0A03, r28	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7f0a03>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2246

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 240:	8e ef       	ldi	r24, 0xFE	; 254
 242:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7f0a26>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2247
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 246:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7f0a27>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2274
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
 24a:	9b e0       	ldi	r25, 0x0B	; 11
 24c:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7f0a00>
init_timers():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2222
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    init_TCA1();
  #else
    PORTMUX.TCAROUTEA = TCA0_PINS;
 250:	95 e0       	ldi	r25, 0x05	; 5
 252:	90 93 e7 05 	sts	0x05E7, r25	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7f05e7>
init_TCBs():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2352
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
 256:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7f05e8>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2424
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
 25a:	27 e0       	ldi	r18, 0x07	; 7
 25c:	20 93 01 0b 	sts	0x0B01, r18	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7f0b01>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2427

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
 260:	80 93 0c 0b 	sts	0x0B0C, r24	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7f0b0c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2430
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
 264:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7f0b0d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2433

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
 268:	90 93 00 0b 	sts	0x0B00, r25	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7f0b00>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2424
    #elif defined(MILLIS_USE_TIMERB7)
      if(timer_B != (TCB_t *)&TCB7)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
 26c:	20 93 11 0b 	sts	0x0B11, r18	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7f0b11>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2427

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
 270:	80 93 1c 0b 	sts	0x0B1C, r24	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7f0b1c>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2430
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
 274:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7f0b1d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2433

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
 278:	90 93 10 0b 	sts	0x0B10, r25	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7f0b10>
init_TCD0():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2477
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
 27c:	8f ef       	ldi	r24, 0xFF	; 255
 27e:	9f e0       	ldi	r25, 0x0F	; 15
 280:	80 93 aa 0b 	sts	0x0BAA, r24	; 0x800baa <__TEXT_REGION_LENGTH__+0x7f0baa>
 284:	90 93 ab 0b 	sts	0x0BAB, r25	; 0x800bab <__TEXT_REGION_LENGTH__+0x7f0bab>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2481
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
 288:	80 e8       	ldi	r24, 0x80	; 128
 28a:	80 93 82 0b 	sts	0x0B82, r24	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7f0b82>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2483
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
 28e:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7f0b81>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2486
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
 292:	8b ef       	ldi	r24, 0xFB	; 251
 294:	93 e0       	ldi	r25, 0x03	; 3
 296:	80 93 ae 0b 	sts	0x0BAE, r24	; 0x800bae <__TEXT_REGION_LENGTH__+0x7f0bae>
 29a:	90 93 af 0b 	sts	0x0BAF, r25	; 0x800baf <__TEXT_REGION_LENGTH__+0x7f0baf>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2495
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
 29e:	81 e7       	ldi	r24, 0x71	; 113
 2a0:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7f0b80>
init_timers():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2228
  #endif
  init_TCBs();
  #if (defined(TCD0) && defined(USE_TIMERD0_PWM) && !defined(MILLIS_USE_TIMERD0))
    init_TCD0();
    #if defined(ERRATA_TCD_PORTMUX) && ERRATA_TCD_PORTMUX == 0 && defined(TCD0_PINS)
      PORTMUX.TCDROUTEA = TCD0_PINS;
 2a4:	10 92 e9 05 	sts	0x05E9, r1	; 0x8005e9 <__TEXT_REGION_LENGTH__+0x7f05e9>
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:2513
    // but due to a silicon bug, the input buffer is on, but it's input is floating. Per errata, we are supposed to turn it off.
    PORTD.PIN0CTRL = PORT_ISC_INPUT_DISABLE_gc;
  #endif
  init_clock();
  init_timers();
  init_ADC0();
 2a8:	0e 94 00 00 	call	0	; 0x0 <__vectors>
init_millis():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1722
        #endif
        RTC.INTCTRL         = 0x01; // enable overflow interrupt
        RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
      */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
 2ac:	8f ed       	ldi	r24, 0xDF	; 223
 2ae:	9e e2       	ldi	r25, 0x2E	; 46
 2b0:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7f0b2c>
 2b4:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7f0b2d>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1724
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
 2b8:	c0 93 25 0b 	sts	0x0B25, r28	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7f0b25>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1726
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
 2bc:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7f0b21>
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring.c:1728
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
 2c0:	83 e0       	ldi	r24, 0x03	; 3
 2c2:	80 93 20 0b 	sts	0x0B20, r24	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7f0b20>
main():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/main.cpp:88
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 2c6:	78 94       	sei
_pinMode():
C:\Users\c40769\AppData\Local\Arduino15\packages\microchip\hardware\megaavr\1.0\cores\avrcore/wiring_digital.c:86
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
 2c8:	80 e2       	ldi	r24, 0x20	; 32
 2ca:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7f04a1>
loop():
C:\Users\c40769\active_projects\AVRCore\test_code\Blink_dd/Blink_dd.ino:33
  pinMode(PIN_PF5, OUTPUT);
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite(PIN_PF5, HIGH);  // turn the LED on (HIGH is the voltage level)
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	6e df       	rcall	.-292    	; 0x1ae <digitalWrite.constprop.0>
C:\Users\c40769\active_projects\AVRCore\test_code\Blink_dd/Blink_dd.ino:34
  delay(500);                      // wait for a second
 2d2:	46 df       	rcall	.-372    	; 0x160 <delay.constprop.4>
C:\Users\c40769\active_projects\AVRCore\test_code\Blink_dd/Blink_dd.ino:35
  digitalWrite(PIN_PF5, LOW);   // turn the LED off by making the voltage LOW
 2d4:	80 e0       	ldi	r24, 0x00	; 0
 2d6:	6b df       	rcall	.-298    	; 0x1ae <digitalWrite.constprop.0>
C:\Users\c40769\active_projects\AVRCore\test_code\Blink_dd/Blink_dd.ino:36
  delay(500);                      // wait for a second
 2d8:	43 df       	rcall	.-378    	; 0x160 <delay.constprop.4>
 2da:	f9 cf       	rjmp	.-14     	; 0x2ce <main+0x9e>

000002dc <__muluhisi3>:
__muluhisi3():
 2dc:	09 d0       	rcall	.+18     	; 0x2f0 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 2de:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 2e0:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 2e2:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 2e4:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 2e6:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 2e8:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 2ea:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 2ec:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 2ee:	08 95       	ret

000002f0 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 2f0:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 2f2:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 2f4:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 2f6:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 2f8:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
 2fa:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
 2fc:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
 2fe:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
 300:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 302:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 304:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 306:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 308:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 30a:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 30c:	08 95       	ret

0000030e <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 30e:	f8 94       	cli

00000310 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega2/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 310:	ff cf       	rjmp	.-2      	; 0x310 <__stop_program>
